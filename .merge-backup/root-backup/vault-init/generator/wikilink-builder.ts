import type { WikiLink, NodeData } from './types';

/**
 * Build wikilinks for Obsidian nodes based on relationships
 */

/**
 * Format a wikilink for Obsidian
 */
export function formatWikiLink(link: WikiLink): string {
  if (link.alias) {
    return `[[${link.target}|${link.alias}]]`;
  }
  return `[[${link.target}]]`;
}

/**
 * Parse a wikilink string into WikiLink object
 */
export function parseWikiLink(linkString: string): WikiLink | null {
  const wikilinkRegex = /\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/;
  const match = linkString.match(wikilinkRegex);

  if (!match) {
    return null;
  }

  return {
    target: match[1]?.trim() ?? '',
    alias: match[2]?.trim(),
  };
}

/**
 * Generate automatic wikilinks based on node type and content
 */
export function generateAutoLinks(
  nodeData: NodeData,
  relatedNodes?: NodeData[]
): WikiLink[] {
  const links: WikiLink[] = [];

  // Add user-provided links
  if (nodeData.links) {
    nodeData.links.forEach((linkTarget) => {
      links.push({ target: linkTarget });
    });
  }

  // Generate links to related nodes
  if (relatedNodes) {
    const autoGeneratedLinks = findRelatedNodes(nodeData, relatedNodes);
    links.push(...autoGeneratedLinks);
  }

  // Remove duplicates based on target
  return deduplicateLinks(links);
}

/**
 * Find related nodes based on tags, type, and content similarity
 */
function findRelatedNodes(
  nodeData: NodeData,
  candidateNodes: NodeData[]
): WikiLink[] {
  const links: WikiLink[] = [];

  for (const candidate of candidateNodes) {
    // Skip self
    if (candidate.name === nodeData.name) {
      continue;
    }

    const relevanceScore = calculateRelevance(nodeData, candidate);

    // Only link if relevance score is above threshold (0.3 = 30% match)
    if (relevanceScore > 0.3) {
      links.push({
        target: candidate.name,
        type: candidate.type,
      });
    }
  }

  return links;
}

/**
 * Calculate relevance score between two nodes (0-1)
 */
function calculateRelevance(node1: NodeData, node2: NodeData): number {
  let score = 0;

  // Same type increases relevance
  if (node1.type === node2.type) {
    score += 0.2;
  }

  // Shared tags increase relevance significantly
  if (node1.tags && node2.tags) {
    const sharedTags = node1.tags.filter((tag) => node2.tags?.includes(tag));
    if (sharedTags.length > 0) {
      const tagScore = sharedTags.length / Math.max(node1.tags.length, node2.tags.length);
      score += tagScore * 0.5;
    }
  }

  // Content similarity (simple keyword matching)
  if (node1.content && node2.content) {
    const contentScore = calculateContentSimilarity(
      node1.content,
      node2.content
    );
    score += contentScore * 0.2;
  }

  // Description similarity
  if (node1.description && node2.description) {
    const descScore = calculateContentSimilarity(
      node1.description,
      node2.description
    );
    score += descScore * 0.1;
  }

  return score;
}

/**
 * Calculate simple content similarity based on common words
 */
function calculateContentSimilarity(content1: string, content2: string): number {
  const words1 = extractKeywords(content1);
  const words2 = extractKeywords(content2);

  if (words1.length === 0 || words2.length === 0) {
    return 0;
  }

  const commonWords = words1.filter((word) => words2.includes(word));
  return commonWords.length / Math.max(words1.length, words2.length);
}

/**
 * Extract keywords from text (simple implementation)
 */
function extractKeywords(text: string): string[] {
  // Common stop words to filter out
  const stopWords = new Set([
    'the',
    'a',
    'an',
    'and',
    'or',
    'but',
    'in',
    'on',
    'at',
    'to',
    'for',
    'of',
    'with',
    'by',
    'from',
    'as',
    'is',
    'was',
    'are',
    'were',
    'been',
    'be',
    'have',
    'has',
    'had',
    'do',
    'does',
    'did',
    'will',
    'would',
    'could',
    'should',
    'may',
    'might',
    'must',
    'can',
    'this',
    'that',
    'these',
    'those',
  ]);

  return text
    .toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .split(/\s+/)
    .filter((word) => word.length > 3 && !stopWords.has(word))
    .slice(0, 20); // Limit to top 20 keywords
}

/**
 * Remove duplicate links based on target
 */
function deduplicateLinks(links: WikiLink[]): WikiLink[] {
  const seen = new Map<string, WikiLink>();

  for (const link of links) {
    const key = link.target.toLowerCase();
    if (!seen.has(key)) {
      seen.set(key, link);
    }
  }

  return Array.from(seen.values());
}

/**
 * Group links by type
 */
export function groupLinksByType(
  links: WikiLink[]
): Record<string, WikiLink[]> {
  const grouped: Record<string, WikiLink[]> = {
    concept: [],
    technical: [],
    feature: [],
    external: [],
    unknown: [],
  };

  for (const link of links) {
    const type = link.type || 'unknown';
    if (!grouped[type]) {
      grouped[type] = [];
    }
    grouped[type].push(link);
  }

  return grouped;
}

/**
 * Format links section for markdown
 */
export function formatLinksSection(links: WikiLink[]): string {
  if (links.length === 0) {
    return '';
  }

  const grouped = groupLinksByType(links);
  const sections: string[] = [];

  // Add sections for each type that has links
  if ((grouped['concept'] ?? []).length > 0) {
    sections.push(
      '### Related Concepts\n\n' +
        (grouped['concept'] ?? []).map((l) => `- ${formatWikiLink(l)}`).join('\n')
    );
  }

  if ((grouped['technical'] ?? []).length > 0) {
    sections.push(
      '### Technical References\n\n' +
        (grouped['technical'] ?? []).map((l) => `- ${formatWikiLink(l)}`).join('\n')
    );
  }

  if ((grouped['feature'] ?? []).length > 0) {
    sections.push(
      '### Related Features\n\n' +
        (grouped['feature'] ?? []).map((l) => `- ${formatWikiLink(l)}`).join('\n')
    );
  }

  if ((grouped['external'] ?? []).length > 0) {
    sections.push(
      '### External Resources\n\n' +
        (grouped['external'] ?? []).map((l) => `- ${formatWikiLink(l)}`).join('\n')
    );
  }

  if ((grouped['unknown'] ?? []).length > 0) {
    sections.push(
      '### See Also\n\n' +
        (grouped['unknown'] ?? []).map((l) => `- ${formatWikiLink(l)}`).join('\n')
    );
  }

  return '\n## Links\n\n' + sections.join('\n\n');
}

/**
 * Extract all wikilinks from markdown content
 */
export function extractWikiLinks(markdownContent: string): WikiLink[] {
  const wikilinkRegex = /\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g;
  const links: WikiLink[] = [];
  let match;

  while ((match = wikilinkRegex.exec(markdownContent)) !== null) {
    links.push({
      target: match[1]?.trim() ?? '',
      alias: match[2]?.trim(),
    });
  }

  return links;
}

/**
 * Sanitize node name for use in wikilinks
 */
export function sanitizeNodeName(name: string): string {
  return name
    .trim()
    .replace(/[<>:"/\\|?*\[\]]/g, '-') // Replace invalid filename chars (including brackets)
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/-+/g, '-') // Replace multiple hyphens with single
    .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
}
