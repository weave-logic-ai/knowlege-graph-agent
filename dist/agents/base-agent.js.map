{"version":3,"file":"base-agent.js","sources":["../../src/agents/base-agent.ts"],"sourcesContent":["/**\n * Base Agent Implementation\n *\n * Abstract base class for all agents providing common functionality\n * including task execution, input validation, output formatting,\n * error handling, and optional claude-flow integration.\n *\n * @module agents/base-agent\n */\n\nimport { getLogger, retry, type Logger, type RetryOptions } from '../utils/index.js';\nimport {\n  AgentType,\n  AgentStatus,\n  TaskPriority,\n  MessageType,\n  type AgentConfig,\n  type AgentInstance,\n  type AgentState,\n  type AgentTask,\n  type AgentResult,\n  type AgentError,\n  type AgentMessage,\n  type ExecutionMetrics,\n  type ResultArtifact,\n  createAgentId,\n  createTaskId,\n} from './types.js';\nimport {\n  TrajectoryTracker,\n  type TrajectoryTrackerConfig,\n} from '../learning/services/trajectory-tracker.js';\nimport type { TrajectoryStep } from '../integrations/agentic-flow/adapters/reasoning-bank-adapter.js';\n\n// ============================================================================\n// Base Agent Abstract Class\n// ============================================================================\n\n/**\n * Abstract base class for all agents\n *\n * Provides common functionality that all agents share, including:\n * - Task execution with timeout and retry handling\n * - Input validation\n * - Output formatting\n * - Error handling and logging\n * - Optional claude-flow hooks integration\n *\n * @example\n * ```typescript\n * class ResearchAgent extends BaseAgent {\n *   protected async executeTask(task: AgentTask): Promise<AgentResult> {\n *     // Implementation specific to researcher agent\n *     const results = await this.searchSources(task.input);\n *     return this.formatOutput(results);\n *   }\n * }\n * ```\n */\nexport abstract class BaseAgent implements AgentInstance {\n  /** Agent configuration */\n  public readonly config: AgentConfig;\n\n  /** Agent runtime state */\n  private _state: AgentState;\n\n  /** Logger instance */\n  protected readonly logger: Logger;\n\n  /** Message handlers for different message types */\n  private messageHandlers: Map<MessageType, (message: AgentMessage) => Promise<void>> =\n    new Map();\n\n  /** Trajectory tracker for learning */\n  protected trajectoryTracker: TrajectoryTracker | null = null;\n\n  /** Current active trajectory ID */\n  protected currentTrajectoryId: string | null = null;\n\n  /** Whether to auto-track trajectories */\n  protected autoTrackTrajectories: boolean = true;\n\n  constructor(config: AgentConfig) {\n    // Ensure ID is set\n    this.config = {\n      ...config,\n      id: config.id ?? createAgentId(config.type),\n    };\n\n    // Initialize state\n    this._state = {\n      id: this.config.id!,\n      status: AgentStatus.IDLE,\n      taskQueue: [],\n      completedTasks: [],\n      lastActivity: new Date(),\n      errorCount: 0,\n    };\n\n    // Create logger\n    this.logger = getLogger().child(`agent:${this.config.name}`);\n\n    // Register default message handlers\n    this.registerDefaultMessageHandlers();\n  }\n\n  // ============================================================================\n  // State Management\n  // ============================================================================\n\n  /**\n   * Get current agent state\n   */\n  get state(): AgentState {\n    return { ...this._state };\n  }\n\n  /**\n   * Get current agent status\n   */\n  getStatus(): AgentStatus {\n    return this._state.status;\n  }\n\n  /**\n   * Update agent status\n   */\n  protected setStatus(status: AgentStatus): void {\n    const previousStatus = this._state.status;\n    this._state.status = status;\n    this._state.lastActivity = new Date();\n\n    if (previousStatus !== status) {\n      this.logger.debug(`Status changed: ${previousStatus} -> ${status}`);\n    }\n  }\n\n  // ============================================================================\n  // Task Execution\n  // ============================================================================\n\n  /**\n   * Execute a task\n   *\n   * This is the main entry point for task execution. It handles:\n   * - Pre-task hooks (if enabled)\n   * - Input validation\n   * - Retry logic\n   * - Timeout handling\n   * - Post-task hooks (if enabled)\n   * - Error handling and logging\n   */\n  async execute(task: AgentTask): Promise<AgentResult> {\n    const startTime = new Date();\n\n    this.logger.info(`Executing task: ${task.id}`, {\n      description: task.description,\n      priority: task.priority,\n    });\n\n    // Run pre-task hook if enabled\n    if (this.config.claudeFlow?.hooks?.preTask) {\n      await this.runClaudeFlowHook('pre-task', task);\n    }\n\n    // Start trajectory tracking if enabled\n    if (this.autoTrackTrajectories && this.trajectoryTracker?.isEnabled()) {\n      this.startTrajectory(task.id, {\n        description: task.description,\n        priority: task.priority,\n        input: task.input,\n      });\n      this.recordStep('task_started', `Starting task: ${task.description}`, 1.0);\n    }\n\n    try {\n      // Validate input\n      const validationResult = await this.validateInput(task);\n      if (!validationResult.valid) {\n        this.recordStep('validation_failed', validationResult.error ?? 'Input validation failed', 0.0);\n        await this.completeTrajectory('failure', { validationError: validationResult.error });\n        return this.createErrorResult(\n          'VALIDATION_ERROR',\n          validationResult.error ?? 'Input validation failed',\n          startTime\n        );\n      }\n\n      this.recordStep('validation_passed', 'Input validation successful', 1.0);\n\n      // Set status to running\n      this.setStatus(AgentStatus.RUNNING);\n      this._state.currentTask = task;\n\n      // Execute with retry if configured\n      let result: AgentResult;\n      const retryConfig = this.config.retry;\n\n      if (retryConfig && retryConfig.maxRetries > 0) {\n        const retryOptions: RetryOptions = {\n          maxRetries: retryConfig.maxRetries,\n          initialDelay: retryConfig.backoffMs,\n          backoffFactor: retryConfig.backoffMultiplier ?? 2,\n          isRetryable: (error: unknown) => this.isRetryableError(error),\n        };\n\n        result = await retry(\n          async () => this.executeWithTimeout(task),\n          retryOptions\n        );\n      } else {\n        result = await this.executeWithTimeout(task);\n      }\n\n      // Update state on success\n      if (result.success) {\n        this._state.completedTasks.push(task.id);\n        this.setStatus(AgentStatus.COMPLETED);\n        this.recordStep('task_completed', 'Task completed successfully', 1.0, { success: true });\n        await this.completeTrajectory('success', {\n          durationMs: result.metrics?.durationMs,\n          artifactCount: result.artifacts?.length ?? 0,\n        });\n      } else {\n        this._state.errorCount++;\n        this.setStatus(AgentStatus.FAILED);\n        this.recordStep('task_failed', result.error?.message ?? 'Task failed', 0.0, { error: result.error });\n        await this.completeTrajectory('failure', {\n          errorCode: result.error?.code,\n          errorMessage: result.error?.message,\n        });\n      }\n\n      // Add metrics\n      result.metrics = this.calculateMetrics(startTime, new Date());\n\n      // Run post-task hook if enabled\n      if (this.config.claudeFlow?.hooks?.postTask) {\n        await this.runClaudeFlowHook('post-task', task, result);\n      }\n\n      return result;\n    } catch (error) {\n      this._state.errorCount++;\n      this.setStatus(AgentStatus.FAILED);\n\n      const agentError = this.normalizeError(error);\n      this.logger.error(`Task execution failed: ${task.id}`, error as Error);\n\n      // Record trajectory failure\n      this.recordStep('task_exception', agentError.message, 0.0, {\n        errorCode: agentError.code,\n        stack: agentError.stack,\n      });\n      await this.completeTrajectory('failure', {\n        exception: true,\n        errorCode: agentError.code,\n        errorMessage: agentError.message,\n      });\n\n      return this.createErrorResult(agentError.code, agentError.message, startTime, {\n        stack: agentError.stack,\n        retryable: agentError.retryable,\n      });\n    } finally {\n      this._state.currentTask = undefined;\n      this._state.lastActivity = new Date();\n    }\n  }\n\n  /**\n   * Execute task with timeout\n   */\n  private async executeWithTimeout(task: AgentTask): Promise<AgentResult> {\n    const timeout = task.timeout ?? this.config.taskTimeout ?? 30000;\n\n    return new Promise<AgentResult>((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error(`Task execution timed out after ${timeout}ms`));\n      }, timeout);\n\n      this.executeTask(task)\n        .then((result) => {\n          clearTimeout(timer);\n          resolve(result);\n        })\n        .catch((error) => {\n          clearTimeout(timer);\n          reject(error);\n        });\n    });\n  }\n\n  /**\n   * Abstract method for actual task execution\n   *\n   * Subclasses must implement this method with their specific logic.\n   */\n  protected abstract executeTask(task: AgentTask): Promise<AgentResult>;\n\n  // ============================================================================\n  // Input Validation\n  // ============================================================================\n\n  /**\n   * Validate task input\n   *\n   * Override this method to implement custom validation logic.\n   */\n  async validateInput(task: AgentTask): Promise<{ valid: boolean; error?: string }> {\n    // Basic validation\n    if (!task.id) {\n      return { valid: false, error: 'Task ID is required' };\n    }\n\n    if (!task.description) {\n      return { valid: false, error: 'Task description is required' };\n    }\n\n    // Check dependencies are resolved\n    if (task.dependencies && task.dependencies.length > 0) {\n      const unresolvedDeps = task.dependencies.filter(\n        (dep) => !this._state.completedTasks.includes(dep)\n      );\n\n      if (unresolvedDeps.length > 0) {\n        return {\n          valid: false,\n          error: `Unresolved dependencies: ${unresolvedDeps.join(', ')}`,\n        };\n      }\n    }\n\n    return { valid: true };\n  }\n\n  // ============================================================================\n  // Output Formatting\n  // ============================================================================\n\n  /**\n   * Format successful output\n   */\n  formatOutput<T>(data: T, artifacts?: ResultArtifact[]): AgentResult<T> {\n    return {\n      success: true,\n      data,\n      artifacts,\n      metadata: {\n        agentId: this.config.id,\n        agentType: this.config.type,\n        timestamp: new Date().toISOString(),\n      },\n    };\n  }\n\n  /**\n   * Create a success result\n   */\n  protected createSuccessResult<T>(\n    data: T,\n    startTime: Date,\n    artifacts?: ResultArtifact[]\n  ): AgentResult<T> {\n    return {\n      success: true,\n      data,\n      artifacts,\n      metrics: this.calculateMetrics(startTime, new Date()),\n      metadata: {\n        agentId: this.config.id,\n        agentType: this.config.type,\n      },\n    };\n  }\n\n  /**\n   * Create an error result\n   */\n  protected createErrorResult(\n    code: string,\n    message: string,\n    startTime: Date,\n    details?: Partial<AgentError>\n  ): AgentResult {\n    return {\n      success: false,\n      error: {\n        code,\n        message,\n        ...details,\n      },\n      metrics: this.calculateMetrics(startTime, new Date()),\n      metadata: {\n        agentId: this.config.id,\n        agentType: this.config.type,\n      },\n    };\n  }\n\n  /**\n   * Calculate execution metrics\n   */\n  private calculateMetrics(startTime: Date, endTime: Date): ExecutionMetrics {\n    return {\n      startTime,\n      endTime,\n      durationMs: endTime.getTime() - startTime.getTime(),\n      memoryUsage: process.memoryUsage?.().heapUsed,\n      retries: 0, // Updated by retry logic if needed\n    };\n  }\n\n  // ============================================================================\n  // Error Handling\n  // ============================================================================\n\n  /**\n   * Normalize error to AgentError format\n   */\n  private normalizeError(error: unknown): AgentError {\n    if (error instanceof Error) {\n      return {\n        code: error.name || 'UNKNOWN_ERROR',\n        message: error.message,\n        stack: error.stack,\n        retryable: this.isRetryableError(error),\n      };\n    }\n\n    return {\n      code: 'UNKNOWN_ERROR',\n      message: String(error),\n      retryable: false,\n    };\n  }\n\n  /**\n   * Check if an error is retryable\n   */\n  protected isRetryableError(error: unknown): boolean {\n    if (error instanceof Error) {\n      const message = error.message.toLowerCase();\n\n      // Network/transient errors\n      if (\n        message.includes('timeout') ||\n        message.includes('network') ||\n        message.includes('connection') ||\n        message.includes('econnreset') ||\n        message.includes('rate limit')\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // ============================================================================\n  // Lifecycle Methods\n  // ============================================================================\n\n  /**\n   * Pause the agent\n   */\n  async pause(): Promise<void> {\n    if (this._state.status === AgentStatus.RUNNING) {\n      this.logger.info('Pausing agent');\n      this.setStatus(AgentStatus.PAUSED);\n    }\n  }\n\n  /**\n   * Resume the agent\n   */\n  async resume(): Promise<void> {\n    if (this._state.status === AgentStatus.PAUSED) {\n      this.logger.info('Resuming agent');\n      this.setStatus(AgentStatus.IDLE);\n    }\n  }\n\n  /**\n   * Terminate the agent\n   */\n  async terminate(): Promise<void> {\n    this.logger.info('Terminating agent');\n\n    // Clean up any resources\n    await this.cleanup();\n\n    this.setStatus(AgentStatus.TERMINATED);\n  }\n\n  /**\n   * Cleanup resources\n   *\n   * Override to implement custom cleanup logic.\n   */\n  protected async cleanup(): Promise<void> {\n    // Default: no cleanup needed\n  }\n\n  // ============================================================================\n  // Messaging\n  // ============================================================================\n\n  /**\n   * Send a message to another agent\n   */\n  async sendMessage(message: AgentMessage): Promise<void> {\n    this.logger.debug(`Sending message to ${message.to}`, {\n      type: message.type,\n      correlationId: message.correlationId,\n    });\n\n    // In a real implementation, this would use a message bus\n    // For now, just log the message\n    this.logger.trace('Message payload', { payload: message.payload });\n  }\n\n  /**\n   * Receive and process a message\n   */\n  async receiveMessage(message: AgentMessage): Promise<void> {\n    this.logger.debug(`Received message from ${message.from}`, {\n      type: message.type,\n      correlationId: message.correlationId,\n    });\n\n    const handler = this.messageHandlers.get(message.type);\n    if (handler) {\n      await handler(message);\n    } else {\n      this.logger.warn(`No handler for message type: ${message.type}`);\n    }\n  }\n\n  /**\n   * Register a message handler\n   */\n  protected registerMessageHandler(\n    type: MessageType,\n    handler: (message: AgentMessage) => Promise<void>\n  ): void {\n    this.messageHandlers.set(type, handler);\n  }\n\n  /**\n   * Register default message handlers\n   */\n  private registerDefaultMessageHandlers(): void {\n    // Handle status requests\n    this.registerMessageHandler(MessageType.STATUS, async (message) => {\n      await this.sendMessage({\n        id: `${Date.now()}`,\n        type: MessageType.STATUS,\n        from: this.config.id!,\n        to: message.from,\n        timestamp: new Date(),\n        correlationId: message.id,\n        payload: {\n          agentId: this.config.id,\n          status: this._state.status,\n          currentTask: this._state.currentTask?.id,\n        },\n      });\n    });\n  }\n\n  // ============================================================================\n  // Trajectory Tracking\n  // ============================================================================\n\n  /**\n   * Set the trajectory tracker for this agent\n   *\n   * @param tracker - The trajectory tracker instance\n   */\n  setTrajectoryTracker(tracker: TrajectoryTracker): void {\n    this.trajectoryTracker = tracker;\n  }\n\n  /**\n   * Enable or disable auto-tracking of trajectories\n   *\n   * @param enabled - Whether to auto-track\n   */\n  setAutoTrackTrajectories(enabled: boolean): void {\n    this.autoTrackTrajectories = enabled;\n  }\n\n  /**\n   * Start tracking a task trajectory\n   *\n   * @param taskId - The task ID to track\n   * @param metadata - Optional metadata\n   * @returns The trajectory ID\n   */\n  protected startTrajectory(\n    taskId: string,\n    metadata: Record<string, unknown> = {}\n  ): string | null {\n    if (!this.trajectoryTracker?.isEnabled()) {\n      return null;\n    }\n\n    this.currentTrajectoryId = this.trajectoryTracker.startTrajectory(taskId, {\n      ...metadata,\n      agentId: this.config.id,\n      agentType: this.config.type,\n      agentName: this.config.name,\n    });\n\n    return this.currentTrajectoryId;\n  }\n\n  /**\n   * Record a step in the current trajectory\n   *\n   * @param action - The action taken\n   * @param observation - The observation/result\n   * @param confidence - Optional confidence score (0-1)\n   * @param metadata - Optional step metadata\n   */\n  protected recordStep(\n    action: string,\n    observation: string,\n    confidence?: number,\n    metadata?: Record<string, unknown>\n  ): void {\n    if (!this.trajectoryTracker || !this.currentTrajectoryId) {\n      return;\n    }\n\n    this.trajectoryTracker.recordStep(this.currentTrajectoryId, {\n      action,\n      observation,\n      confidence,\n      metadata,\n    });\n  }\n\n  /**\n   * Complete the current trajectory\n   *\n   * @param outcome - The task outcome\n   * @param metadata - Optional final metadata\n   * @returns The stored trajectory ID, or null\n   */\n  protected async completeTrajectory(\n    outcome: 'success' | 'failure' | 'partial',\n    metadata: Record<string, unknown> = {}\n  ): Promise<string | null> {\n    if (!this.trajectoryTracker || !this.currentTrajectoryId) {\n      return null;\n    }\n\n    const storedId = await this.trajectoryTracker.completeTrajectory(\n      this.currentTrajectoryId,\n      outcome,\n      metadata\n    );\n\n    this.currentTrajectoryId = null;\n    return storedId;\n  }\n\n  /**\n   * Abort the current trajectory\n   *\n   * @param reason - The reason for aborting\n   */\n  protected abortTrajectory(reason: string): void {\n    if (!this.trajectoryTracker || !this.currentTrajectoryId) {\n      return;\n    }\n\n    this.trajectoryTracker.abortTrajectory(this.currentTrajectoryId, reason);\n    this.currentTrajectoryId = null;\n  }\n\n  /**\n   * Check if trajectory tracking is active\n   */\n  isTrackingTrajectory(): boolean {\n    return this.currentTrajectoryId !== null;\n  }\n\n  /**\n   * Get current trajectory progress\n   */\n  getTrajectoryProgress(): {\n    stepCount: number;\n    duration: number;\n    lastStep?: TrajectoryStep;\n  } | null {\n    if (!this.trajectoryTracker || !this.currentTrajectoryId) {\n      return null;\n    }\n\n    return this.trajectoryTracker.getProgress(this.currentTrajectoryId);\n  }\n\n  // ============================================================================\n  // Claude-Flow Integration\n  // ============================================================================\n\n  /**\n   * Run a claude-flow hook\n   */\n  protected async runClaudeFlowHook(\n    hookType: 'pre-task' | 'post-task' | 'post-edit',\n    task: AgentTask,\n    result?: AgentResult\n  ): Promise<void> {\n    if (!this.config.claudeFlow?.enabled) {\n      return;\n    }\n\n    const namespace = this.config.claudeFlow.namespace ?? 'knowledge-graph';\n\n    this.logger.debug(`Running claude-flow hook: ${hookType}`, {\n      namespace,\n      taskId: task.id,\n    });\n\n    // Generate the hook command that would be run\n    const hookCommand = this.generateHookCommand(hookType, task, result);\n\n    this.logger.trace('Claude-flow hook command', { command: hookCommand });\n\n    // In production, this would execute via child_process or MCP\n    // For now, we just log the intent\n  }\n\n  /**\n   * Generate claude-flow hook command\n   */\n  private generateHookCommand(\n    hookType: 'pre-task' | 'post-task' | 'post-edit',\n    task: AgentTask,\n    result?: AgentResult\n  ): string {\n    const namespace = this.config.claudeFlow?.namespace ?? 'knowledge-graph';\n\n    switch (hookType) {\n      case 'pre-task':\n        return `npx claude-flow@alpha hooks pre-task --description \"${task.description}\"`;\n\n      case 'post-task':\n        return `npx claude-flow@alpha hooks post-task --task-id \"${task.id}\"`;\n\n      case 'post-edit':\n        return `npx claude-flow@alpha hooks post-edit --memory-key \"${namespace}/agent/${this.config.id}/task/${task.id}\"`;\n\n      default:\n        return '';\n    }\n  }\n\n  /**\n   * Store result in claude-flow memory\n   */\n  protected async storeInMemory(key: string, value: unknown): Promise<void> {\n    if (!this.config.claudeFlow?.enabled) {\n      return;\n    }\n\n    const namespace = this.config.claudeFlow.namespace ?? 'knowledge-graph';\n\n    this.logger.debug('Storing in claude-flow memory', { namespace, key });\n\n    // This would call the MCP memory_usage tool\n    // For now, just log the intent\n    this.logger.trace('Memory store', {\n      action: 'store',\n      namespace,\n      key,\n      value: JSON.stringify(value).slice(0, 100),\n    });\n  }\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Create a task with defaults\n */\nexport function createTask(\n  description: string,\n  options?: Partial<Omit<AgentTask, 'id' | 'description' | 'createdAt'>>\n): AgentTask {\n  return {\n    id: createTaskId(),\n    description,\n    priority: options?.priority ?? TaskPriority.MEDIUM,\n    input: options?.input ?? {},\n    expectedOutput: options?.expectedOutput,\n    dependencies: options?.dependencies,\n    timeout: options?.timeout,\n    metadata: options?.metadata,\n    createdAt: new Date(),\n    deadline: options?.deadline,\n  };\n}\n\n/**\n * Type guard for checking if an object is an AgentResult\n */\nexport function isAgentResult(obj: unknown): obj is AgentResult {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    'success' in obj &&\n    typeof (obj as AgentResult).success === 'boolean'\n  );\n}\n\n/**\n * Type guard for checking if an object is an AgentError\n */\nexport function isAgentError(obj: unknown): obj is AgentError {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    'code' in obj &&\n    'message' in obj &&\n    typeof (obj as AgentError).code === 'string' &&\n    typeof (obj as AgentError).message === 'string'\n  );\n}\n"],"names":[],"mappings":"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"}