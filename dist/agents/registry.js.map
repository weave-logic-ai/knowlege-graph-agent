{"version":3,"file":"registry.js","sources":["../../src/agents/registry.ts"],"sourcesContent":["/**\n * Agent Registry\n *\n * Manages agent type registration, instantiation, and lifecycle.\n * Provides a factory pattern for creating agents dynamically.\n *\n * @module agents/registry\n */\n\nimport { getLogger, type Logger } from '../utils/index.js';\nimport {\n  AgentType,\n  AgentStatus,\n  type AgentConfig,\n  type AgentFactory,\n  type AgentInstance,\n  type AgentState,\n  type AgentCapability,\n  type AgentHealthCheck,\n  createAgentId,\n} from './types.js';\n\n// ============================================================================\n// Registry Types\n// ============================================================================\n\n/**\n * Agent registration entry\n */\ninterface AgentRegistration {\n  /** Agent type */\n  type: AgentType;\n\n  /** Factory function */\n  factory: AgentFactory;\n\n  /** Default configuration */\n  defaultConfig?: Partial<AgentConfig>;\n\n  /** Agent capabilities */\n  capabilities: AgentCapability[];\n\n  /** Registration metadata */\n  metadata?: Record<string, unknown>;\n\n  /** Registration timestamp */\n  registeredAt: Date;\n}\n\n/**\n * Registry configuration options\n */\nexport interface RegistryOptions {\n  /** Logger instance */\n  logger?: Logger;\n\n  /** Maximum agents per type */\n  maxAgentsPerType?: number;\n\n  /** Default task timeout */\n  defaultTimeout?: number;\n\n  /** Enable health monitoring */\n  enableHealthMonitoring?: boolean;\n\n  /** Health check interval in ms */\n  healthCheckInterval?: number;\n}\n\n/**\n * Agent spawn options\n */\nexport interface SpawnOptions {\n  /** Custom agent ID */\n  id?: string;\n\n  /** Override default configuration */\n  configOverrides?: Partial<AgentConfig>;\n\n  /** Start immediately after spawn */\n  autoStart?: boolean;\n}\n\n// ============================================================================\n// Agent Registry Class\n// ============================================================================\n\n/**\n * Agent Registry\n *\n * Central registry for managing agent types and instances.\n * Supports registration, spawning, lifecycle management, and health monitoring.\n *\n * @example\n * ```typescript\n * const registry = new AgentRegistry();\n *\n * // Register an agent type\n * registry.register(AgentType.RESEARCHER, researcherFactory, {\n *   capabilities: [{ name: 'search', description: 'Search capabilities' }]\n * });\n *\n * // Spawn an agent\n * const agent = await registry.spawn(AgentType.RESEARCHER, {\n *   name: 'Research Assistant',\n * });\n *\n * // Execute a task\n * const result = await agent.execute(task);\n * ```\n */\nexport class AgentRegistry {\n  private registrations: Map<AgentType, AgentRegistration> = new Map();\n  private instances: Map<string, AgentInstance> = new Map();\n  private instancesByType: Map<AgentType, Set<string>> = new Map();\n  private logger: Logger;\n  private options: Required<RegistryOptions>;\n  private healthCheckTimer?: NodeJS.Timeout;\n\n  constructor(options: RegistryOptions = {}) {\n    this.logger = options.logger ?? getLogger().child('agent-registry');\n    this.options = {\n      logger: this.logger,\n      maxAgentsPerType: options.maxAgentsPerType ?? 10,\n      defaultTimeout: options.defaultTimeout ?? 30000,\n      enableHealthMonitoring: options.enableHealthMonitoring ?? false,\n      healthCheckInterval: options.healthCheckInterval ?? 30000,\n    };\n\n    // Initialize type tracking\n    for (const type of Object.values(AgentType)) {\n      this.instancesByType.set(type, new Set());\n    }\n\n    // Start health monitoring if enabled\n    if (this.options.enableHealthMonitoring) {\n      this.startHealthMonitoring();\n    }\n  }\n\n  // ============================================================================\n  // Registration Methods\n  // ============================================================================\n\n  /**\n   * Register an agent type with its factory function\n   */\n  register(\n    type: AgentType,\n    factory: AgentFactory,\n    options?: {\n      defaultConfig?: Partial<AgentConfig>;\n      capabilities?: AgentCapability[];\n      metadata?: Record<string, unknown>;\n    }\n  ): void {\n    if (this.registrations.has(type)) {\n      this.logger.warn(`Overwriting existing registration for agent type: ${type}`);\n    }\n\n    const registration: AgentRegistration = {\n      type,\n      factory,\n      defaultConfig: options?.defaultConfig,\n      capabilities: options?.capabilities ?? [],\n      metadata: options?.metadata,\n      registeredAt: new Date(),\n    };\n\n    this.registrations.set(type, registration);\n    this.logger.info(`Registered agent type: ${type}`, {\n      capabilities: registration.capabilities.map(c => c.name),\n    });\n  }\n\n  /**\n   * Unregister an agent type\n   */\n  unregister(type: AgentType): boolean {\n    // Terminate all instances of this type first\n    const instances = this.instancesByType.get(type);\n    if (instances) {\n      for (const id of instances) {\n        void this.terminateAgent(id);\n      }\n    }\n\n    const result = this.registrations.delete(type);\n    if (result) {\n      this.logger.info(`Unregistered agent type: ${type}`);\n    }\n    return result;\n  }\n\n  /**\n   * Check if an agent type is registered\n   */\n  isRegistered(type: AgentType): boolean {\n    return this.registrations.has(type);\n  }\n\n  /**\n   * Get registration info for an agent type\n   */\n  getRegistration(type: AgentType): AgentRegistration | undefined {\n    return this.registrations.get(type);\n  }\n\n  // ============================================================================\n  // Agent Lifecycle Methods\n  // ============================================================================\n\n  /**\n   * Spawn a new agent instance\n   */\n  async spawn(\n    type: AgentType,\n    config: Omit<AgentConfig, 'type'>,\n    options?: SpawnOptions\n  ): Promise<AgentInstance> {\n    const registration = this.registrations.get(type);\n    if (!registration) {\n      throw new Error(`Agent type not registered: ${type}`);\n    }\n\n    // Check max agents limit\n    const existingCount = this.instancesByType.get(type)?.size ?? 0;\n    if (existingCount >= this.options.maxAgentsPerType) {\n      throw new Error(\n        `Maximum agents of type ${type} reached (${this.options.maxAgentsPerType})`\n      );\n    }\n\n    // Merge configurations\n    const fullConfig: AgentConfig = {\n      ...registration.defaultConfig,\n      ...config,\n      type,\n      id: options?.id ?? createAgentId(type),\n      ...options?.configOverrides,\n    };\n\n    this.logger.debug(`Spawning agent: ${fullConfig.id}`, {\n      type,\n      name: fullConfig.name,\n    });\n\n    try {\n      // Create agent using factory\n      const agent = await registration.factory(fullConfig);\n\n      // Track instance\n      this.instances.set(fullConfig.id!, agent);\n      this.instancesByType.get(type)?.add(fullConfig.id!);\n\n      this.logger.info(`Agent spawned: ${fullConfig.id}`, {\n        type,\n        name: fullConfig.name,\n        capabilities: fullConfig.capabilities,\n      });\n\n      return agent;\n    } catch (error) {\n      this.logger.error(\n        `Failed to spawn agent: ${fullConfig.id}`,\n        error instanceof Error ? error : new Error(String(error))\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Spawn multiple agents in parallel\n   */\n  async spawnMultiple(\n    specs: Array<{\n      type: AgentType;\n      config: Omit<AgentConfig, 'type'>;\n      options?: SpawnOptions;\n    }>\n  ): Promise<AgentInstance[]> {\n    const results = await Promise.allSettled(\n      specs.map(spec => this.spawn(spec.type, spec.config, spec.options))\n    );\n\n    const agents: AgentInstance[] = [];\n    const errors: Error[] = [];\n\n    for (const result of results) {\n      if (result.status === 'fulfilled') {\n        agents.push(result.value);\n      } else {\n        errors.push(result.reason);\n      }\n    }\n\n    if (errors.length > 0) {\n      this.logger.warn(`${errors.length} agents failed to spawn`, {\n        totalRequested: specs.length,\n        spawned: agents.length,\n        failed: errors.length,\n      });\n    }\n\n    return agents;\n  }\n\n  /**\n   * Get an agent instance by ID\n   */\n  get(id: string): AgentInstance | undefined {\n    return this.instances.get(id);\n  }\n\n  /**\n   * Get all agent instances\n   */\n  getAll(): AgentInstance[] {\n    return Array.from(this.instances.values());\n  }\n\n  /**\n   * Get agents by type\n   */\n  getByType(type: AgentType): AgentInstance[] {\n    const ids = this.instancesByType.get(type);\n    if (!ids) return [];\n\n    return Array.from(ids)\n      .map(id => this.instances.get(id))\n      .filter((agent): agent is AgentInstance => agent !== undefined);\n  }\n\n  /**\n   * List all registered agent types\n   */\n  listTypes(): Array<{\n    type: AgentType;\n    capabilities: AgentCapability[];\n    instanceCount: number;\n  }> {\n    return Array.from(this.registrations.entries()).map(([type, reg]) => ({\n      type,\n      capabilities: reg.capabilities,\n      instanceCount: this.instancesByType.get(type)?.size ?? 0,\n    }));\n  }\n\n  /**\n   * List all active agent instances\n   */\n  listInstances(): Array<{\n    id: string;\n    type: AgentType;\n    name: string;\n    status: AgentStatus;\n  }> {\n    return Array.from(this.instances.entries()).map(([id, agent]) => ({\n      id,\n      type: agent.config.type,\n      name: agent.config.name,\n      status: agent.getStatus(),\n    }));\n  }\n\n  /**\n   * Terminate an agent instance\n   */\n  async terminateAgent(id: string): Promise<boolean> {\n    const agent = this.instances.get(id);\n    if (!agent) {\n      return false;\n    }\n\n    try {\n      await agent.terminate();\n      this.instances.delete(id);\n      this.instancesByType.get(agent.config.type)?.delete(id);\n\n      this.logger.info(`Agent terminated: ${id}`);\n      return true;\n    } catch (error) {\n      this.logger.error(\n        `Failed to terminate agent: ${id}`,\n        error instanceof Error ? error : new Error(String(error))\n      );\n      // Force remove from tracking even if termination failed\n      this.instances.delete(id);\n      this.instancesByType.get(agent.config.type)?.delete(id);\n      return false;\n    }\n  }\n\n  /**\n   * Terminate all agents of a specific type\n   */\n  async terminateByType(type: AgentType): Promise<number> {\n    const ids = this.instancesByType.get(type);\n    if (!ids || ids.size === 0) return 0;\n\n    const results = await Promise.allSettled(\n      Array.from(ids).map(id => this.terminateAgent(id))\n    );\n\n    return results.filter(r => r.status === 'fulfilled' && r.value).length;\n  }\n\n  /**\n   * Terminate all agents\n   */\n  async terminateAll(): Promise<number> {\n    const ids = Array.from(this.instances.keys());\n    const results = await Promise.allSettled(\n      ids.map(id => this.terminateAgent(id))\n    );\n\n    return results.filter(r => r.status === 'fulfilled' && r.value).length;\n  }\n\n  // ============================================================================\n  // Health Monitoring Methods\n  // ============================================================================\n\n  /**\n   * Start health monitoring\n   */\n  private startHealthMonitoring(): void {\n    if (this.healthCheckTimer) {\n      clearInterval(this.healthCheckTimer);\n    }\n\n    this.healthCheckTimer = setInterval(async () => {\n      await this.performHealthChecks();\n    }, this.options.healthCheckInterval);\n\n    this.logger.debug('Health monitoring started', {\n      interval: this.options.healthCheckInterval,\n    });\n  }\n\n  /**\n   * Stop health monitoring\n   */\n  stopHealthMonitoring(): void {\n    if (this.healthCheckTimer) {\n      clearInterval(this.healthCheckTimer);\n      this.healthCheckTimer = undefined;\n      this.logger.debug('Health monitoring stopped');\n    }\n  }\n\n  /**\n   * Perform health checks on all agents\n   */\n  async performHealthChecks(): Promise<AgentHealthCheck[]> {\n    const checks: AgentHealthCheck[] = [];\n\n    for (const [id, agent] of this.instances) {\n      const check: AgentHealthCheck = {\n        agentId: id,\n        healthy: true,\n        status: agent.getStatus(),\n        lastHeartbeat: new Date(),\n      };\n\n      // Check for stuck agents\n      if (agent.state.status === AgentStatus.RUNNING) {\n        const stuckThreshold = this.options.defaultTimeout * 2;\n        const elapsed = Date.now() - agent.state.lastActivity.getTime();\n\n        if (elapsed > stuckThreshold) {\n          check.healthy = false;\n          check.error = `Agent appears stuck (${elapsed}ms since last activity)`;\n        }\n      }\n\n      // Check error count\n      if (agent.state.errorCount > 5) {\n        check.healthy = false;\n        check.error = `High error count: ${agent.state.errorCount}`;\n      }\n\n      checks.push(check);\n\n      if (!check.healthy) {\n        this.logger.warn(`Unhealthy agent detected: ${id}`, {\n          status: check.status,\n          error: check.error,\n        });\n      }\n    }\n\n    return checks;\n  }\n\n  /**\n   * Get health status for a specific agent\n   */\n  async getAgentHealth(id: string): Promise<AgentHealthCheck | null> {\n    const agent = this.instances.get(id);\n    if (!agent) return null;\n\n    return {\n      agentId: id,\n      healthy: agent.state.errorCount < 5,\n      status: agent.getStatus(),\n      lastHeartbeat: agent.state.lastActivity,\n      error: agent.state.errorCount >= 5\n        ? `High error count: ${agent.state.errorCount}`\n        : undefined,\n    };\n  }\n\n  // ============================================================================\n  // Utility Methods\n  // ============================================================================\n\n  /**\n   * Get registry statistics\n   */\n  getStats(): {\n    registeredTypes: number;\n    totalInstances: number;\n    instancesByType: Record<string, number>;\n    instancesByStatus: Record<string, number>;\n  } {\n    const instancesByStatus: Record<string, number> = {};\n\n    for (const agent of this.instances.values()) {\n      const status = agent.getStatus();\n      instancesByStatus[status] = (instancesByStatus[status] ?? 0) + 1;\n    }\n\n    return {\n      registeredTypes: this.registrations.size,\n      totalInstances: this.instances.size,\n      instancesByType: Object.fromEntries(\n        Array.from(this.instancesByType.entries()).map(([type, ids]) => [\n          type,\n          ids.size,\n        ])\n      ),\n      instancesByStatus,\n    };\n  }\n\n  /**\n   * Clear all registrations and instances\n   */\n  async clear(): Promise<void> {\n    await this.terminateAll();\n    this.registrations.clear();\n    this.stopHealthMonitoring();\n    this.logger.info('Registry cleared');\n  }\n\n  /**\n   * Dispose of the registry\n   */\n  async dispose(): Promise<void> {\n    await this.clear();\n    this.logger.info('Registry disposed');\n  }\n}\n\n// ============================================================================\n// Default Registry Instance\n// ============================================================================\n\nlet defaultRegistry: AgentRegistry | null = null;\n\n/**\n * Get or create the default registry instance\n */\nexport function getRegistry(): AgentRegistry {\n  if (!defaultRegistry) {\n    defaultRegistry = new AgentRegistry();\n  }\n  return defaultRegistry;\n}\n\n/**\n * Create a new registry instance\n */\nexport function createRegistry(options?: RegistryOptions): AgentRegistry {\n  return new AgentRegistry(options);\n}\n\n/**\n * Set the default registry instance\n */\nexport function setDefaultRegistry(registry: AgentRegistry): void {\n  defaultRegistry = registry;\n}\n\n// ============================================================================\n// Built-in Agent Registration Helpers\n// ============================================================================\n\n/**\n * Register default agent types with a registry\n *\n * This registers placeholder factories that should be replaced\n * with actual implementations.\n */\nexport function registerDefaultAgents(\n  registry: AgentRegistry,\n  factories?: Partial<Record<AgentType, AgentFactory>>\n): void {\n  const defaultCapabilities: Record<AgentType, AgentCapability[]> = {\n    [AgentType.RESEARCHER]: [\n      { name: 'search', description: 'Information search' },\n      { name: 'analyze', description: 'Data analysis' },\n    ],\n    [AgentType.CODER]: [\n      { name: 'code', description: 'Code generation' },\n      { name: 'refactor', description: 'Code refactoring' },\n    ],\n    [AgentType.TESTER]: [\n      { name: 'test', description: 'Test generation' },\n      { name: 'coverage', description: 'Coverage analysis' },\n    ],\n    [AgentType.ANALYST]: [\n      { name: 'analyze', description: 'Pattern analysis' },\n      { name: 'report', description: 'Report generation' },\n    ],\n    [AgentType.ARCHITECT]: [\n      { name: 'design', description: 'System design' },\n      { name: 'document', description: 'Architecture documentation' },\n    ],\n    [AgentType.REVIEWER]: [\n      { name: 'review', description: 'Code review' },\n      { name: 'feedback', description: 'Feedback generation' },\n    ],\n    [AgentType.COORDINATOR]: [\n      { name: 'orchestrate', description: 'Task orchestration' },\n      { name: 'delegate', description: 'Task delegation' },\n    ],\n    [AgentType.OPTIMIZER]: [\n      { name: 'optimize', description: 'Performance optimization' },\n      { name: 'benchmark', description: 'Benchmarking' },\n    ],\n    [AgentType.DOCUMENTER]: [\n      { name: 'document', description: 'Documentation generation' },\n      { name: 'format', description: 'Documentation formatting' },\n    ],\n    [AgentType.PLANNER]: [\n      { name: 'plan', description: 'Task planning and decomposition' },\n      { name: 'schedule', description: 'Timeline estimation' },\n      { name: 'risk', description: 'Risk assessment' },\n    ],\n    [AgentType.CUSTOM]: [],\n  };\n\n  for (const type of Object.values(AgentType)) {\n    const factory = factories?.[type];\n    if (factory) {\n      registry.register(type, factory, {\n        capabilities: defaultCapabilities[type],\n      });\n    }\n  }\n}\n"],"names":[],"mappings":"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"}