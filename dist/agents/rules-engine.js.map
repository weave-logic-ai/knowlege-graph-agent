{"version":3,"file":"rules-engine.js","sources":["../../src/agents/rules-engine.ts"],"sourcesContent":["/**\n * Rules Engine\n *\n * Event-driven rule execution engine with async processing, condition evaluation,\n * error isolation, and performance tracking.\n *\n * @module agents/rules-engine\n */\n\nimport { createLogger, type Logger } from '../utils/index.js';\n\n// ============================================================================\n// Types and Interfaces\n// ============================================================================\n\n/**\n * Trigger types for rule execution\n */\nexport type RuleTrigger =\n  | 'file:add'\n  | 'file:change'\n  | 'file:unlink'\n  | 'graph:update'\n  | 'agent:complete'\n  | 'manual';\n\n/**\n * Rule priority levels\n */\nexport type RulePriority = 'low' | 'normal' | 'high' | 'critical';\n\n/**\n * Rule execution status\n */\nexport type RuleExecutionStatus = 'pending' | 'running' | 'success' | 'failure' | 'skipped';\n\n/**\n * Context provided to rules during execution\n */\nexport interface RuleContext {\n  /** The trigger event that caused this execution */\n  trigger: RuleTrigger;\n\n  /** Timestamp when the event occurred */\n  timestamp: Date;\n\n  /** Path to the file (for file-related triggers) */\n  filePath?: string;\n\n  /** Previous file content (for file:change) */\n  previousContent?: string;\n\n  /** Current file content */\n  currentContent?: string;\n\n  /** Graph-related data (for graph:update) */\n  graphData?: {\n    nodesAdded?: number;\n    nodesRemoved?: number;\n    edgesModified?: number;\n  };\n\n  /** Agent completion data (for agent:complete) */\n  agentData?: {\n    agentId: string;\n    taskId: string;\n    result: 'success' | 'failure';\n    duration: number;\n  };\n\n  /** Custom metadata that can be attached to context */\n  metadata?: Record<string, unknown>;\n\n  /** Reference to the rules engine for chaining */\n  engine?: RulesEngine;\n}\n\n/**\n * Condition function that determines if a rule should execute\n */\nexport type RuleCondition = (context: RuleContext) => boolean | Promise<boolean>;\n\n/**\n * Action function that performs the rule's work\n */\nexport type RuleAction = (context: RuleContext) => void | Promise<void>;\n\n/**\n * Rule definition\n */\nexport interface AgentRule {\n  /** Unique identifier for the rule */\n  id: string;\n\n  /** Human-readable name */\n  name: string;\n\n  /** Optional description */\n  description?: string;\n\n  /** Triggers that activate this rule */\n  triggers: RuleTrigger[];\n\n  /** Condition to evaluate before executing (optional) */\n  condition?: RuleCondition;\n\n  /** Action to execute */\n  action: RuleAction;\n\n  /** Rule priority (default: 'normal') */\n  priority?: RulePriority;\n\n  /** Whether the rule is enabled (default: true) */\n  enabled?: boolean;\n\n  /** Tags for categorization */\n  tags?: string[];\n\n  /** Maximum execution time in milliseconds (default: 30000) */\n  timeout?: number;\n\n  /** Whether to continue execution on failure (default: true) */\n  continueOnFailure?: boolean;\n}\n\n/**\n * Execution log entry\n */\nexport interface RuleExecutionLog {\n  /** Rule ID */\n  ruleId: string;\n\n  /** Rule name */\n  ruleName: string;\n\n  /** Execution status */\n  status: RuleExecutionStatus;\n\n  /** Trigger that caused execution */\n  trigger: RuleTrigger;\n\n  /** Start timestamp */\n  startedAt: Date;\n\n  /** End timestamp */\n  completedAt?: Date;\n\n  /** Execution duration in milliseconds */\n  duration?: number;\n\n  /** Error message if failed */\n  error?: string;\n\n  /** Whether condition was evaluated */\n  conditionEvaluated?: boolean;\n\n  /** Result of condition evaluation */\n  conditionResult?: boolean;\n\n  /** Context snapshot (partial) */\n  contextSnapshot?: {\n    filePath?: string;\n    trigger: RuleTrigger;\n    timestamp: Date;\n  };\n}\n\n/**\n * Rule execution statistics\n */\nexport interface RuleStatistics {\n  /** Rule ID */\n  ruleId: string;\n\n  /** Rule name */\n  ruleName: string;\n\n  /** Total executions */\n  totalExecutions: number;\n\n  /** Successful executions */\n  successCount: number;\n\n  /** Failed executions */\n  failureCount: number;\n\n  /** Skipped executions (condition false) */\n  skippedCount: number;\n\n  /** Average execution time in milliseconds */\n  averageExecutionTime: number;\n\n  /** Min execution time */\n  minExecutionTime: number;\n\n  /** Max execution time */\n  maxExecutionTime: number;\n\n  /** Last execution timestamp */\n  lastExecutedAt?: Date;\n\n  /** Last successful execution */\n  lastSuccessAt?: Date;\n\n  /** Last failure timestamp */\n  lastFailureAt?: Date;\n}\n\n/**\n * Engine-wide statistics\n */\nexport interface EngineStatistics {\n  /** Total rules registered */\n  totalRules: number;\n\n  /** Enabled rules count */\n  enabledRules: number;\n\n  /** Total executions across all rules */\n  totalExecutions: number;\n\n  /** Success rate (0-1) */\n  successRate: number;\n\n  /** Average execution time across all rules */\n  averageExecutionTime: number;\n\n  /** Rules currently executing */\n  activeExecutions: number;\n\n  /** Per-rule statistics */\n  ruleStats: Map<string, RuleStatistics>;\n\n  /** Per-trigger statistics */\n  triggerStats: Map<RuleTrigger, {\n    totalExecutions: number;\n    successCount: number;\n    averageTime: number;\n  }>;\n}\n\n/**\n * Rules engine configuration\n */\nexport interface RulesEngineConfig {\n  /** Maximum concurrent rule executions (default: 10) */\n  maxConcurrency?: number;\n\n  /** Default timeout for rules in milliseconds (default: 30000) */\n  defaultTimeout?: number;\n\n  /** Size of the execution log circular buffer (default: 1000) */\n  logBufferSize?: number;\n\n  /** Whether to enable detailed logging (default: false) */\n  verbose?: boolean;\n\n  /** Custom logger instance */\n  logger?: Logger;\n}\n\n// ============================================================================\n// Circular Buffer for Execution Logs\n// ============================================================================\n\n/**\n * Circular buffer implementation for execution logs\n */\nclass CircularBuffer<T> {\n  private buffer: (T | undefined)[];\n  private head: number = 0;\n  private tail: number = 0;\n  private count: number = 0;\n\n  constructor(private capacity: number) {\n    this.buffer = new Array(capacity);\n  }\n\n  push(item: T): void {\n    this.buffer[this.tail] = item;\n    this.tail = (this.tail + 1) % this.capacity;\n\n    if (this.count < this.capacity) {\n      this.count++;\n    } else {\n      this.head = (this.head + 1) % this.capacity;\n    }\n  }\n\n  toArray(): T[] {\n    const result: T[] = [];\n    for (let i = 0; i < this.count; i++) {\n      const idx = (this.head + i) % this.capacity;\n      const item = this.buffer[idx];\n      if (item !== undefined) {\n        result.push(item);\n      }\n    }\n    return result;\n  }\n\n  getLatest(n: number): T[] {\n    const all = this.toArray();\n    return all.slice(-n);\n  }\n\n  clear(): void {\n    this.buffer = new Array(this.capacity);\n    this.head = 0;\n    this.tail = 0;\n    this.count = 0;\n  }\n\n  get size(): number {\n    return this.count;\n  }\n}\n\n// ============================================================================\n// Priority Queue for Rule Execution\n// ============================================================================\n\nconst PRIORITY_ORDER: Record<RulePriority, number> = {\n  critical: 0,\n  high: 1,\n  normal: 2,\n  low: 3,\n};\n\n// ============================================================================\n// Rules Engine Implementation\n// ============================================================================\n\n/**\n * Event-driven rules engine with async processing and error isolation\n */\nexport class RulesEngine {\n  private rules: Map<string, AgentRule> = new Map();\n  private executionLogs: CircularBuffer<RuleExecutionLog>;\n  private ruleStats: Map<string, RuleStatistics> = new Map();\n  private triggerStats: Map<RuleTrigger, { totalExecutions: number; successCount: number; totalTime: number }> = new Map();\n  private activeExecutions: number = 0;\n  private readonly logger: Logger;\n  private readonly config: Required<RulesEngineConfig>;\n\n  constructor(config: RulesEngineConfig = {}) {\n    this.config = {\n      maxConcurrency: config.maxConcurrency ?? 10,\n      defaultTimeout: config.defaultTimeout ?? 30000,\n      logBufferSize: config.logBufferSize ?? 1000,\n      verbose: config.verbose ?? false,\n      logger: config.logger ?? createLogger('RulesEngine'),\n    };\n\n    this.logger = this.config.logger;\n    this.executionLogs = new CircularBuffer(this.config.logBufferSize);\n\n    // Initialize trigger stats for all trigger types\n    const allTriggers: RuleTrigger[] = ['file:add', 'file:change', 'file:unlink', 'graph:update', 'agent:complete', 'manual'];\n    for (const trigger of allTriggers) {\n      this.triggerStats.set(trigger, { totalExecutions: 0, successCount: 0, totalTime: 0 });\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Rule Management\n  // --------------------------------------------------------------------------\n\n  /**\n   * Register a new rule\n   */\n  registerRule(rule: AgentRule): void {\n    if (this.rules.has(rule.id)) {\n      this.logger.warn(`Rule with id '${rule.id}' already exists, replacing`, { ruleId: rule.id });\n    }\n\n    // Apply defaults\n    const normalizedRule: AgentRule = {\n      ...rule,\n      priority: rule.priority ?? 'normal',\n      enabled: rule.enabled ?? true,\n      timeout: rule.timeout ?? this.config.defaultTimeout,\n      continueOnFailure: rule.continueOnFailure ?? true,\n    };\n\n    this.rules.set(rule.id, normalizedRule);\n\n    // Initialize stats for this rule\n    this.ruleStats.set(rule.id, {\n      ruleId: rule.id,\n      ruleName: rule.name,\n      totalExecutions: 0,\n      successCount: 0,\n      failureCount: 0,\n      skippedCount: 0,\n      averageExecutionTime: 0,\n      minExecutionTime: Infinity,\n      maxExecutionTime: 0,\n    });\n\n    if (this.config.verbose) {\n      this.logger.debug(`Registered rule: ${rule.name}`, {\n        ruleId: rule.id,\n        triggers: rule.triggers,\n        priority: normalizedRule.priority,\n      });\n    }\n  }\n\n  /**\n   * Register multiple rules at once\n   */\n  registerRules(rules: AgentRule[]): void {\n    for (const rule of rules) {\n      this.registerRule(rule);\n    }\n  }\n\n  /**\n   * Unregister a rule by ID\n   */\n  unregisterRule(ruleId: string): boolean {\n    const existed = this.rules.delete(ruleId);\n    if (existed) {\n      this.logger.debug(`Unregistered rule: ${ruleId}`);\n    }\n    return existed;\n  }\n\n  /**\n   * Get a rule by ID\n   */\n  getRule(ruleId: string): AgentRule | undefined {\n    return this.rules.get(ruleId);\n  }\n\n  /**\n   * Get all registered rules\n   */\n  getAllRules(): AgentRule[] {\n    return Array.from(this.rules.values());\n  }\n\n  /**\n   * Get rules by trigger type\n   */\n  getRulesByTrigger(trigger: RuleTrigger): AgentRule[] {\n    return Array.from(this.rules.values()).filter(\n      (rule) => rule.enabled && rule.triggers.includes(trigger)\n    );\n  }\n\n  /**\n   * Enable a rule\n   */\n  enableRule(ruleId: string): boolean {\n    const rule = this.rules.get(ruleId);\n    if (rule) {\n      rule.enabled = true;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Disable a rule\n   */\n  disableRule(ruleId: string): boolean {\n    const rule = this.rules.get(ruleId);\n    if (rule) {\n      rule.enabled = false;\n      return true;\n    }\n    return false;\n  }\n\n  // --------------------------------------------------------------------------\n  // Rule Execution\n  // --------------------------------------------------------------------------\n\n  /**\n   * Trigger rule execution for an event\n   */\n  async trigger(trigger: RuleTrigger, context: Partial<RuleContext> = {}): Promise<RuleExecutionLog[]> {\n    const fullContext: RuleContext = {\n      trigger,\n      timestamp: new Date(),\n      ...context,\n      engine: this,\n    };\n\n    // Get applicable rules sorted by priority\n    const applicableRules = this.getRulesByTrigger(trigger).sort(\n      (a, b) => PRIORITY_ORDER[a.priority ?? 'normal'] - PRIORITY_ORDER[b.priority ?? 'normal']\n    );\n\n    if (applicableRules.length === 0) {\n      if (this.config.verbose) {\n        this.logger.debug(`No rules to execute for trigger: ${trigger}`);\n      }\n      return [];\n    }\n\n    this.logger.info(`Executing ${applicableRules.length} rules for trigger: ${trigger}`, {\n      trigger,\n      ruleCount: applicableRules.length,\n    });\n\n    // Execute rules concurrently with concurrency limit\n    const logs: RuleExecutionLog[] = [];\n    const executing: Promise<void>[] = [];\n\n    for (const rule of applicableRules) {\n      // Wait if at concurrency limit\n      while (this.activeExecutions >= this.config.maxConcurrency) {\n        await Promise.race(executing);\n      }\n\n      const execution = this.executeRule(rule, fullContext).then((log) => {\n        logs.push(log);\n        const idx = executing.indexOf(execution);\n        if (idx > -1) executing.splice(idx, 1);\n      });\n\n      executing.push(execution);\n    }\n\n    // Wait for all remaining executions\n    await Promise.all(executing);\n\n    return logs;\n  }\n\n  /**\n   * Execute a single rule\n   */\n  private async executeRule(rule: AgentRule, context: RuleContext): Promise<RuleExecutionLog> {\n    const startTime = Date.now();\n    this.activeExecutions++;\n\n    const log: RuleExecutionLog = {\n      ruleId: rule.id,\n      ruleName: rule.name,\n      status: 'running',\n      trigger: context.trigger,\n      startedAt: new Date(),\n      contextSnapshot: {\n        filePath: context.filePath,\n        trigger: context.trigger,\n        timestamp: context.timestamp,\n      },\n    };\n\n    try {\n      // Evaluate condition if present\n      if (rule.condition) {\n        log.conditionEvaluated = true;\n        const conditionResult = await this.withTimeout(\n          Promise.resolve(rule.condition(context)),\n          rule.timeout ?? this.config.defaultTimeout,\n          `Condition evaluation for rule '${rule.name}'`\n        );\n        log.conditionResult = conditionResult;\n\n        if (!conditionResult) {\n          log.status = 'skipped';\n          log.completedAt = new Date();\n          log.duration = Date.now() - startTime;\n          this.updateStats(rule, log, false);\n          this.executionLogs.push(log);\n          this.activeExecutions--;\n\n          if (this.config.verbose) {\n            this.logger.debug(`Rule skipped (condition false): ${rule.name}`, { ruleId: rule.id });\n          }\n          return log;\n        }\n      }\n\n      // Execute action\n      await this.withTimeout(\n        Promise.resolve(rule.action(context)),\n        rule.timeout ?? this.config.defaultTimeout,\n        `Action execution for rule '${rule.name}'`\n      );\n\n      log.status = 'success';\n      log.completedAt = new Date();\n      log.duration = Date.now() - startTime;\n\n      if (this.config.verbose) {\n        this.logger.debug(`Rule executed successfully: ${rule.name}`, {\n          ruleId: rule.id,\n          duration: log.duration,\n        });\n      }\n\n    } catch (error) {\n      log.status = 'failure';\n      log.completedAt = new Date();\n      log.duration = Date.now() - startTime;\n      log.error = error instanceof Error ? error.message : String(error);\n\n      this.logger.error(`Rule execution failed: ${rule.name}`, error instanceof Error ? error : undefined, {\n        ruleId: rule.id,\n        trigger: context.trigger,\n      });\n\n      if (!rule.continueOnFailure) {\n        throw error;\n      }\n    } finally {\n      this.activeExecutions--;\n      this.updateStats(rule, log, log.status === 'success');\n      this.executionLogs.push(log);\n    }\n\n    return log;\n  }\n\n  /**\n   * Execute a rule by ID with custom context\n   */\n  async executeRuleById(ruleId: string, context: Partial<RuleContext> = {}): Promise<RuleExecutionLog | null> {\n    const rule = this.rules.get(ruleId);\n    if (!rule) {\n      this.logger.warn(`Rule not found: ${ruleId}`);\n      return null;\n    }\n\n    const fullContext: RuleContext = {\n      trigger: 'manual',\n      timestamp: new Date(),\n      ...context,\n      engine: this,\n    };\n\n    return this.executeRule(rule, fullContext);\n  }\n\n  /**\n   * Wrap a promise with a timeout\n   */\n  private async withTimeout<T>(\n    promise: Promise<T>,\n    timeoutMs: number,\n    operation: string\n  ): Promise<T> {\n    let timeoutId: NodeJS.Timeout;\n\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      timeoutId = setTimeout(() => {\n        reject(new Error(`Timeout after ${timeoutMs}ms: ${operation}`));\n      }, timeoutMs);\n    });\n\n    try {\n      const result = await Promise.race([promise, timeoutPromise]);\n      clearTimeout(timeoutId!);\n      return result;\n    } catch (error) {\n      clearTimeout(timeoutId!);\n      throw error;\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Statistics and Metrics\n  // --------------------------------------------------------------------------\n\n  /**\n   * Update statistics after rule execution\n   */\n  private updateStats(rule: AgentRule, log: RuleExecutionLog, success: boolean): void {\n    const stats = this.ruleStats.get(rule.id);\n    if (!stats) return;\n\n    stats.totalExecutions++;\n    stats.lastExecutedAt = log.completedAt;\n\n    if (log.status === 'skipped') {\n      stats.skippedCount++;\n    } else if (success) {\n      stats.successCount++;\n      stats.lastSuccessAt = log.completedAt;\n    } else {\n      stats.failureCount++;\n      stats.lastFailureAt = log.completedAt;\n    }\n\n    if (log.duration !== undefined && log.status !== 'skipped') {\n      const totalTime = stats.averageExecutionTime * (stats.totalExecutions - stats.skippedCount - 1);\n      const execCount = stats.totalExecutions - stats.skippedCount;\n      stats.averageExecutionTime = execCount > 0 ? (totalTime + log.duration) / execCount : 0;\n\n      stats.minExecutionTime = Math.min(stats.minExecutionTime, log.duration);\n      stats.maxExecutionTime = Math.max(stats.maxExecutionTime, log.duration);\n    }\n\n    // Update trigger stats\n    const triggerStat = this.triggerStats.get(log.trigger);\n    if (triggerStat) {\n      triggerStat.totalExecutions++;\n      if (success) triggerStat.successCount++;\n      if (log.duration) triggerStat.totalTime += log.duration;\n    }\n  }\n\n  /**\n   * Get statistics for a specific rule\n   */\n  getRuleStatistics(ruleId: string): RuleStatistics | undefined {\n    return this.ruleStats.get(ruleId);\n  }\n\n  /**\n   * Get engine-wide statistics\n   */\n  getStatistics(): EngineStatistics {\n    const allRules = Array.from(this.rules.values());\n    const enabledRules = allRules.filter((r) => r.enabled);\n\n    let totalExecutions = 0;\n    let totalSuccesses = 0;\n    let totalTime = 0;\n    let timeCount = 0;\n\n    for (const stats of this.ruleStats.values()) {\n      totalExecutions += stats.totalExecutions;\n      totalSuccesses += stats.successCount;\n      if (stats.averageExecutionTime > 0 && stats.totalExecutions > stats.skippedCount) {\n        totalTime += stats.averageExecutionTime * (stats.totalExecutions - stats.skippedCount);\n        timeCount += stats.totalExecutions - stats.skippedCount;\n      }\n    }\n\n    const triggerStatsMap = new Map<RuleTrigger, { totalExecutions: number; successCount: number; averageTime: number }>();\n    for (const [trigger, stat] of this.triggerStats) {\n      triggerStatsMap.set(trigger, {\n        totalExecutions: stat.totalExecutions,\n        successCount: stat.successCount,\n        averageTime: stat.totalExecutions > 0 ? stat.totalTime / stat.totalExecutions : 0,\n      });\n    }\n\n    return {\n      totalRules: allRules.length,\n      enabledRules: enabledRules.length,\n      totalExecutions,\n      successRate: totalExecutions > 0 ? totalSuccesses / totalExecutions : 0,\n      averageExecutionTime: timeCount > 0 ? totalTime / timeCount : 0,\n      activeExecutions: this.activeExecutions,\n      ruleStats: new Map(this.ruleStats),\n      triggerStats: triggerStatsMap,\n    };\n  }\n\n  // --------------------------------------------------------------------------\n  // Execution Logs\n  // --------------------------------------------------------------------------\n\n  /**\n   * Get execution logs (most recent first)\n   */\n  getExecutionLogs(limit?: number): RuleExecutionLog[] {\n    const logs = this.executionLogs.toArray().reverse();\n    return limit ? logs.slice(0, limit) : logs;\n  }\n\n  /**\n   * Get logs for a specific rule\n   */\n  getLogsForRule(ruleId: string, limit?: number): RuleExecutionLog[] {\n    const logs = this.executionLogs.toArray()\n      .filter((log) => log.ruleId === ruleId)\n      .reverse();\n    return limit ? logs.slice(0, limit) : logs;\n  }\n\n  /**\n   * Get logs for a specific trigger\n   */\n  getLogsForTrigger(trigger: RuleTrigger, limit?: number): RuleExecutionLog[] {\n    const logs = this.executionLogs.toArray()\n      .filter((log) => log.trigger === trigger)\n      .reverse();\n    return limit ? logs.slice(0, limit) : logs;\n  }\n\n  /**\n   * Get failed execution logs\n   */\n  getFailedLogs(limit?: number): RuleExecutionLog[] {\n    const logs = this.executionLogs.toArray()\n      .filter((log) => log.status === 'failure')\n      .reverse();\n    return limit ? logs.slice(0, limit) : logs;\n  }\n\n  /**\n   * Clear execution logs\n   */\n  clearLogs(): void {\n    this.executionLogs.clear();\n    this.logger.debug('Execution logs cleared');\n  }\n\n  // --------------------------------------------------------------------------\n  // Utility Methods\n  // --------------------------------------------------------------------------\n\n  /**\n   * Reset all statistics\n   */\n  resetStatistics(): void {\n    for (const [ruleId, rule] of this.rules) {\n      this.ruleStats.set(ruleId, {\n        ruleId,\n        ruleName: rule.name,\n        totalExecutions: 0,\n        successCount: 0,\n        failureCount: 0,\n        skippedCount: 0,\n        averageExecutionTime: 0,\n        minExecutionTime: Infinity,\n        maxExecutionTime: 0,\n      });\n    }\n\n    for (const trigger of this.triggerStats.keys()) {\n      this.triggerStats.set(trigger, { totalExecutions: 0, successCount: 0, totalTime: 0 });\n    }\n\n    this.logger.debug('Statistics reset');\n  }\n\n  /**\n   * Get a summary of the engine state\n   */\n  getSummary(): {\n    rulesCount: number;\n    enabledCount: number;\n    triggersConfigured: RuleTrigger[];\n    activeExecutions: number;\n    logsCount: number;\n  } {\n    const allRules = Array.from(this.rules.values());\n    const triggersConfigured = new Set<RuleTrigger>();\n\n    for (const rule of allRules) {\n      if (rule.enabled) {\n        for (const trigger of rule.triggers) {\n          triggersConfigured.add(trigger);\n        }\n      }\n    }\n\n    return {\n      rulesCount: allRules.length,\n      enabledCount: allRules.filter((r) => r.enabled).length,\n      triggersConfigured: Array.from(triggersConfigured),\n      activeExecutions: this.activeExecutions,\n      logsCount: this.executionLogs.size,\n    };\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\n/**\n * Create a new rules engine instance\n */\nexport function createRulesEngine(config?: RulesEngineConfig): RulesEngine {\n  return new RulesEngine(config);\n}\n\n/**\n * Create a simple rule definition\n */\nexport function createRule(\n  id: string,\n  name: string,\n  triggers: RuleTrigger[],\n  action: RuleAction,\n  options: Partial<Omit<AgentRule, 'id' | 'name' | 'triggers' | 'action'>> = {}\n): AgentRule {\n  return {\n    id,\n    name,\n    triggers,\n    action,\n    ...options,\n  };\n}\n\n/**\n * Create a conditional rule\n */\nexport function createConditionalRule(\n  id: string,\n  name: string,\n  triggers: RuleTrigger[],\n  condition: RuleCondition,\n  action: RuleAction,\n  options: Partial<Omit<AgentRule, 'id' | 'name' | 'triggers' | 'condition' | 'action'>> = {}\n): AgentRule {\n  return {\n    id,\n    name,\n    triggers,\n    condition,\n    action,\n    ...options,\n  };\n}\n\n// ============================================================================\n// Built-in Rule Templates\n// ============================================================================\n\n/**\n * Create a file change logging rule\n */\nexport function createFileChangeLogRule(\n  logger: Logger = createLogger('FileChangeRule')\n): AgentRule {\n  return {\n    id: 'builtin:file-change-log',\n    name: 'File Change Logger',\n    description: 'Logs all file changes to the console',\n    triggers: ['file:add', 'file:change', 'file:unlink'],\n    priority: 'low',\n    action: (context) => {\n      logger.info(`File ${context.trigger.replace('file:', '')}: ${context.filePath ?? 'unknown'}`);\n    },\n  };\n}\n\n/**\n * Create a graph update notification rule\n */\nexport function createGraphUpdateNotificationRule(\n  callback: (context: RuleContext) => void | Promise<void>\n): AgentRule {\n  return {\n    id: 'builtin:graph-update-notify',\n    name: 'Graph Update Notification',\n    description: 'Notifies when the knowledge graph is updated',\n    triggers: ['graph:update'],\n    priority: 'normal',\n    action: callback,\n  };\n}\n\n/**\n * Create an agent completion handler rule\n */\nexport function createAgentCompletionRule(\n  handler: (agentData: NonNullable<RuleContext['agentData']>) => void | Promise<void>\n): AgentRule {\n  return {\n    id: 'builtin:agent-completion-handler',\n    name: 'Agent Completion Handler',\n    description: 'Handles agent task completion events',\n    triggers: ['agent:complete'],\n    priority: 'high',\n    condition: (context) => context.agentData !== undefined,\n    action: async (context) => {\n      if (context.agentData) {\n        await handler(context.agentData);\n      }\n    },\n  };\n}\n"],"names":[],"mappings":"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"}