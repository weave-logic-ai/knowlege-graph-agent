{"version":3,"file":"tester-agent.js","sources":["../../src/agents/tester-agent.ts"],"sourcesContent":["/**\n * Tester Agent\n *\n * Specialized agent for test generation, coverage analysis, and test improvement.\n * Extends BaseAgent with support for vitest/jest testing frameworks.\n *\n * @module agents/tester-agent\n */\n\nimport * as path from 'path';\nimport { BaseAgent } from './base-agent.js';\nimport {\n  AgentType,\n  type AgentTask,\n  type AgentResult,\n  type TesterAgentConfig,\n  type ResultArtifact,\n} from './types.js';\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Test framework type\n */\nexport type TestFramework = 'vitest' | 'jest';\n\n/**\n * Test type\n */\nexport type TestType = 'unit' | 'integration' | 'e2e' | 'snapshot';\n\n/**\n * Test generation request\n */\nexport interface TestGenerationRequest {\n  /** Source code to test */\n  sourceCode: string;\n  /** Source file path */\n  sourcePath: string;\n  /** Target test framework */\n  framework: TestFramework;\n  /** Types of tests to generate */\n  testTypes?: TestType[];\n  /** Include edge cases */\n  includeEdgeCases?: boolean;\n  /** Include error scenarios */\n  includeErrorCases?: boolean;\n  /** Coverage target percentage */\n  coverageTarget?: number;\n}\n\n/**\n * Generated test suite\n */\nexport interface GeneratedTestSuite {\n  /** Test file content */\n  code: string;\n  /** Test file path */\n  path: string;\n  /** Number of test cases */\n  testCount: number;\n  /** Estimated coverage */\n  estimatedCoverage: number;\n  /** Test categories */\n  categories: string[];\n  /** Import statements */\n  imports: string[];\n}\n\n/**\n * Test case definition\n */\nexport interface TestCase {\n  /** Test name/description */\n  name: string;\n  /** Test type */\n  type: TestType;\n  /** Test category */\n  category: string;\n  /** Test code */\n  code: string;\n  /** Setup required */\n  setup?: string;\n  /** Assertions */\n  assertions: string[];\n}\n\n/**\n * Coverage metrics\n */\nexport interface CoverageMetrics {\n  /** Line coverage percentage */\n  lines: number;\n  /** Branch coverage percentage */\n  branches: number;\n  /** Function coverage percentage */\n  functions: number;\n  /** Statement coverage percentage */\n  statements: number;\n  /** Uncovered lines */\n  uncoveredLines: number[];\n  /** Uncovered functions */\n  uncoveredFunctions: string[];\n}\n\n/**\n * Coverage analysis result\n */\nexport interface CoverageAnalysis {\n  /** Source file */\n  sourceFile: string;\n  /** Test file */\n  testFile?: string;\n  /** Coverage metrics */\n  metrics: CoverageMetrics;\n  /** Coverage gaps */\n  gaps: CoverageGap[];\n  /** Recommendations */\n  recommendations: string[];\n}\n\n/**\n * Coverage gap identification\n */\nexport interface CoverageGap {\n  /** Type of gap */\n  type: 'function' | 'branch' | 'line' | 'edge-case';\n  /** Location in source */\n  location: { start: number; end: number };\n  /** Description of what's not covered */\n  description: string;\n  /** Priority (1-10) */\n  priority: number;\n  /** Suggested test to add */\n  suggestedTest?: string;\n}\n\n/**\n * Test suggestion\n */\nexport interface TestSuggestion {\n  /** Suggestion type */\n  type: 'add' | 'improve' | 'remove' | 'refactor';\n  /** Target test or function */\n  target: string;\n  /** Description */\n  description: string;\n  /** Priority (1-10) */\n  priority: number;\n  /** Sample code */\n  sampleCode?: string;\n}\n\n/**\n * Tester task type\n */\nexport type TesterTaskType = 'generate' | 'coverage' | 'suggest' | 'analyze';\n\n// ============================================================================\n// Tester Agent\n// ============================================================================\n\n/**\n * Tester Agent\n *\n * Capabilities:\n * - Test generation from source code\n * - Coverage analysis and gap detection\n * - Test improvement suggestions\n * - Support for vitest and jest\n *\n * @example\n * ```typescript\n * const tester = new TesterAgent({\n *   name: 'tester-agent',\n *   type: AgentType.TESTER,\n *   testFramework: 'vitest',\n * });\n *\n * const result = await tester.execute({\n *   id: 'task-1',\n *   description: 'Generate tests for UserService',\n *   priority: TaskPriority.MEDIUM,\n *   input: {\n *     data: {\n *       sourceCode: '...',\n *       sourcePath: 'src/user-service.ts',\n *       framework: 'vitest',\n *       includeEdgeCases: true\n *     }\n *   },\n *   createdAt: new Date()\n * });\n * ```\n */\nexport class TesterAgent extends BaseAgent {\n  constructor(config: Partial<TesterAgentConfig> & { name: string }) {\n    super({\n      type: AgentType.TESTER,\n      taskTimeout: 180000, // 3 minutes\n      capabilities: ['test-generation', 'coverage-analysis'],\n      ...config,\n    });\n  }\n\n  // ==========================================================================\n  // Task Execution\n  // ==========================================================================\n\n  /**\n   * Execute tester task\n   */\n  protected async executeTask(task: AgentTask): Promise<AgentResult> {\n    const startTime = new Date();\n    const taskType = (task.input?.parameters?.taskType as TesterTaskType) || 'generate';\n\n    switch (taskType) {\n      case 'generate':\n        return this.handleGenerateTask(task, startTime);\n      case 'coverage':\n        return this.handleCoverageTask(task, startTime);\n      case 'suggest':\n        return this.handleSuggestTask(task, startTime);\n      case 'analyze':\n        return this.handleAnalyzeTask(task, startTime);\n      default:\n        return this.createErrorResult(\n          'INVALID_TASK_TYPE',\n          `Unknown task type: ${taskType}`,\n          startTime\n        );\n    }\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Generate tests from source code\n   */\n  async generateTests(request: TestGenerationRequest): Promise<GeneratedTestSuite> {\n    this.logger.info('Generating tests', {\n      file: request.sourcePath,\n      framework: request.framework,\n    });\n\n    const analysis = this.analyzeSourceCode(request.sourceCode);\n    const testCases: TestCase[] = [];\n\n    for (const func of analysis.functions) {\n      testCases.push(...this.generateFunctionTests(func, request));\n    }\n\n    for (const cls of analysis.classes) {\n      testCases.push(...this.generateClassTests(cls, request));\n    }\n\n    if (request.includeEdgeCases) {\n      testCases.push(...this.generateEdgeCaseTests(analysis, request));\n    }\n\n    if (request.includeErrorCases) {\n      testCases.push(...this.generateErrorCaseTests(analysis, request));\n    }\n\n    return this.buildTestSuite(testCases, request);\n  }\n\n  /**\n   * Analyze test coverage\n   */\n  async analyzeTestCoverage(\n    sourceCode: string,\n    sourcePath: string,\n    testCode?: string\n  ): Promise<CoverageAnalysis> {\n    this.logger.info('Analyzing test coverage', { file: sourcePath });\n\n    const analysis = this.analyzeSourceCode(sourceCode);\n    const gaps: CoverageGap[] = [];\n    const recommendations: string[] = [];\n\n    let testedFunctions = 0;\n    let testedBranches = 0;\n    let testedLines = 0;\n\n    if (testCode) {\n      for (const func of analysis.functions) {\n        if (testCode.includes(func.name) || testCode.includes(`'${func.name}'`)) {\n          testedFunctions++;\n        } else {\n          gaps.push({\n            type: 'function',\n            location: { start: func.line, end: func.line },\n            description: `Function '${func.name}' is not tested`,\n            priority: 8,\n            suggestedTest: this.generateTestStub(func.name, 'function'),\n          });\n        }\n      }\n\n      for (const branch of analysis.branches) {\n        if (testCode.includes(branch.condition)) {\n          testedBranches++;\n        } else {\n          gaps.push({\n            type: 'branch',\n            location: { start: branch.line, end: branch.line },\n            description: `Branch '${branch.type}' at line ${branch.line} needs testing`,\n            priority: 6,\n          });\n        }\n      }\n\n      testedLines = Math.min(\n        analysis.lines,\n        Math.round((testedFunctions / Math.max(1, analysis.functions.length)) * analysis.lines)\n      );\n    } else {\n      for (const func of analysis.functions) {\n        gaps.push({\n          type: 'function',\n          location: { start: func.line, end: func.line },\n          description: `Function '${func.name}' is not tested`,\n          priority: 8,\n          suggestedTest: this.generateTestStub(func.name, 'function'),\n        });\n      }\n      recommendations.push('Create a test file for this source file');\n    }\n\n    const metrics: CoverageMetrics = {\n      lines: analysis.lines > 0 ? Math.round((testedLines / analysis.lines) * 100) : 0,\n      branches: analysis.branches.length > 0\n        ? Math.round((testedBranches / analysis.branches.length) * 100)\n        : 100,\n      functions: analysis.functions.length > 0\n        ? Math.round((testedFunctions / analysis.functions.length) * 100)\n        : 100,\n      statements: analysis.lines > 0 ? Math.round((testedLines / analysis.lines) * 100) : 0,\n      uncoveredLines: [],\n      uncoveredFunctions: analysis.functions\n        .filter(f => !testCode?.includes(f.name))\n        .map(f => f.name),\n    };\n\n    if (metrics.functions < 80) {\n      recommendations.push(\n        `Increase function coverage from ${metrics.functions}% to at least 80%`\n      );\n    }\n    if (metrics.branches < 70) {\n      recommendations.push(\n        `Improve branch coverage from ${metrics.branches}% to at least 70%`\n      );\n    }\n    if (gaps.length > 0) {\n      recommendations.push(\n        `Address ${gaps.length} coverage gap(s) identified`\n      );\n    }\n\n    return {\n      sourceFile: sourcePath,\n      testFile: testCode ? sourcePath.replace(/\\.ts$/, '.test.ts') : undefined,\n      metrics,\n      gaps: gaps.sort((a, b) => b.priority - a.priority),\n      recommendations,\n    };\n  }\n\n  /**\n   * Suggest test improvements\n   */\n  async suggestTestCases(\n    sourceCode: string,\n    testCode: string,\n    sourcePath: string\n  ): Promise<TestSuggestion[]> {\n    this.logger.info('Analyzing tests for improvements', { file: sourcePath });\n\n    const suggestions: TestSuggestion[] = [];\n    const sourceAnalysis = this.analyzeSourceCode(sourceCode);\n    const testAnalysis = this.analyzeTestCode(testCode);\n\n    for (const func of sourceAnalysis.functions) {\n      const hasTest = testAnalysis.testedItems.includes(func.name);\n      if (!hasTest) {\n        suggestions.push({\n          type: 'add',\n          target: func.name,\n          description: `Add tests for function '${func.name}'`,\n          priority: 8,\n          sampleCode: this.generateTestStub(func.name, 'function'),\n        });\n      }\n    }\n\n    for (const func of sourceAnalysis.functions) {\n      const hasEdgeTests = testAnalysis.edgeCases.some(\n        ec => ec.includes(func.name)\n      );\n      if (!hasEdgeTests && func.hasParameters) {\n        suggestions.push({\n          type: 'add',\n          target: func.name,\n          description: `Add edge case tests for '${func.name}' (null, undefined, empty values)`,\n          priority: 6,\n          sampleCode: this.generateEdgeCaseStub(func.name),\n        });\n      }\n    }\n\n    for (const func of sourceAnalysis.functions) {\n      const hasErrorTests = testAnalysis.errorTests.some(\n        et => et.includes(func.name)\n      );\n      if (!hasErrorTests && func.hasErrorHandling) {\n        suggestions.push({\n          type: 'add',\n          target: func.name,\n          description: `Add error handling tests for '${func.name}'`,\n          priority: 7,\n          sampleCode: this.generateErrorTestStub(func.name),\n        });\n      }\n    }\n\n    for (const test of testAnalysis.tests) {\n      if (test.assertions === 0) {\n        suggestions.push({\n          type: 'improve',\n          target: test.name,\n          description: `Test '${test.name}' has no assertions`,\n          priority: 9,\n        });\n      }\n      if (test.assertions === 1) {\n        suggestions.push({\n          type: 'improve',\n          target: test.name,\n          description: `Consider adding more assertions to '${test.name}'`,\n          priority: 4,\n        });\n      }\n    }\n\n    const testNames = testAnalysis.tests.map(t => t.name);\n    const duplicates = testNames.filter(\n      (name, index) => testNames.indexOf(name) !== index\n    );\n    for (const dup of [...new Set(duplicates)]) {\n      suggestions.push({\n        type: 'remove',\n        target: dup,\n        description: `Remove duplicate test '${dup}'`,\n        priority: 5,\n      });\n    }\n\n    return suggestions.sort((a, b) => b.priority - a.priority);\n  }\n\n  // ==========================================================================\n  // Private Task Handlers\n  // ==========================================================================\n\n  private async handleGenerateTask(\n    task: AgentTask,\n    startTime: Date\n  ): Promise<AgentResult<GeneratedTestSuite>> {\n    const request = task.input?.data as TestGenerationRequest | undefined;\n\n    if (!request?.sourceCode) {\n      return this.createErrorResult(\n        'VALIDATION_ERROR',\n        'Test generation request with source code is required',\n        startTime\n      ) as AgentResult<GeneratedTestSuite>;\n    }\n\n    try {\n      const suite = await this.generateTests(request);\n      const artifacts: ResultArtifact[] = [{\n        type: 'code',\n        name: path.basename(suite.path),\n        content: suite.code,\n        mimeType: 'text/typescript',\n      }];\n\n      return this.createSuccessResult(suite, startTime, artifacts);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return this.createErrorResult('GENERATION_ERROR', `Test generation failed: ${message}`, startTime) as AgentResult<GeneratedTestSuite>;\n    }\n  }\n\n  private async handleCoverageTask(\n    task: AgentTask,\n    startTime: Date\n  ): Promise<AgentResult<CoverageAnalysis>> {\n    const input = task.input?.data as {\n      sourceCode: string;\n      sourcePath: string;\n      testCode?: string;\n    } | undefined;\n\n    if (!input?.sourceCode) {\n      return this.createErrorResult(\n        'VALIDATION_ERROR',\n        'Source code and path are required for coverage analysis',\n        startTime\n      ) as AgentResult<CoverageAnalysis>;\n    }\n\n    try {\n      const analysis = await this.analyzeTestCoverage(\n        input.sourceCode,\n        input.sourcePath,\n        input.testCode\n      );\n      return this.createSuccessResult(analysis, startTime);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return this.createErrorResult('COVERAGE_ERROR', `Coverage analysis failed: ${message}`, startTime) as AgentResult<CoverageAnalysis>;\n    }\n  }\n\n  private async handleSuggestTask(\n    task: AgentTask,\n    startTime: Date\n  ): Promise<AgentResult<TestSuggestion[]>> {\n    const input = task.input?.data as {\n      sourceCode: string;\n      testCode: string;\n      sourcePath: string;\n    } | undefined;\n\n    if (!input?.sourceCode || !input?.testCode) {\n      return this.createErrorResult(\n        'VALIDATION_ERROR',\n        'Source code and test code are required',\n        startTime\n      ) as AgentResult<TestSuggestion[]>;\n    }\n\n    try {\n      const suggestions = await this.suggestTestCases(\n        input.sourceCode,\n        input.testCode,\n        input.sourcePath\n      );\n      return this.createSuccessResult(suggestions, startTime);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return this.createErrorResult('SUGGESTION_ERROR', `Test suggestion failed: ${message}`, startTime) as AgentResult<TestSuggestion[]>;\n    }\n  }\n\n  private async handleAnalyzeTask(\n    task: AgentTask,\n    startTime: Date\n  ): Promise<AgentResult<{ coverage: CoverageAnalysis; suggestions: TestSuggestion[] }>> {\n    const input = task.input?.data as {\n      sourceCode: string;\n      sourcePath: string;\n      testCode?: string;\n    } | undefined;\n\n    if (!input?.sourceCode) {\n      return this.createErrorResult(\n        'VALIDATION_ERROR',\n        'Source code is required for analysis',\n        startTime\n      ) as AgentResult<{ coverage: CoverageAnalysis; suggestions: TestSuggestion[] }>;\n    }\n\n    try {\n      const coverage = await this.analyzeTestCoverage(\n        input.sourceCode,\n        input.sourcePath,\n        input.testCode\n      );\n\n      const suggestions = input.testCode\n        ? await this.suggestTestCases(input.sourceCode, input.testCode, input.sourcePath)\n        : [];\n\n      return this.createSuccessResult({ coverage, suggestions }, startTime);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return this.createErrorResult('ANALYSIS_ERROR', `Test analysis failed: ${message}`, startTime) as AgentResult<{ coverage: CoverageAnalysis; suggestions: TestSuggestion[] }>;\n    }\n  }\n\n  // ==========================================================================\n  // Source Code Analysis\n  // ==========================================================================\n\n  private analyzeSourceCode(code: string): {\n    functions: Array<{\n      name: string;\n      line: number;\n      params: string[];\n      hasParameters: boolean;\n      hasErrorHandling: boolean;\n      isAsync: boolean;\n    }>;\n    classes: Array<{\n      name: string;\n      line: number;\n      methods: string[];\n    }>;\n    branches: Array<{\n      type: 'if' | 'switch' | 'ternary';\n      line: number;\n      condition: string;\n    }>;\n    lines: number;\n  } {\n    const lines = code.split('\\n');\n    const functions: Array<{\n      name: string;\n      line: number;\n      params: string[];\n      hasParameters: boolean;\n      hasErrorHandling: boolean;\n      isAsync: boolean;\n    }> = [];\n    const classes: Array<{\n      name: string;\n      line: number;\n      methods: string[];\n    }> = [];\n    const branches: Array<{\n      type: 'if' | 'switch' | 'ternary';\n      line: number;\n      condition: string;\n    }> = [];\n\n    const funcRegex = /(?:export\\s+)?(?:async\\s+)?function\\s+(\\w+)\\s*\\(([^)]*)\\)/g;\n    const arrowRegex = /(?:export\\s+)?(?:const|let)\\s+(\\w+)\\s*=\\s*(?:async\\s+)?\\(([^)]*)\\)\\s*=>/g;\n    const methodRegex = /(?:async\\s+)?(\\w+)\\s*\\(([^)]*)\\)\\s*(?::\\s*[^{]+)?\\s*\\{/g;\n\n    let match;\n    while ((match = funcRegex.exec(code)) !== null) {\n      const lineNum = code.slice(0, match.index).split('\\n').length;\n      const params = match[2].split(',').map(p => p.trim()).filter(p => p);\n      const funcBody = this.extractFunctionBody(code, match.index);\n\n      functions.push({\n        name: match[1],\n        line: lineNum,\n        params,\n        hasParameters: params.length > 0,\n        hasErrorHandling: /try\\s*\\{/.test(funcBody),\n        isAsync: match[0].includes('async'),\n      });\n    }\n\n    while ((match = arrowRegex.exec(code)) !== null) {\n      const lineNum = code.slice(0, match.index).split('\\n').length;\n      const params = match[2].split(',').map(p => p.trim()).filter(p => p);\n      const funcBody = this.extractFunctionBody(code, match.index);\n\n      functions.push({\n        name: match[1],\n        line: lineNum,\n        params,\n        hasParameters: params.length > 0,\n        hasErrorHandling: /try\\s*\\{/.test(funcBody),\n        isAsync: match[0].includes('async'),\n      });\n    }\n\n    const classRegex = /(?:export\\s+)?class\\s+(\\w+)/g;\n    while ((match = classRegex.exec(code)) !== null) {\n      const lineNum = code.slice(0, match.index).split('\\n').length;\n      const classBody = this.extractClassBody(code, match.index);\n      const methods: string[] = [];\n\n      let methodMatch;\n      while ((methodMatch = methodRegex.exec(classBody)) !== null) {\n        if (!['constructor', 'if', 'while', 'for', 'switch'].includes(methodMatch[1])) {\n          methods.push(methodMatch[1]);\n        }\n      }\n\n      classes.push({\n        name: match[1],\n        line: lineNum,\n        methods,\n      });\n    }\n\n    const ifRegex = /if\\s*\\(([^)]+)\\)/g;\n    while ((match = ifRegex.exec(code)) !== null) {\n      const lineNum = code.slice(0, match.index).split('\\n').length;\n      branches.push({\n        type: 'if',\n        line: lineNum,\n        condition: match[1],\n      });\n    }\n\n    const switchRegex = /switch\\s*\\(([^)]+)\\)/g;\n    while ((match = switchRegex.exec(code)) !== null) {\n      const lineNum = code.slice(0, match.index).split('\\n').length;\n      branches.push({\n        type: 'switch',\n        line: lineNum,\n        condition: match[1],\n      });\n    }\n\n    return {\n      functions,\n      classes,\n      branches,\n      lines: lines.filter(l => l.trim().length > 0).length,\n    };\n  }\n\n  private analyzeTestCode(code: string): {\n    tests: Array<{ name: string; assertions: number }>;\n    testedItems: string[];\n    edgeCases: string[];\n    errorTests: string[];\n  } {\n    const tests: Array<{ name: string; assertions: number }> = [];\n    const testedItems: string[] = [];\n    const edgeCases: string[] = [];\n    const errorTests: string[] = [];\n\n    const testRegex = /(?:it|test)\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/g;\n    let match;\n\n    while ((match = testRegex.exec(code)) !== null) {\n      const testName = match[1];\n      const testBody = this.extractTestBody(code, match.index);\n      const assertions = (testBody.match(/expect\\s*\\(/g) || []).length;\n\n      tests.push({ name: testName, assertions });\n\n      const identifiers = testBody.match(/\\b[a-zA-Z_]\\w*\\b/g) || [];\n      testedItems.push(...identifiers);\n\n      if (\n        testName.toLowerCase().includes('edge') ||\n        testName.toLowerCase().includes('empty') ||\n        testName.toLowerCase().includes('null') ||\n        testName.toLowerCase().includes('undefined') ||\n        testBody.includes('null') ||\n        testBody.includes('undefined') ||\n        testBody.includes('[]') ||\n        testBody.includes(\"''\")\n      ) {\n        edgeCases.push(testName);\n      }\n\n      if (\n        testName.toLowerCase().includes('error') ||\n        testName.toLowerCase().includes('throw') ||\n        testName.toLowerCase().includes('fail') ||\n        testBody.includes('toThrow') ||\n        testBody.includes('rejects')\n      ) {\n        errorTests.push(testName);\n      }\n    }\n\n    return {\n      tests,\n      testedItems: [...new Set(testedItems)],\n      edgeCases,\n      errorTests,\n    };\n  }\n\n  // ==========================================================================\n  // Test Generation Methods\n  // ==========================================================================\n\n  private generateFunctionTests(\n    func: { name: string; params: string[]; isAsync: boolean; hasErrorHandling: boolean },\n    request: TestGenerationRequest\n  ): TestCase[] {\n    const testCases: TestCase[] = [];\n\n    testCases.push({\n      name: `should execute ${func.name} successfully`,\n      type: 'unit',\n      category: 'happy-path',\n      code: this.generateHappyPathTest(func),\n      assertions: ['expect(result).toBeDefined()'],\n    });\n\n    if (func.params.length > 0) {\n      for (const param of func.params) {\n        testCases.push({\n          name: `should handle ${param} parameter correctly`,\n          type: 'unit',\n          category: 'parameter-validation',\n          code: this.generateParamTest(func.name, param),\n          assertions: [`expect result for ${param}`],\n        });\n      }\n    }\n\n    return testCases;\n  }\n\n  private generateClassTests(\n    cls: { name: string; methods: string[] },\n    request: TestGenerationRequest\n  ): TestCase[] {\n    const testCases: TestCase[] = [];\n\n    testCases.push({\n      name: `should create ${cls.name} instance`,\n      type: 'unit',\n      category: 'instantiation',\n      code: `    const instance = new ${cls.name}();\\n    expect(instance).toBeInstanceOf(${cls.name});`,\n      setup: `let instance: ${cls.name};`,\n      assertions: [`expect(instance).toBeInstanceOf(${cls.name})`],\n    });\n\n    for (const method of cls.methods) {\n      testCases.push({\n        name: `should call ${method} method`,\n        type: 'unit',\n        category: 'method',\n        code: this.generateMethodTest(cls.name, method),\n        assertions: [`expect(result).toBeDefined()`],\n      });\n    }\n\n    return testCases;\n  }\n\n  private generateEdgeCaseTests(\n    analysis: ReturnType<typeof this.analyzeSourceCode>,\n    request: TestGenerationRequest\n  ): TestCase[] {\n    const testCases: TestCase[] = [];\n\n    for (const func of analysis.functions) {\n      if (func.hasParameters) {\n        testCases.push({\n          name: `should handle null input for ${func.name}`,\n          type: 'unit',\n          category: 'edge-case',\n          code: this.generateNullTest(func.name),\n          assertions: ['expect behavior with null'],\n        });\n\n        testCases.push({\n          name: `should handle empty input for ${func.name}`,\n          type: 'unit',\n          category: 'edge-case',\n          code: this.generateEmptyTest(func.name),\n          assertions: ['expect behavior with empty'],\n        });\n      }\n    }\n\n    return testCases;\n  }\n\n  private generateErrorCaseTests(\n    analysis: ReturnType<typeof this.analyzeSourceCode>,\n    request: TestGenerationRequest\n  ): TestCase[] {\n    const testCases: TestCase[] = [];\n\n    for (const func of analysis.functions) {\n      if (func.hasErrorHandling) {\n        testCases.push({\n          name: `should handle errors in ${func.name}`,\n          type: 'unit',\n          category: 'error-handling',\n          code: this.generateErrorTest(func.name, func.isAsync),\n          assertions: ['expect error handling'],\n        });\n      }\n    }\n\n    return testCases;\n  }\n\n  // ==========================================================================\n  // Test Code Generation Helpers\n  // ==========================================================================\n\n  private generateHappyPathTest(\n    func: { name: string; isAsync: boolean }\n  ): string {\n    if (func.isAsync) {\n      return `    const result = await ${func.name}();\\n    expect(result).toBeDefined();`;\n    }\n    return `    const result = ${func.name}();\\n    expect(result).toBeDefined();`;\n  }\n\n  private generateParamTest(funcName: string, param: string): string {\n    return `    const testValue = 'test-${param}';\\n    const result = ${funcName}(testValue);\\n    expect(result).toBeDefined();`;\n  }\n\n  private generateMethodTest(className: string, method: string): string {\n    return `    const instance = new ${className}();\\n    const result = instance.${method}();\\n    expect(result).toBeDefined();`;\n  }\n\n  private generateNullTest(funcName: string): string {\n    return `    expect(() => ${funcName}(null)).not.toThrow();`;\n  }\n\n  private generateEmptyTest(funcName: string): string {\n    return `    const result = ${funcName}('');\\n    expect(result).toBeDefined();`;\n  }\n\n  private generateErrorTest(funcName: string, isAsync: boolean): string {\n    if (isAsync) {\n      return `    await expect(${funcName}(invalidInput)).rejects.toThrow();`;\n    }\n    return `    expect(() => ${funcName}(invalidInput)).toThrow();`;\n  }\n\n  private generateTestStub(name: string, type: 'function' | 'class'): string {\n    if (type === 'function') {\n      return `  it('should test ${name}', () => {\\n    const result = ${name}();\\n    expect(result).toBeDefined();\\n  });`;\n    }\n    return `  it('should create ${name} instance', () => {\\n    const instance = new ${name}();\\n    expect(instance).toBeInstanceOf(${name});\\n  });`;\n  }\n\n  private generateEdgeCaseStub(funcName: string): string {\n    return `  it('should handle edge cases for ${funcName}', () => {\\n    expect(${funcName}(null)).toBeDefined();\\n    expect(${funcName}(undefined)).toBeDefined();\\n    expect(${funcName}('')).toBeDefined();\\n  });`;\n  }\n\n  private generateErrorTestStub(funcName: string): string {\n    return `  it('should handle errors in ${funcName}', () => {\\n    expect(() => ${funcName}(invalidInput)).toThrow();\\n  });`;\n  }\n\n  // ==========================================================================\n  // Test Suite Building\n  // ==========================================================================\n\n  private buildTestSuite(\n    testCases: TestCase[],\n    request: TestGenerationRequest\n  ): GeneratedTestSuite {\n    const isVitest = request.framework === 'vitest';\n    const moduleName = path.basename(request.sourcePath, path.extname(request.sourcePath));\n    const imports = this.buildImports(request, moduleName);\n\n    let code = '';\n    code += imports.join('\\n') + '\\n\\n';\n\n    const byCategory = new Map<string, TestCase[]>();\n    for (const test of testCases) {\n      if (!byCategory.has(test.category)) {\n        byCategory.set(test.category, []);\n      }\n      byCategory.get(test.category)!.push(test);\n    }\n\n    code += `describe('${moduleName}', () => {\\n`;\n\n    for (const [category, tests] of byCategory) {\n      code += `  describe('${category}', () => {\\n`;\n\n      for (const test of tests) {\n        if (test.setup) {\n          code += `    ${test.setup}\\n\\n`;\n        }\n\n        code += `    it('${test.name}', ${test.code.includes('await') ? 'async ' : ''}() => {\\n`;\n        code += test.code.split('\\n').map(l => `  ${l}`).join('\\n') + '\\n';\n        code += `    });\\n\\n`;\n      }\n\n      code += `  });\\n\\n`;\n    }\n\n    code += '});\\n';\n\n    const estimatedCoverage = Math.min(\n      100,\n      Math.round((testCases.length / Math.max(1, testCases.length)) * 80)\n    );\n\n    return {\n      code,\n      path: request.sourcePath.replace(/\\.(ts|tsx|js|jsx)$/, `.test.$1`),\n      testCount: testCases.length,\n      estimatedCoverage,\n      categories: [...byCategory.keys()],\n      imports,\n    };\n  }\n\n  private buildImports(request: TestGenerationRequest, moduleName: string): string[] {\n    const imports: string[] = [];\n    const isVitest = request.framework === 'vitest';\n\n    if (isVitest) {\n      imports.push(\"import { describe, it, expect, beforeEach, afterEach } from 'vitest';\");\n    } else {\n      imports.push(\"import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';\");\n    }\n\n    imports.push(`import { /* exports */ } from './${moduleName}';`);\n\n    return imports;\n  }\n\n  // ==========================================================================\n  // Utility Methods\n  // ==========================================================================\n\n  private extractFunctionBody(code: string, startIndex: number): string {\n    let braceCount = 0;\n    let inBody = false;\n    let bodyStart = startIndex;\n    let bodyEnd = startIndex;\n\n    for (let i = startIndex; i < code.length; i++) {\n      if (code[i] === '{') {\n        if (!inBody) {\n          bodyStart = i;\n          inBody = true;\n        }\n        braceCount++;\n      } else if (code[i] === '}') {\n        braceCount--;\n        if (inBody && braceCount === 0) {\n          bodyEnd = i + 1;\n          break;\n        }\n      }\n    }\n\n    return code.slice(bodyStart, bodyEnd);\n  }\n\n  private extractClassBody(code: string, startIndex: number): string {\n    return this.extractFunctionBody(code, startIndex);\n  }\n\n  private extractTestBody(code: string, startIndex: number): string {\n    let parenCount = 0;\n    let inTest = false;\n    let bodyStart = startIndex;\n\n    for (let i = startIndex; i < code.length; i++) {\n      if (code[i] === '(') {\n        parenCount++;\n        inTest = true;\n      } else if (code[i] === ')') {\n        parenCount--;\n        if (inTest && parenCount === 0) {\n          return code.slice(bodyStart, i + 1);\n        }\n      }\n    }\n\n    return code.slice(bodyStart, Math.min(bodyStart + 500, code.length));\n  }\n}\n\n"],"names":[],"mappings":"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"}