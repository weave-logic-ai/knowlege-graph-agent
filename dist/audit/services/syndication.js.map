{"version":3,"file":"syndication.js","sources":["../../../src/audit/services/syndication.ts"],"sourcesContent":["/**\n * Syndication Service\n *\n * Handles cross-environment event synchronization between\n * multiple audit chain instances using peer-to-peer communication.\n *\n * Features:\n * - Peer connection management with health tracking\n * - Bidirectional event synchronization\n * - Conflict detection and resolution\n * - Automatic periodic sync with configurable intervals\n * - Exponential backoff for failed sync attempts\n *\n * @module audit/services/syndication\n */\n\nimport type {\n  Blake3Hash,\n  Did,\n  LedgerEvent,\n  Checkpoint,\n  SyncRequest,\n  SyncResponse,\n  KnowledgeGraphEventPayload,\n} from '../types.js';\nimport { AuditChain } from './audit-chain.js';\nimport { createLogger } from '../../utils/index.js';\n\nconst logger = createLogger('syndication');\n\n/**\n * Peer connection status\n */\nexport type PeerStatus = 'connected' | 'disconnected' | 'syncing' | 'error';\n\n/**\n * Peer information\n */\nexport interface PeerInfo {\n  /** Unique peer identifier */\n  id: string;\n  /** Network endpoint URL */\n  endpoint: string;\n  /** Peer's decentralized identifier */\n  did?: Did;\n  /** Current connection status */\n  status: PeerStatus;\n  /** Timestamp of last successful sync */\n  lastSyncTime?: Date;\n  /** Height of last synced checkpoint */\n  lastCheckpointHeight?: number;\n  /** Total events received from this peer */\n  eventsReceived: number;\n  /** Total events sent to this peer */\n  eventsSent: number;\n  /** Cumulative error count */\n  errors: number;\n  /** Last error message */\n  lastError?: string;\n  /** Connection latency in milliseconds */\n  latency?: number;\n}\n\n/**\n * Sync operation result\n */\nexport interface SyncResult {\n  /** ID of the synced peer */\n  peerId: string;\n  /** Whether sync completed successfully */\n  success: boolean;\n  /** Number of events received during sync */\n  eventsReceived: number;\n  /** Number of events sent during sync */\n  eventsSent: number;\n  /** New checkpoint height after sync */\n  newCheckpointHeight?: number;\n  /** Sync duration in milliseconds */\n  duration: number;\n  /** Error message if sync failed */\n  error?: string;\n}\n\n/**\n * Syndication service configuration\n */\nexport interface SyndicationConfig {\n  /** Local audit chain instance */\n  auditChain: AuditChain;\n  /** Initial peer endpoints */\n  peers: string[];\n  /** Enable automatic periodic synchronization */\n  autoSync: boolean;\n  /** Interval between auto-syncs in milliseconds */\n  syncInterval: number;\n  /** Timeout for sync requests in milliseconds */\n  requestTimeout: number;\n  /** Maximum events to transfer per sync request */\n  maxEventsPerRequest: number;\n  /** Retry failed syncs automatically */\n  retryOnError: boolean;\n  /** Maximum retry attempts before giving up */\n  maxRetries: number;\n  /** Base delay for exponential backoff in milliseconds */\n  retryBaseDelay: number;\n  /** Maximum delay between retries in milliseconds */\n  retryMaxDelay: number;\n}\n\n/**\n * Default syndication configuration values\n */\nconst DEFAULT_CONFIG: Omit<SyndicationConfig, 'auditChain'> = {\n  peers: [],\n  autoSync: false,\n  syncInterval: 5 * 60 * 1000, // 5 minutes\n  requestTimeout: 30000, // 30 seconds\n  maxEventsPerRequest: 1000,\n  retryOnError: true,\n  maxRetries: 3,\n  retryBaseDelay: 1000, // 1 second\n  retryMaxDelay: 30000, // 30 seconds\n};\n\n/**\n * Syndication Service\n *\n * Manages peer-to-peer synchronization of audit events across\n * multiple environments. Provides:\n *\n * - Peer discovery and connection management\n * - Bidirectional event synchronization\n * - Conflict detection with hash-based resolution\n * - Automatic periodic sync with health monitoring\n * - Statistics and observability\n *\n * @example\n * ```typescript\n * const auditChain = createAuditChain({ agentDid: 'did:exo:agent-1' });\n * await auditChain.initialize();\n *\n * const syndication = createSyndicationService({\n *   auditChain,\n *   peers: ['https://peer1.example.com/audit', 'https://peer2.example.com/audit'],\n *   autoSync: true,\n *   syncInterval: 60000, // 1 minute\n * });\n *\n * await syndication.start();\n *\n * // Manual sync trigger\n * const results = await syndication.syncWithAllPeers();\n * ```\n */\nexport class SyndicationService {\n  private config: SyndicationConfig;\n  private peers: Map<string, PeerInfo> = new Map();\n  private syncTimer?: ReturnType<typeof setInterval>;\n  private isRunning: boolean = false;\n  private syncInProgress: boolean = false;\n  private retryAttempts: Map<string, number> = new Map();\n\n  /**\n   * Create a new syndication service instance\n   *\n   * @param config - Configuration with required auditChain\n   */\n  constructor(config: Partial<SyndicationConfig> & { auditChain: AuditChain }) {\n    this.config = {\n      ...DEFAULT_CONFIG,\n      ...config,\n    };\n\n    // Initialize peers from config\n    for (const endpoint of this.config.peers) {\n      const peerId = this.generatePeerId(endpoint);\n      this.peers.set(peerId, {\n        id: peerId,\n        endpoint,\n        status: 'disconnected',\n        eventsReceived: 0,\n        eventsSent: 0,\n        errors: 0,\n      });\n    }\n  }\n\n  /**\n   * Generate a deterministic peer ID from endpoint URL\n   *\n   * @param endpoint - Peer endpoint URL\n   * @returns Generated peer ID\n   */\n  private generatePeerId(endpoint: string): string {\n    // Simple hash for peer ID generation\n    let hash = 0;\n    for (let i = 0; i < endpoint.length; i++) {\n      const char = endpoint.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    return `peer-${Math.abs(hash).toString(36)}`;\n  }\n\n  /**\n   * Calculate exponential backoff delay\n   *\n   * @param attempt - Current retry attempt number\n   * @returns Delay in milliseconds\n   */\n  private calculateBackoff(attempt: number): number {\n    const delay = this.config.retryBaseDelay * Math.pow(2, attempt);\n    const jitter = Math.random() * 0.3 * delay; // 30% jitter\n    return Math.min(delay + jitter, this.config.retryMaxDelay);\n  }\n\n  /**\n   * Start the syndication service\n   *\n   * Connects to all configured peers and starts automatic\n   * synchronization if enabled.\n   */\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      logger.warn('Syndication service already running');\n      return;\n    }\n\n    logger.info('Starting syndication service', {\n      peers: this.peers.size,\n      autoSync: this.config.autoSync,\n      syncInterval: this.config.syncInterval,\n    });\n\n    this.isRunning = true;\n\n    // Connect to all peers\n    await this.connectToPeers();\n\n    // Start auto-sync if enabled\n    if (this.config.autoSync) {\n      this.startAutoSync();\n    }\n\n    logger.info('Syndication service started', {\n      connectedPeers: this.getConnectedPeers().length,\n    });\n  }\n\n  /**\n   * Stop the syndication service\n   *\n   * Disconnects from all peers and stops automatic synchronization.\n   */\n  async stop(): Promise<void> {\n    if (!this.isRunning) {\n      return;\n    }\n\n    logger.info('Stopping syndication service');\n\n    // Stop auto-sync\n    if (this.syncTimer) {\n      clearInterval(this.syncTimer);\n      this.syncTimer = undefined;\n    }\n\n    // Wait for any in-progress sync to complete\n    const maxWait = 5000;\n    const startWait = Date.now();\n    while (this.syncInProgress && Date.now() - startWait < maxWait) {\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n\n    // Disconnect from peers\n    for (const peer of this.peers.values()) {\n      peer.status = 'disconnected';\n    }\n\n    this.isRunning = false;\n    this.retryAttempts.clear();\n    logger.info('Syndication service stopped');\n  }\n\n  /**\n   * Connect to all configured peers\n   */\n  private async connectToPeers(): Promise<void> {\n    const connectPromises = Array.from(this.peers.values()).map(async (peer) => {\n      try {\n        await this.connectToPeer(peer.id);\n      } catch (error) {\n        logger.warn('Failed to connect to peer', {\n          peerId: peer.id,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    });\n\n    await Promise.allSettled(connectPromises);\n  }\n\n  /**\n   * Establish connection to a specific peer\n   *\n   * @param peerId - Peer identifier\n   * @returns True if connection successful\n   */\n  async connectToPeer(peerId: string): Promise<boolean> {\n    const peer = this.peers.get(peerId);\n    if (!peer) {\n      logger.warn('Peer not found', { peerId });\n      return false;\n    }\n\n    try {\n      // In production, would establish WebSocket or HTTP/2 connection\n      // For now, simulate connection with health check\n      const startTime = Date.now();\n\n      // Simulate network latency\n      await new Promise(resolve => setTimeout(resolve, 50));\n\n      peer.status = 'connected';\n      peer.latency = Date.now() - startTime;\n      this.retryAttempts.set(peerId, 0);\n\n      logger.debug('Connected to peer', {\n        peerId,\n        endpoint: peer.endpoint,\n        latency: peer.latency,\n      });\n\n      return true;\n    } catch (error) {\n      peer.status = 'error';\n      peer.errors++;\n      peer.lastError = error instanceof Error ? error.message : String(error);\n\n      logger.error('Failed to connect to peer', undefined, {\n        peerId,\n        errorMessage: peer.lastError,\n      });\n\n      return false;\n    }\n  }\n\n  /**\n   * Disconnect from a specific peer\n   *\n   * @param peerId - Peer identifier\n   */\n  async disconnectPeer(peerId: string): Promise<void> {\n    const peer = this.peers.get(peerId);\n    if (peer) {\n      peer.status = 'disconnected';\n      logger.debug('Disconnected from peer', { peerId });\n    }\n  }\n\n  /**\n   * Start automatic periodic synchronization\n   */\n  private startAutoSync(): void {\n    if (this.syncTimer) {\n      clearInterval(this.syncTimer);\n    }\n\n    this.syncTimer = setInterval(async () => {\n      if (!this.syncInProgress) {\n        try {\n          await this.syncWithAllPeers();\n        } catch (err) {\n          logger.error('Auto-sync failed', err instanceof Error ? err : undefined, {\n            errorMessage: err instanceof Error ? err.message : String(err),\n          });\n        }\n      }\n    }, this.config.syncInterval);\n\n    logger.debug('Auto-sync started', { interval: this.config.syncInterval });\n  }\n\n  /**\n   * Stop automatic synchronization\n   */\n  stopAutoSync(): void {\n    if (this.syncTimer) {\n      clearInterval(this.syncTimer);\n      this.syncTimer = undefined;\n      logger.debug('Auto-sync stopped');\n    }\n  }\n\n  /**\n   * Synchronize with all connected peers\n   *\n   * @returns Array of sync results for each peer\n   */\n  async syncWithAllPeers(): Promise<SyncResult[]> {\n    if (this.syncInProgress) {\n      logger.warn('Sync already in progress, skipping');\n      return [];\n    }\n\n    this.syncInProgress = true;\n    const results: SyncResult[] = [];\n\n    try {\n      const connectedPeers = this.getConnectedPeers();\n      logger.debug('Starting sync with all peers', { count: connectedPeers.length });\n\n      for (const peer of connectedPeers) {\n        const result = await this.syncWithPeer(peer.id);\n        results.push(result);\n\n        // Handle retry logic for failed syncs\n        if (!result.success && this.config.retryOnError) {\n          const attempts = (this.retryAttempts.get(peer.id) || 0) + 1;\n          this.retryAttempts.set(peer.id, attempts);\n\n          if (attempts <= this.config.maxRetries) {\n            const delay = this.calculateBackoff(attempts);\n            logger.debug('Scheduling retry', { peerId: peer.id, attempt: attempts, delay });\n            setTimeout(() => this.syncWithPeer(peer.id), delay);\n          } else {\n            logger.warn('Max retries exceeded for peer', { peerId: peer.id });\n          }\n        }\n      }\n\n      const successful = results.filter(r => r.success).length;\n      logger.info('Sync completed', {\n        total: results.length,\n        successful,\n        failed: results.length - successful,\n      });\n    } finally {\n      this.syncInProgress = false;\n    }\n\n    return results;\n  }\n\n  /**\n   * Synchronize with a specific peer\n   *\n   * @param peerId - Peer identifier\n   * @returns Sync result\n   */\n  async syncWithPeer(peerId: string): Promise<SyncResult> {\n    const peer = this.peers.get(peerId);\n    if (!peer) {\n      return {\n        peerId,\n        success: false,\n        eventsReceived: 0,\n        eventsSent: 0,\n        duration: 0,\n        error: 'Peer not found',\n      };\n    }\n\n    if (peer.status !== 'connected') {\n      // Try to reconnect\n      const connected = await this.connectToPeer(peerId);\n      if (!connected) {\n        return {\n          peerId,\n          success: false,\n          eventsReceived: 0,\n          eventsSent: 0,\n          duration: 0,\n          error: 'Peer not connected',\n        };\n      }\n    }\n\n    const startTime = Date.now();\n    const previousStatus = peer.status;\n    peer.status = 'syncing';\n\n    try {\n      // Log sync start event\n      await this.config.auditChain.appendEvent({\n        type: 'SyncStarted',\n        peerId,\n        direction: 'bidirectional',\n      } as KnowledgeGraphEventPayload);\n\n      // Create sync request with current state\n      const checkpoint = this.config.auditChain.getLatestCheckpoint();\n      const request: SyncRequest = {\n        requester: this.config.auditChain.getConfig().agentDid,\n        lastCheckpointHeight: checkpoint?.height ?? -1,\n        lastEventRoot: checkpoint?.eventRoot,\n        maxEvents: this.config.maxEventsPerRequest,\n      };\n\n      // Fetch events from peer\n      const response = await this.fetchFromPeer(peer, request);\n\n      // Process received events\n      let eventsReceived = 0;\n      for (const event of response.events) {\n        const validation = await this.config.auditChain.validateAndInsert(event);\n        if (validation.valid) {\n          eventsReceived++;\n        } else {\n          logger.debug('Received invalid event', {\n            eventId: event.id,\n            errors: validation.errors,\n          });\n        }\n      }\n\n      // Send our events to peer\n      const ourEvents = await this.getEventsSince(peer.lastCheckpointHeight ?? -1);\n      const eventsSent = await this.sendToPeer(peer, ourEvents);\n\n      // Update peer stats\n      peer.eventsReceived += eventsReceived;\n      peer.eventsSent += eventsSent;\n      peer.lastSyncTime = new Date();\n      peer.lastCheckpointHeight = response.checkpoint?.height ?? peer.lastCheckpointHeight;\n      peer.status = 'connected';\n\n      // Reset retry counter on success\n      this.retryAttempts.set(peerId, 0);\n\n      const duration = Date.now() - startTime;\n\n      // Log sync completion event\n      await this.config.auditChain.appendEvent({\n        type: 'SyncCompleted',\n        peerId,\n        eventsTransferred: eventsReceived + eventsSent,\n        duration,\n      } as KnowledgeGraphEventPayload);\n\n      logger.info('Sync with peer completed', {\n        peerId,\n        eventsReceived,\n        eventsSent,\n        duration,\n      });\n\n      return {\n        peerId,\n        success: true,\n        eventsReceived,\n        eventsSent,\n        newCheckpointHeight: response.checkpoint?.height,\n        duration,\n      };\n    } catch (err) {\n      peer.status = 'error';\n      peer.errors++;\n      peer.lastError = err instanceof Error ? err.message : String(err);\n      const duration = Date.now() - startTime;\n\n      logger.error('Sync with peer failed', err instanceof Error ? err : undefined, {\n        peerId,\n        errorMessage: peer.lastError,\n        duration,\n      });\n\n      return {\n        peerId,\n        success: false,\n        eventsReceived: 0,\n        eventsSent: 0,\n        duration,\n        error: peer.lastError,\n      };\n    }\n  }\n\n  /**\n   * Fetch events from a peer\n   *\n   * In production, this would make an HTTP/WebSocket request.\n   *\n   * @param peer - Peer information\n   * @param request - Sync request\n   * @returns Sync response\n   */\n  private async fetchFromPeer(peer: PeerInfo, _request: SyncRequest): Promise<SyncResponse> {\n    // In production implementation:\n    // - Make HTTP POST to peer.endpoint/sync\n    // - Set timeout from config.requestTimeout\n    // - Handle authentication/authorization\n    // - Verify response signatures\n\n    // Simulate network operation\n    await new Promise(resolve => setTimeout(resolve, 10));\n\n    // Return empty response for now\n    return {\n      provider: peer.did || (`did:exo:${peer.id}` as Did),\n      events: [],\n      hasMore: false,\n    };\n  }\n\n  /**\n   * Send events to a peer\n   *\n   * In production, this would make an HTTP/WebSocket request.\n   *\n   * @param peer - Peer information\n   * @param events - Events to send\n   * @returns Number of events successfully sent\n   */\n  private async sendToPeer(_peer: PeerInfo, events: LedgerEvent[]): Promise<number> {\n    // In production implementation:\n    // - Make HTTP POST to peer.endpoint/events\n    // - Batch events if exceeding maxEventsPerRequest\n    // - Handle acknowledgments\n    // - Retry failed sends\n\n    // Simulate network operation\n    await new Promise(resolve => setTimeout(resolve, 10));\n\n    return events.length;\n  }\n\n  /**\n   * Get events since a specific checkpoint height\n   *\n   * Uses the audit chain's query capability to retrieve events\n   * that occurred after the specified checkpoint.\n   *\n   * @param checkpointHeight - Height to query from\n   * @returns Array of events\n   */\n  private async getEventsSince(checkpointHeight: number): Promise<LedgerEvent[]> {\n    const result = await this.config.auditChain.queryEvents({\n      limit: this.config.maxEventsPerRequest,\n    });\n\n    // The events are returned in HLC order from queryEvents\n    // For checkpoint-based filtering, we use the total count as a proxy\n    // In production, would use more efficient index-based query\n    // that tracks checkpoint heights directly\n    if (checkpointHeight < 0) {\n      return result.events;\n    }\n\n    // Return events beyond the checkpoint count\n    return result.events.slice(checkpointHeight);\n  }\n\n  /**\n   * Add a new peer to the syndication network\n   *\n   * @param endpoint - Peer endpoint URL\n   * @returns Generated peer ID\n   */\n  addPeer(endpoint: string): string {\n    const peerId = this.generatePeerId(endpoint);\n\n    if (!this.peers.has(peerId)) {\n      this.peers.set(peerId, {\n        id: peerId,\n        endpoint,\n        status: 'disconnected',\n        eventsReceived: 0,\n        eventsSent: 0,\n        errors: 0,\n      });\n\n      logger.debug('Added peer', { peerId, endpoint });\n\n      // Auto-connect if service is running\n      if (this.isRunning) {\n        this.connectToPeer(peerId).catch((error) => {\n          logger.warn('Failed to connect to new peer', {\n            peerId,\n            error: error instanceof Error ? error.message : String(error),\n          });\n        });\n      }\n    } else {\n      logger.debug('Peer already exists', { peerId, endpoint });\n    }\n\n    return peerId;\n  }\n\n  /**\n   * Remove a peer from the syndication network\n   *\n   * @param peerId - Peer identifier\n   * @returns True if peer was removed\n   */\n  removePeer(peerId: string): boolean {\n    const removed = this.peers.delete(peerId);\n    if (removed) {\n      this.retryAttempts.delete(peerId);\n      logger.debug('Removed peer', { peerId });\n    }\n    return removed;\n  }\n\n  /**\n   * Get information about a specific peer\n   *\n   * @param peerId - Peer identifier\n   * @returns Peer information or undefined\n   */\n  getPeer(peerId: string): PeerInfo | undefined {\n    return this.peers.get(peerId);\n  }\n\n  /**\n   * Get all registered peers\n   *\n   * @returns Array of all peer information\n   */\n  getAllPeers(): PeerInfo[] {\n    return Array.from(this.peers.values());\n  }\n\n  /**\n   * Get currently connected peers\n   *\n   * @returns Array of connected peer information\n   */\n  getConnectedPeers(): PeerInfo[] {\n    return Array.from(this.peers.values()).filter(p => p.status === 'connected');\n  }\n\n  /**\n   * Get peers in error state\n   *\n   * @returns Array of error state peer information\n   */\n  getErrorPeers(): PeerInfo[] {\n    return Array.from(this.peers.values()).filter(p => p.status === 'error');\n  }\n\n  /**\n   * Get comprehensive service statistics\n   *\n   * @returns Statistics object\n   */\n  getStats(): {\n    totalPeers: number;\n    connectedPeers: number;\n    syncingPeers: number;\n    errorPeers: number;\n    totalEventsReceived: number;\n    totalEventsSent: number;\n    totalErrors: number;\n    isRunning: boolean;\n    autoSyncEnabled: boolean;\n    syncInterval: number;\n  } {\n    let totalEventsReceived = 0;\n    let totalEventsSent = 0;\n    let totalErrors = 0;\n    let connectedPeers = 0;\n    let syncingPeers = 0;\n    let errorPeers = 0;\n\n    for (const peer of this.peers.values()) {\n      totalEventsReceived += peer.eventsReceived;\n      totalEventsSent += peer.eventsSent;\n      totalErrors += peer.errors;\n\n      switch (peer.status) {\n        case 'connected':\n          connectedPeers++;\n          break;\n        case 'syncing':\n          syncingPeers++;\n          break;\n        case 'error':\n          errorPeers++;\n          break;\n      }\n    }\n\n    return {\n      totalPeers: this.peers.size,\n      connectedPeers,\n      syncingPeers,\n      errorPeers,\n      totalEventsReceived,\n      totalEventsSent,\n      totalErrors,\n      isRunning: this.isRunning,\n      autoSyncEnabled: this.config.autoSync,\n      syncInterval: this.config.syncInterval,\n    };\n  }\n\n  /**\n   * Force an immediate sync with all peers\n   *\n   * @returns Array of sync results\n   */\n  async forceSyncNow(): Promise<SyncResult[]> {\n    logger.info('Force sync requested');\n    return await this.syncWithAllPeers();\n  }\n\n  /**\n   * Check if the service is currently running\n   *\n   * @returns True if running\n   */\n  isServiceRunning(): boolean {\n    return this.isRunning;\n  }\n\n  /**\n   * Check if a sync is currently in progress\n   *\n   * @returns True if syncing\n   */\n  isSyncing(): boolean {\n    return this.syncInProgress;\n  }\n\n  /**\n   * Update service configuration\n   *\n   * Note: Some config changes require restart to take effect.\n   *\n   * @param updates - Configuration updates\n   */\n  updateConfig(updates: Partial<Omit<SyndicationConfig, 'auditChain'>>): void {\n    const previousAutoSync = this.config.autoSync;\n    const previousInterval = this.config.syncInterval;\n\n    Object.assign(this.config, updates);\n\n    // Handle auto-sync changes\n    if (this.isRunning) {\n      if (updates.autoSync !== undefined || updates.syncInterval !== undefined) {\n        if (this.config.autoSync && (!previousAutoSync || this.config.syncInterval !== previousInterval)) {\n          this.startAutoSync();\n        } else if (!this.config.autoSync && previousAutoSync) {\n          this.stopAutoSync();\n        }\n      }\n    }\n\n    logger.debug('Configuration updated', { updates });\n  }\n}\n\n/**\n * Create a syndication service instance\n *\n * @param config - Configuration with required auditChain\n * @returns Configured SyndicationService instance\n *\n * @example\n * ```typescript\n * const syndication = createSyndicationService({\n *   auditChain,\n *   peers: ['https://peer1.example.com/audit'],\n *   autoSync: true,\n * });\n * ```\n */\nexport function createSyndicationService(\n  config: Partial<SyndicationConfig> & { auditChain: AuditChain }\n): SyndicationService {\n  return new SyndicationService(config);\n}\n"],"names":[],"mappings":"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"}