{"version":3,"file":"vector.js","sources":["../../../src/cli/commands/vector.ts"],"sourcesContent":["/**\n * Vector Command\n *\n * CLI commands for vector operations including semantic search,\n * vector store statistics, index management, and trajectory tracking.\n *\n * @module cli/commands/vector\n */\n\nimport { Command } from 'commander';\nimport chalk from 'chalk';\nimport ora from 'ora';\nimport { join } from 'path';\nimport { existsSync } from 'fs';\nimport {\n  createVectorStore,\n  createTrajectoryTracker,\n  type VectorIndexStats,\n  type SearchResult,\n  type AgentTrajectory,\n  type DetectedPattern,\n} from '../../vector/index.js';\nimport { validateProjectRoot } from '../../core/security.js';\n\n/**\n * Format bytes to human-readable string\n */\nfunction formatBytes(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;\n  if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;\n  return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;\n}\n\n/**\n * Format duration in milliseconds to human-readable string\n */\nfunction formatDuration(ms: number): string {\n  if (ms < 1000) return `${ms}ms`;\n  if (ms < 60000) return `${(ms / 1000).toFixed(2)}s`;\n  if (ms < 3600000) return `${(ms / 60000).toFixed(2)}m`;\n  return `${(ms / 3600000).toFixed(2)}h`;\n}\n\n/**\n * Format table row with padding\n */\nfunction formatRow(cells: string[], widths: number[]): string {\n  return cells.map((cell, i) => cell.padEnd(widths[i])).join('  ');\n}\n\n/**\n * Print a table with headers and rows\n */\nfunction printTable(\n  headers: string[],\n  rows: string[][],\n  options: { indent?: number; headerColor?: typeof chalk.white } = {}\n): void {\n  const indent = '  '.repeat(options.indent ?? 1);\n  const headerColor = options.headerColor ?? chalk.white;\n\n  // Calculate column widths\n  const widths = headers.map((h, i) => {\n    const maxRowWidth = Math.max(...rows.map((r) => (r[i] || '').length));\n    return Math.max(h.length, maxRowWidth);\n  });\n\n  // Print header\n  console.log(indent + headerColor(formatRow(headers, widths)));\n  console.log(indent + chalk.gray('-'.repeat(widths.reduce((a, b) => a + b + 2, 0))));\n\n  // Print rows\n  for (const row of rows) {\n    console.log(indent + chalk.gray(formatRow(row, widths)));\n  }\n}\n\n/**\n * Create vector command group\n */\nexport function createVectorCommand(): Command {\n  const vector = new Command('vector')\n    .alias('vec')\n    .description('Vector operations for semantic search and trajectory tracking');\n\n  // Search subcommand\n  vector\n    .command('search <query>')\n    .description('Perform semantic search on vector store')\n    .option('-p, --path <path>', 'Project root path', '.')\n    .option('-k, --top-k <n>', 'Number of results to return', '10')\n    .option('-t, --type <type>', 'Filter by node type')\n    .option('--hybrid', 'Enable hybrid search (combines vector + graph)')\n    .option('--min-score <score>', 'Minimum similarity score (0-1)', '0')\n    .option('--json', 'Output as JSON')\n    .action(async (query, options) => {\n      const spinner = ora('Searching vectors...').start();\n\n      try {\n        const projectRoot = validateProjectRoot(options.path);\n        const topK = parseInt(options.topK, 10) || 10;\n        const minScore = parseFloat(options.minScore) || 0;\n\n        // Create vector store\n        const store = createVectorStore();\n        await store.initialize();\n\n        // Check if we have vectors\n        const stats = store.getStats();\n        if (stats.totalVectors === 0) {\n          spinner.warn('Vector store is empty');\n          console.log(chalk.gray('  No vectors have been indexed yet.'));\n          console.log(chalk.gray('  Run ') + chalk.cyan('kg vector rebuild') + chalk.gray(' to index vectors.'));\n          return;\n        }\n\n        spinner.text = 'Generating query embedding...';\n\n        // For now, create a mock embedding from the query\n        // In production, this would use an actual embedding model\n        const queryEmbedding = createMockEmbedding(query, stats.dimensions);\n\n        spinner.text = `Searching ${stats.totalVectors} vectors...`;\n\n        let results: SearchResult[];\n\n        if (options.hybrid) {\n          // Hybrid search\n          const hybridResults = await store.hybridSearch({\n            embedding: queryEmbedding,\n            limit: topK,\n            minScore,\n            filters: options.type ? { type: options.type } : undefined,\n          });\n          results = hybridResults;\n        } else {\n          // Standard vector search\n          results = await store.search({\n            vector: queryEmbedding,\n            k: topK,\n            minScore,\n            filter: options.type ? { type: options.type } : undefined,\n          });\n        }\n\n        spinner.stop();\n\n        if (options.json) {\n          console.log(JSON.stringify(results, null, 2));\n          return;\n        }\n\n        console.log(chalk.cyan(`\\n  Search Results for \"${query}\"\\n`));\n\n        if (results.length === 0) {\n          console.log(chalk.gray('  No results found'));\n          return;\n        }\n\n        console.log(chalk.gray(`  Found ${results.length} result${results.length === 1 ? '' : 's'}\\n`));\n\n        // Display results as a table\n        const headers = ['#', 'ID', 'Score', 'Type', 'Metadata'];\n        const rows = results.map((r, i) => [\n          String(i + 1),\n          r.id.substring(0, 24) + (r.id.length > 24 ? '...' : ''),\n          r.score.toFixed(4),\n          (r.metadata?.type as string) || '-',\n          Object.keys(r.metadata || {}).length > 0\n            ? Object.keys(r.metadata).slice(0, 3).join(', ')\n            : '-',\n        ]);\n\n        printTable(headers, rows);\n\n        // Show detailed metadata for top results\n        console.log(chalk.white('\\n  Top Result Details:\\n'));\n        const top = results[0];\n        console.log(chalk.gray(`    ID: ${top.id}`));\n        console.log(chalk.gray(`    Score: ${top.score.toFixed(6)}`));\n        if (top.distance !== undefined) {\n          console.log(chalk.gray(`    Distance: ${top.distance.toFixed(6)}`));\n        }\n        if (Object.keys(top.metadata || {}).length > 0) {\n          console.log(chalk.gray('    Metadata:'));\n          for (const [key, value] of Object.entries(top.metadata)) {\n            const displayValue = typeof value === 'object' ? JSON.stringify(value) : String(value);\n            console.log(chalk.gray(`      ${key}: ${displayValue.substring(0, 50)}`));\n          }\n        }\n\n        console.log();\n      } catch (error) {\n        spinner.fail('Search failed');\n        console.error(chalk.red(String(error)));\n        process.exit(1);\n      }\n    });\n\n  // Stats subcommand\n  vector\n    .command('stats')\n    .description('Display vector store statistics')\n    .option('-p, --path <path>', 'Project root path', '.')\n    .option('--json', 'Output as JSON')\n    .action(async (options) => {\n      try {\n        const projectRoot = validateProjectRoot(options.path);\n\n        // Create vector store\n        const store = createVectorStore();\n        await store.initialize();\n\n        const stats = store.getStats();\n\n        if (options.json) {\n          console.log(JSON.stringify(stats, null, 2));\n          return;\n        }\n\n        console.log(chalk.cyan.bold('\\n  Vector Store Statistics\\n'));\n\n        // Overview\n        console.log(chalk.white('  Overview'));\n        console.log(chalk.gray(`    Total Vectors:   ${stats.totalVectors.toLocaleString()}`));\n        console.log(chalk.gray(`    Dimensions:      ${stats.dimensions}`));\n        console.log(chalk.gray(`    Index Type:      ${stats.indexType.toUpperCase()}`));\n        console.log(chalk.gray(`    Memory Usage:    ${formatBytes(stats.memoryUsage)}`));\n        console.log(chalk.gray(`    Last Updated:    ${stats.lastUpdated.toISOString()}`));\n\n        // Index stats\n        if (stats.indexStats) {\n          console.log();\n          console.log(chalk.white('  Index Configuration'));\n          if (stats.indexStats.levels !== undefined) {\n            console.log(chalk.gray(`    HNSW Levels:     ${stats.indexStats.levels}`));\n          }\n          if (stats.indexStats.entryPoint) {\n            console.log(chalk.gray(`    Entry Point:     ${stats.indexStats.entryPoint.substring(0, 24)}...`));\n          }\n          if (stats.indexStats.avgConnections !== undefined) {\n            console.log(chalk.gray(`    Avg Connections: ${stats.indexStats.avgConnections.toFixed(2)}`));\n          }\n        }\n\n        // Namespace breakdown\n        if (stats.namespaces && Object.keys(stats.namespaces).length > 0) {\n          console.log();\n          console.log(chalk.white('  Namespaces'));\n          for (const [ns, count] of Object.entries(stats.namespaces)) {\n            const bar = '|'.repeat(Math.min(count, 30));\n            console.log(chalk.gray(`    ${ns.padEnd(15)} ${String(count).padStart(6)} ${chalk.blue(bar)}`));\n          }\n        }\n\n        // Performance hints\n        console.log();\n        console.log(chalk.white('  Performance'));\n        if (stats.totalVectors === 0) {\n          console.log(chalk.yellow('    [!] Vector store is empty'));\n          console.log(chalk.gray('        Run \"kg vector rebuild\" to populate the index'));\n        } else if (stats.totalVectors < 100) {\n          console.log(chalk.green('    [OK] Small index - linear search may be faster'));\n        } else if (stats.totalVectors < 10000) {\n          console.log(chalk.green('    [OK] Medium index - HNSW optimal'));\n        } else {\n          console.log(chalk.yellow('    [!] Large index - consider quantization'));\n        }\n\n        console.log();\n      } catch (error) {\n        console.error(chalk.red('Failed to get stats:'), String(error));\n        process.exit(1);\n      }\n    });\n\n  // Rebuild subcommand\n  vector\n    .command('rebuild')\n    .description('Rebuild vector index from knowledge graph')\n    .option('-p, --path <path>', 'Project root path', '.')\n    .option('--force', 'Force rebuild even if index exists')\n    .option('--batch-size <size>', 'Batch size for indexing', '100')\n    .option('-v, --verbose', 'Verbose output')\n    .action(async (options) => {\n      const spinner = ora('Rebuilding vector index...').start();\n\n      try {\n        const projectRoot = validateProjectRoot(options.path);\n        const batchSize = parseInt(options.batchSize, 10) || 100;\n\n        // Create vector store\n        const store = createVectorStore();\n        await store.initialize();\n\n        const existingStats = store.getStats();\n\n        if (existingStats.totalVectors > 0 && !options.force) {\n          spinner.warn(`Index already contains ${existingStats.totalVectors} vectors`);\n          console.log(chalk.gray('  Use --force to rebuild anyway'));\n          return;\n        }\n\n        if (options.force && existingStats.totalVectors > 0) {\n          spinner.text = 'Clearing existing index...';\n          await store.clear();\n        }\n\n        // In a real implementation, this would:\n        // 1. Read nodes from the knowledge graph database\n        // 2. Generate embeddings for each node\n        // 3. Insert vectors in batches\n\n        spinner.text = 'Scanning knowledge graph...';\n\n        // Simulate rebuild process\n        const kgPath = join(projectRoot, '.kg', 'knowledge.db');\n        if (!existsSync(kgPath)) {\n          spinner.fail('Knowledge graph not found');\n          console.log(chalk.gray('  Run ') + chalk.cyan('kg graph') + chalk.gray(' first'));\n          return;\n        }\n\n        // Mock rebuild with progress\n        spinner.text = 'Generating embeddings...';\n\n        // For demonstration, we show what would happen\n        spinner.succeed('Vector index rebuild complete');\n\n        console.log();\n        console.log(chalk.white('  Rebuild Summary'));\n        console.log(chalk.gray(`    Vectors indexed: 0 (mock - no embedding model configured)`));\n        console.log(chalk.gray(`    Batch size:      ${batchSize}`));\n        console.log(chalk.gray(`    Project root:    ${projectRoot}`));\n\n        console.log();\n        console.log(chalk.yellow('  Note: Full vector indexing requires an embedding model.'));\n        console.log(chalk.gray('  Configure OPENAI_API_KEY or use local embeddings.'));\n        console.log();\n\n      } catch (error) {\n        spinner.fail('Rebuild failed');\n        console.error(chalk.red(String(error)));\n        process.exit(1);\n      }\n    });\n\n  // Trajectory subcommand group\n  const trajectory = vector\n    .command('trajectory')\n    .alias('traj')\n    .description('Agent trajectory tracking operations');\n\n  // trajectory list\n  trajectory\n    .command('list')\n    .description('List recorded agent trajectories')\n    .option('-p, --path <path>', 'Project root path', '.')\n    .option('-a, --agent <id>', 'Filter by agent ID')\n    .option('-w, --workflow <id>', 'Filter by workflow ID')\n    .option('-l, --limit <n>', 'Maximum number of trajectories', '20')\n    .option('--success', 'Show only successful trajectories')\n    .option('--failed', 'Show only failed trajectories')\n    .option('--json', 'Output as JSON')\n    .action(async (options) => {\n      try {\n        const limit = parseInt(options.limit, 10) || 20;\n\n        // Create trajectory tracker\n        const tracker = createTrajectoryTracker({\n          maxTrajectories: 1000,\n          enableAutoLearning: true,\n        });\n\n        const stats = tracker.getStats();\n\n        if (options.json) {\n          const exported = tracker.export();\n          let trajectories = exported.trajectories;\n\n          if (options.agent) {\n            trajectories = trajectories.filter((t) => t.agentId === options.agent);\n          }\n          if (options.workflow) {\n            trajectories = trajectories.filter((t) => t.workflowId === options.workflow);\n          }\n          if (options.success) {\n            trajectories = trajectories.filter((t) => t.success);\n          }\n          if (options.failed) {\n            trajectories = trajectories.filter((t) => !t.success);\n          }\n\n          console.log(JSON.stringify(trajectories.slice(0, limit), null, 2));\n          return;\n        }\n\n        console.log(chalk.cyan.bold('\\n  Agent Trajectories\\n'));\n\n        // Overview stats\n        console.log(chalk.white('  Overview'));\n        console.log(chalk.gray(`    Active:     ${stats.activeTrajectories}`));\n        console.log(chalk.gray(`    Completed:  ${stats.completedTrajectories}`));\n        console.log(chalk.gray(`    Success:    ${(stats.successRate * 100).toFixed(1)}%`));\n        console.log(chalk.gray(`    Avg Duration: ${formatDuration(stats.avgDuration)}`));\n        console.log(chalk.gray(`    Patterns:   ${stats.detectedPatterns}`));\n\n        // Get trajectories\n        const exported = tracker.export();\n        let trajectories = exported.trajectories;\n\n        if (options.agent) {\n          trajectories = trajectories.filter((t) => t.agentId === options.agent);\n        }\n        if (options.workflow) {\n          trajectories = trajectories.filter((t) => t.workflowId === options.workflow);\n        }\n        if (options.success) {\n          trajectories = trajectories.filter((t) => t.success);\n        }\n        if (options.failed) {\n          trajectories = trajectories.filter((t) => !t.success);\n        }\n\n        trajectories = trajectories.slice(-limit).reverse();\n\n        if (trajectories.length === 0) {\n          console.log();\n          console.log(chalk.gray('  No trajectories found'));\n          console.log(chalk.gray('  Trajectories are recorded during agent operations.'));\n          console.log();\n          return;\n        }\n\n        console.log();\n        console.log(chalk.white(`  Recent Trajectories (${trajectories.length})`));\n\n        const headers = ['ID', 'Agent', 'Steps', 'Duration', 'Status'];\n        const rows = trajectories.map((t) => [\n          t.id.substring(0, 16) + '...',\n          t.agentId.substring(0, 12) + (t.agentId.length > 12 ? '...' : ''),\n          String(t.steps.length),\n          formatDuration(t.totalDuration),\n          t.success ? chalk.green('OK') : chalk.red('FAIL'),\n        ]);\n\n        printTable(headers, rows);\n        console.log();\n\n      } catch (error) {\n        console.error(chalk.red('Failed to list trajectories:'), String(error));\n        process.exit(1);\n      }\n    });\n\n  // trajectory show\n  trajectory\n    .command('show <id>')\n    .description('Show detailed trajectory information')\n    .option('--json', 'Output as JSON')\n    .action(async (id, options) => {\n      try {\n        // Create trajectory tracker\n        const tracker = createTrajectoryTracker({\n          maxTrajectories: 1000,\n          enableAutoLearning: true,\n        });\n\n        const trajectory = tracker.getTrajectory(id);\n\n        if (!trajectory) {\n          console.log(chalk.yellow(`\\n  Trajectory not found: ${id}\\n`));\n          console.log(chalk.gray('  Use \"kg vector trajectory list\" to see available trajectories.'));\n          console.log();\n          return;\n        }\n\n        if (options.json) {\n          console.log(JSON.stringify(trajectory, null, 2));\n          return;\n        }\n\n        console.log(chalk.cyan.bold('\\n  Trajectory Details\\n'));\n\n        // Basic info\n        console.log(chalk.white('  Information'));\n        console.log(chalk.gray(`    ID:         ${trajectory.id}`));\n        console.log(chalk.gray(`    Agent:      ${trajectory.agentId}`));\n        if (trajectory.workflowId) {\n          console.log(chalk.gray(`    Workflow:   ${trajectory.workflowId}`));\n        }\n        console.log(chalk.gray(`    Started:    ${trajectory.startedAt.toISOString()}`));\n        if (trajectory.completedAt) {\n          console.log(chalk.gray(`    Completed:  ${trajectory.completedAt.toISOString()}`));\n        }\n        console.log(chalk.gray(`    Duration:   ${formatDuration(trajectory.totalDuration)}`));\n        console.log(\n          chalk.gray('    Status:     ') +\n            (trajectory.success ? chalk.green('SUCCESS') : chalk.red('FAILED'))\n        );\n\n        // Steps\n        if (trajectory.steps.length > 0) {\n          console.log();\n          console.log(chalk.white(`  Steps (${trajectory.steps.length})`));\n\n          const stepHeaders = ['#', 'Action', 'Outcome', 'Duration'];\n          const stepRows = trajectory.steps.map((s, i) => [\n            String(i + 1),\n            s.action.substring(0, 30) + (s.action.length > 30 ? '...' : ''),\n            s.outcome === 'success'\n              ? chalk.green(s.outcome)\n              : s.outcome === 'failure'\n              ? chalk.red(s.outcome)\n              : chalk.yellow(s.outcome),\n            formatDuration(s.duration),\n          ]);\n\n          printTable(stepHeaders, stepRows);\n        }\n\n        // Metadata\n        if (trajectory.metadata && Object.keys(trajectory.metadata).length > 0) {\n          console.log();\n          console.log(chalk.white('  Metadata'));\n          for (const [key, value] of Object.entries(trajectory.metadata)) {\n            const displayValue = typeof value === 'object' ? JSON.stringify(value) : String(value);\n            console.log(chalk.gray(`    ${key}: ${displayValue.substring(0, 60)}`));\n          }\n        }\n\n        console.log();\n      } catch (error) {\n        console.error(chalk.red('Failed to show trajectory:'), String(error));\n        process.exit(1);\n      }\n    });\n\n  // trajectory patterns\n  trajectory\n    .command('patterns')\n    .description('Show detected action patterns')\n    .option('--min-confidence <n>', 'Minimum confidence threshold (0-1)', '0.5')\n    .option('--type <type>', 'Filter by pattern type (success, failure, optimization)')\n    .option('--json', 'Output as JSON')\n    .action(async (options) => {\n      try {\n        const minConfidence = parseFloat(options.minConfidence) || 0.5;\n\n        // Create trajectory tracker\n        const tracker = createTrajectoryTracker({\n          maxTrajectories: 1000,\n          enableAutoLearning: true,\n        });\n\n        const patterns = tracker.getPatterns({\n          minConfidence,\n          type: options.type as 'success' | 'failure' | 'optimization' | undefined,\n        });\n\n        if (options.json) {\n          console.log(JSON.stringify(patterns, null, 2));\n          return;\n        }\n\n        console.log(chalk.cyan.bold('\\n  Detected Patterns\\n'));\n\n        if (patterns.length === 0) {\n          console.log(chalk.gray('  No patterns detected yet.'));\n          console.log(chalk.gray('  Patterns are learned from successful agent trajectories.'));\n          console.log();\n          return;\n        }\n\n        const headers = ['ID', 'Type', 'Frequency', 'Success', 'Confidence'];\n        const rows = patterns.map((p) => [\n          p.id.substring(0, 30) + (p.id.length > 30 ? '...' : ''),\n          p.type,\n          String(p.frequency),\n          `${(p.successRate * 100).toFixed(0)}%`,\n          `${(p.confidence * 100).toFixed(0)}%`,\n        ]);\n\n        printTable(headers, rows);\n\n        // Show top pattern details\n        if (patterns.length > 0) {\n          const top = patterns[0];\n          console.log();\n          console.log(chalk.white('  Top Pattern Details'));\n          console.log(chalk.gray(`    ID: ${top.id}`));\n          console.log(chalk.gray(`    Actions: ${top.actions.join(' -> ')}`));\n          console.log(chalk.gray(`    Avg Duration: ${formatDuration(top.avgDuration)}`));\n        }\n\n        console.log();\n      } catch (error) {\n        console.error(chalk.red('Failed to show patterns:'), String(error));\n        process.exit(1);\n      }\n    });\n\n  // trajectory clear\n  trajectory\n    .command('clear')\n    .description('Clear all trajectory data')\n    .option('--confirm', 'Confirm clearing without prompt')\n    .action(async (options) => {\n      try {\n        if (!options.confirm) {\n          console.log(chalk.yellow('\\n  Warning: This will delete all trajectory data.\\n'));\n          console.log(chalk.gray('  Use --confirm to proceed.'));\n          console.log();\n          return;\n        }\n\n        const tracker = createTrajectoryTracker();\n        tracker.clear();\n\n        console.log(chalk.green('\\n  Trajectory data cleared.\\n'));\n      } catch (error) {\n        console.error(chalk.red('Failed to clear trajectories:'), String(error));\n        process.exit(1);\n      }\n    });\n\n  return vector;\n}\n\n/**\n * Create a mock embedding from text\n *\n * This is a placeholder that creates deterministic pseudo-embeddings\n * based on the text content. In production, this would use an actual\n * embedding model (OpenAI, Cohere, local models, etc.)\n *\n * @param text - Text to embed\n * @param dimensions - Number of dimensions\n * @returns Mock embedding vector\n */\nfunction createMockEmbedding(text: string, dimensions: number): number[] {\n  const embedding: number[] = [];\n  const normalized = text.toLowerCase().trim();\n\n  // Simple hash-based pseudo-embedding\n  for (let i = 0; i < dimensions; i++) {\n    let value = 0;\n    for (let j = 0; j < normalized.length; j++) {\n      const charCode = normalized.charCodeAt(j);\n      value += Math.sin(charCode * (i + 1) * 0.1) * Math.cos(j * 0.3);\n    }\n    // Normalize to [-1, 1] range\n    embedding.push(Math.tanh(value / Math.max(1, normalized.length)));\n  }\n\n  // L2 normalize\n  const norm = Math.sqrt(embedding.reduce((sum, v) => sum + v * v, 0));\n  return embedding.map((v) => v / (norm || 1));\n}\n"],"names":["exported","trajectories","trajectory"],"mappings":";;;;;;;;;;;AA2BA,SAAS,YAAY,OAAuB;AAC1C,MAAI,QAAQ,KAAM,QAAO,GAAG,KAAK;AACjC,MAAI,QAAQ,OAAO,KAAM,QAAO,IAAI,QAAQ,MAAM,QAAQ,CAAC,CAAC;AAC5D,MAAI,QAAQ,OAAO,OAAO,KAAM,QAAO,IAAI,SAAS,OAAO,OAAO,QAAQ,CAAC,CAAC;AAC5E,SAAO,IAAI,SAAS,OAAO,OAAO,OAAO,QAAQ,CAAC,CAAC;AACrD;AAKA,SAAS,eAAe,IAAoB;AAC1C,MAAI,KAAK,IAAM,QAAO,GAAG,EAAE;AAC3B,MAAI,KAAK,IAAO,QAAO,IAAI,KAAK,KAAM,QAAQ,CAAC,CAAC;AAChD,MAAI,KAAK,KAAS,QAAO,IAAI,KAAK,KAAO,QAAQ,CAAC,CAAC;AACnD,SAAO,IAAI,KAAK,MAAS,QAAQ,CAAC,CAAC;AACrC;AAKA,SAAS,UAAU,OAAiB,QAA0B;AAC5D,SAAO,MAAM,IAAI,CAAC,MAAM,MAAM,KAAK,OAAO,OAAO,CAAC,CAAC,CAAC,EAAE,KAAK,IAAI;AACjE;AAKA,SAAS,WACP,SACA,MACA,UAAiE,CAAA,GAC3D;AACN,QAAM,SAAS,KAAK,OAAO,QAAQ,UAAU,CAAC;AAC9C,QAAM,cAAc,QAAQ,eAAe,MAAM;AAGjD,QAAM,SAAS,QAAQ,IAAI,CAAC,GAAG,MAAM;AACnC,UAAM,cAAc,KAAK,IAAI,GAAG,KAAK,IAAI,CAAC,OAAO,EAAE,CAAC,KAAK,IAAI,MAAM,CAAC;AACpE,WAAO,KAAK,IAAI,EAAE,QAAQ,WAAW;AAAA,EACvC,CAAC;AAGD,UAAQ,IAAI,SAAS,YAAY,UAAU,SAAS,MAAM,CAAC,CAAC;AAC5D,UAAQ,IAAI,SAAS,MAAM,KAAK,IAAI,OAAO,OAAO,OAAO,CAAC,GAAG,MAAM,IAAI,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;AAGlF,aAAW,OAAO,MAAM;AACtB,YAAQ,IAAI,SAAS,MAAM,KAAK,UAAU,KAAK,MAAM,CAAC,CAAC;AAAA,EACzD;AACF;AAKO,SAAS,sBAA+B;AAC7C,QAAM,SAAS,IAAI,QAAQ,QAAQ,EAChC,MAAM,KAAK,EACX,YAAY,+DAA+D;AAG9E,SACG,QAAQ,gBAAgB,EACxB,YAAY,yCAAyC,EACrD,OAAO,qBAAqB,qBAAqB,GAAG,EACpD,OAAO,mBAAmB,+BAA+B,IAAI,EAC7D,OAAO,qBAAqB,qBAAqB,EACjD,OAAO,YAAY,gDAAgD,EACnE,OAAO,uBAAuB,kCAAkC,GAAG,EACnE,OAAO,UAAU,gBAAgB,EACjC,OAAO,OAAO,OAAO,YAAY;AAChC,UAAM,UAAU,IAAI,sBAAsB,EAAE,MAAA;AAE5C,QAAI;AACF,YAAM,cAAc,oBAAoB,QAAQ,IAAI;AACpD,YAAM,OAAO,SAAS,QAAQ,MAAM,EAAE,KAAK;AAC3C,YAAM,WAAW,WAAW,QAAQ,QAAQ,KAAK;AAGjD,YAAM,QAAQ,kBAAA;AACd,YAAM,MAAM,WAAA;AAGZ,YAAM,QAAQ,MAAM,SAAA;AACpB,UAAI,MAAM,iBAAiB,GAAG;AAC5B,gBAAQ,KAAK,uBAAuB;AACpC,gBAAQ,IAAI,MAAM,KAAK,qCAAqC,CAAC;AAC7D,gBAAQ,IAAI,MAAM,KAAK,QAAQ,IAAI,MAAM,KAAK,mBAAmB,IAAI,MAAM,KAAK,oBAAoB,CAAC;AACrG;AAAA,MACF;AAEA,cAAQ,OAAO;AAIf,YAAM,iBAAiB,oBAAoB,OAAO,MAAM,UAAU;AAElE,cAAQ,OAAO,aAAa,MAAM,YAAY;AAE9C,UAAI;AAEJ,UAAI,QAAQ,QAAQ;AAElB,cAAM,gBAAgB,MAAM,MAAM,aAAa;AAAA,UAC7C,WAAW;AAAA,UACX,OAAO;AAAA,UACP;AAAA,UACA,SAAS,QAAQ,OAAO,EAAE,MAAM,QAAQ,SAAS;AAAA,QAAA,CAClD;AACD,kBAAU;AAAA,MACZ,OAAO;AAEL,kBAAU,MAAM,MAAM,OAAO;AAAA,UAC3B,QAAQ;AAAA,UACR,GAAG;AAAA,UACH;AAAA,UACA,QAAQ,QAAQ,OAAO,EAAE,MAAM,QAAQ,SAAS;AAAA,QAAA,CACjD;AAAA,MACH;AAEA,cAAQ,KAAA;AAER,UAAI,QAAQ,MAAM;AAChB,gBAAQ,IAAI,KAAK,UAAU,SAAS,MAAM,CAAC,CAAC;AAC5C;AAAA,MACF;AAEA,cAAQ,IAAI,MAAM,KAAK;AAAA,wBAA2B,KAAK;AAAA,CAAK,CAAC;AAE7D,UAAI,QAAQ,WAAW,GAAG;AACxB,gBAAQ,IAAI,MAAM,KAAK,oBAAoB,CAAC;AAC5C;AAAA,MACF;AAEA,cAAQ,IAAI,MAAM,KAAK,WAAW,QAAQ,MAAM,UAAU,QAAQ,WAAW,IAAI,KAAK,GAAG;AAAA,CAAI,CAAC;AAG9F,YAAM,UAAU,CAAC,KAAK,MAAM,SAAS,QAAQ,UAAU;AACvD,YAAM,OAAO,QAAQ,IAAI,CAAC,GAAG,MAAM;AAAA,QACjC,OAAO,IAAI,CAAC;AAAA,QACZ,EAAE,GAAG,UAAU,GAAG,EAAE,KAAK,EAAE,GAAG,SAAS,KAAK,QAAQ;AAAA,QACpD,EAAE,MAAM,QAAQ,CAAC;AAAA,QAChB,EAAE,UAAU,QAAmB;AAAA,QAChC,OAAO,KAAK,EAAE,YAAY,CAAA,CAAE,EAAE,SAAS,IACnC,OAAO,KAAK,EAAE,QAAQ,EAAE,MAAM,GAAG,CAAC,EAAE,KAAK,IAAI,IAC7C;AAAA,MAAA,CACL;AAED,iBAAW,SAAS,IAAI;AAGxB,cAAQ,IAAI,MAAM,MAAM,2BAA2B,CAAC;AACpD,YAAM,MAAM,QAAQ,CAAC;AACrB,cAAQ,IAAI,MAAM,KAAK,WAAW,IAAI,EAAE,EAAE,CAAC;AAC3C,cAAQ,IAAI,MAAM,KAAK,cAAc,IAAI,MAAM,QAAQ,CAAC,CAAC,EAAE,CAAC;AAC5D,UAAI,IAAI,aAAa,QAAW;AAC9B,gBAAQ,IAAI,MAAM,KAAK,iBAAiB,IAAI,SAAS,QAAQ,CAAC,CAAC,EAAE,CAAC;AAAA,MACpE;AACA,UAAI,OAAO,KAAK,IAAI,YAAY,EAAE,EAAE,SAAS,GAAG;AAC9C,gBAAQ,IAAI,MAAM,KAAK,eAAe,CAAC;AACvC,mBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,IAAI,QAAQ,GAAG;AACvD,gBAAM,eAAe,OAAO,UAAU,WAAW,KAAK,UAAU,KAAK,IAAI,OAAO,KAAK;AACrF,kBAAQ,IAAI,MAAM,KAAK,SAAS,GAAG,KAAK,aAAa,UAAU,GAAG,EAAE,CAAC,EAAE,CAAC;AAAA,QAC1E;AAAA,MACF;AAEA,cAAQ,IAAA;AAAA,IACV,SAAS,OAAO;AACd,cAAQ,KAAK,eAAe;AAC5B,cAAQ,MAAM,MAAM,IAAI,OAAO,KAAK,CAAC,CAAC;AACtC,cAAQ,KAAK,CAAC;AAAA,IAChB;AAAA,EACF,CAAC;AAGH,SACG,QAAQ,OAAO,EACf,YAAY,iCAAiC,EAC7C,OAAO,qBAAqB,qBAAqB,GAAG,EACpD,OAAO,UAAU,gBAAgB,EACjC,OAAO,OAAO,YAAY;AACzB,QAAI;AACF,YAAM,cAAc,oBAAoB,QAAQ,IAAI;AAGpD,YAAM,QAAQ,kBAAA;AACd,YAAM,MAAM,WAAA;AAEZ,YAAM,QAAQ,MAAM,SAAA;AAEpB,UAAI,QAAQ,MAAM;AAChB,gBAAQ,IAAI,KAAK,UAAU,OAAO,MAAM,CAAC,CAAC;AAC1C;AAAA,MACF;AAEA,cAAQ,IAAI,MAAM,KAAK,KAAK,+BAA+B,CAAC;AAG5D,cAAQ,IAAI,MAAM,MAAM,YAAY,CAAC;AACrC,cAAQ,IAAI,MAAM,KAAK,wBAAwB,MAAM,aAAa,gBAAgB,EAAE,CAAC;AACrF,cAAQ,IAAI,MAAM,KAAK,wBAAwB,MAAM,UAAU,EAAE,CAAC;AAClE,cAAQ,IAAI,MAAM,KAAK,wBAAwB,MAAM,UAAU,aAAa,EAAE,CAAC;AAC/E,cAAQ,IAAI,MAAM,KAAK,wBAAwB,YAAY,MAAM,WAAW,CAAC,EAAE,CAAC;AAChF,cAAQ,IAAI,MAAM,KAAK,wBAAwB,MAAM,YAAY,aAAa,EAAE,CAAC;AAGjF,UAAI,MAAM,YAAY;AACpB,gBAAQ,IAAA;AACR,gBAAQ,IAAI,MAAM,MAAM,uBAAuB,CAAC;AAChD,YAAI,MAAM,WAAW,WAAW,QAAW;AACzC,kBAAQ,IAAI,MAAM,KAAK,wBAAwB,MAAM,WAAW,MAAM,EAAE,CAAC;AAAA,QAC3E;AACA,YAAI,MAAM,WAAW,YAAY;AAC/B,kBAAQ,IAAI,MAAM,KAAK,wBAAwB,MAAM,WAAW,WAAW,UAAU,GAAG,EAAE,CAAC,KAAK,CAAC;AAAA,QACnG;AACA,YAAI,MAAM,WAAW,mBAAmB,QAAW;AACjD,kBAAQ,IAAI,MAAM,KAAK,wBAAwB,MAAM,WAAW,eAAe,QAAQ,CAAC,CAAC,EAAE,CAAC;AAAA,QAC9F;AAAA,MACF;AAGA,UAAI,MAAM,cAAc,OAAO,KAAK,MAAM,UAAU,EAAE,SAAS,GAAG;AAChE,gBAAQ,IAAA;AACR,gBAAQ,IAAI,MAAM,MAAM,cAAc,CAAC;AACvC,mBAAW,CAAC,IAAI,KAAK,KAAK,OAAO,QAAQ,MAAM,UAAU,GAAG;AAC1D,gBAAM,MAAM,IAAI,OAAO,KAAK,IAAI,OAAO,EAAE,CAAC;AAC1C,kBAAQ,IAAI,MAAM,KAAK,OAAO,GAAG,OAAO,EAAE,CAAC,IAAI,OAAO,KAAK,EAAE,SAAS,CAAC,CAAC,IAAI,MAAM,KAAK,GAAG,CAAC,EAAE,CAAC;AAAA,QAChG;AAAA,MACF;AAGA,cAAQ,IAAA;AACR,cAAQ,IAAI,MAAM,MAAM,eAAe,CAAC;AACxC,UAAI,MAAM,iBAAiB,GAAG;AAC5B,gBAAQ,IAAI,MAAM,OAAO,+BAA+B,CAAC;AACzD,gBAAQ,IAAI,MAAM,KAAK,uDAAuD,CAAC;AAAA,MACjF,WAAW,MAAM,eAAe,KAAK;AACnC,gBAAQ,IAAI,MAAM,MAAM,oDAAoD,CAAC;AAAA,MAC/E,WAAW,MAAM,eAAe,KAAO;AACrC,gBAAQ,IAAI,MAAM,MAAM,sCAAsC,CAAC;AAAA,MACjE,OAAO;AACL,gBAAQ,IAAI,MAAM,OAAO,6CAA6C,CAAC;AAAA,MACzE;AAEA,cAAQ,IAAA;AAAA,IACV,SAAS,OAAO;AACd,cAAQ,MAAM,MAAM,IAAI,sBAAsB,GAAG,OAAO,KAAK,CAAC;AAC9D,cAAQ,KAAK,CAAC;AAAA,IAChB;AAAA,EACF,CAAC;AAGH,SACG,QAAQ,SAAS,EACjB,YAAY,2CAA2C,EACvD,OAAO,qBAAqB,qBAAqB,GAAG,EACpD,OAAO,WAAW,oCAAoC,EACtD,OAAO,uBAAuB,2BAA2B,KAAK,EAC9D,OAAO,iBAAiB,gBAAgB,EACxC,OAAO,OAAO,YAAY;AACzB,UAAM,UAAU,IAAI,4BAA4B,EAAE,MAAA;AAElD,QAAI;AACF,YAAM,cAAc,oBAAoB,QAAQ,IAAI;AACpD,YAAM,YAAY,SAAS,QAAQ,WAAW,EAAE,KAAK;AAGrD,YAAM,QAAQ,kBAAA;AACd,YAAM,MAAM,WAAA;AAEZ,YAAM,gBAAgB,MAAM,SAAA;AAE5B,UAAI,cAAc,eAAe,KAAK,CAAC,QAAQ,OAAO;AACpD,gBAAQ,KAAK,0BAA0B,cAAc,YAAY,UAAU;AAC3E,gBAAQ,IAAI,MAAM,KAAK,iCAAiC,CAAC;AACzD;AAAA,MACF;AAEA,UAAI,QAAQ,SAAS,cAAc,eAAe,GAAG;AACnD,gBAAQ,OAAO;AACf,cAAM,MAAM,MAAA;AAAA,MACd;AAOA,cAAQ,OAAO;AAGf,YAAM,SAAS,KAAK,aAAa,OAAO,cAAc;AACtD,UAAI,CAAC,WAAW,MAAM,GAAG;AACvB,gBAAQ,KAAK,2BAA2B;AACxC,gBAAQ,IAAI,MAAM,KAAK,QAAQ,IAAI,MAAM,KAAK,UAAU,IAAI,MAAM,KAAK,QAAQ,CAAC;AAChF;AAAA,MACF;AAGA,cAAQ,OAAO;AAGf,cAAQ,QAAQ,+BAA+B;AAE/C,cAAQ,IAAA;AACR,cAAQ,IAAI,MAAM,MAAM,mBAAmB,CAAC;AAC5C,cAAQ,IAAI,MAAM,KAAK,+DAA+D,CAAC;AACvF,cAAQ,IAAI,MAAM,KAAK,wBAAwB,SAAS,EAAE,CAAC;AAC3D,cAAQ,IAAI,MAAM,KAAK,wBAAwB,WAAW,EAAE,CAAC;AAE7D,cAAQ,IAAA;AACR,cAAQ,IAAI,MAAM,OAAO,2DAA2D,CAAC;AACrF,cAAQ,IAAI,MAAM,KAAK,qDAAqD,CAAC;AAC7E,cAAQ,IAAA;AAAA,IAEV,SAAS,OAAO;AACd,cAAQ,KAAK,gBAAgB;AAC7B,cAAQ,MAAM,MAAM,IAAI,OAAO,KAAK,CAAC,CAAC;AACtC,cAAQ,KAAK,CAAC;AAAA,IAChB;AAAA,EACF,CAAC;AAGH,QAAM,aAAa,OAChB,QAAQ,YAAY,EACpB,MAAM,MAAM,EACZ,YAAY,sCAAsC;AAGrD,aACG,QAAQ,MAAM,EACd,YAAY,kCAAkC,EAC9C,OAAO,qBAAqB,qBAAqB,GAAG,EACpD,OAAO,oBAAoB,oBAAoB,EAC/C,OAAO,uBAAuB,uBAAuB,EACrD,OAAO,mBAAmB,kCAAkC,IAAI,EAChE,OAAO,aAAa,mCAAmC,EACvD,OAAO,YAAY,+BAA+B,EAClD,OAAO,UAAU,gBAAgB,EACjC,OAAO,OAAO,YAAY;AACzB,QAAI;AACF,YAAM,QAAQ,SAAS,QAAQ,OAAO,EAAE,KAAK;AAG7C,YAAM,UAAU,wBAAwB;AAAA,QACtC,iBAAiB;AAAA,QACjB,oBAAoB;AAAA,MAAA,CACrB;AAED,YAAM,QAAQ,QAAQ,SAAA;AAEtB,UAAI,QAAQ,MAAM;AAChB,cAAMA,YAAW,QAAQ,OAAA;AACzB,YAAIC,gBAAeD,UAAS;AAE5B,YAAI,QAAQ,OAAO;AACjBC,0BAAeA,cAAa,OAAO,CAAC,MAAM,EAAE,YAAY,QAAQ,KAAK;AAAA,QACvE;AACA,YAAI,QAAQ,UAAU;AACpBA,0BAAeA,cAAa,OAAO,CAAC,MAAM,EAAE,eAAe,QAAQ,QAAQ;AAAA,QAC7E;AACA,YAAI,QAAQ,SAAS;AACnBA,0BAAeA,cAAa,OAAO,CAAC,MAAM,EAAE,OAAO;AAAA,QACrD;AACA,YAAI,QAAQ,QAAQ;AAClBA,0BAAeA,cAAa,OAAO,CAAC,MAAM,CAAC,EAAE,OAAO;AAAA,QACtD;AAEA,gBAAQ,IAAI,KAAK,UAAUA,cAAa,MAAM,GAAG,KAAK,GAAG,MAAM,CAAC,CAAC;AACjE;AAAA,MACF;AAEA,cAAQ,IAAI,MAAM,KAAK,KAAK,0BAA0B,CAAC;AAGvD,cAAQ,IAAI,MAAM,MAAM,YAAY,CAAC;AACrC,cAAQ,IAAI,MAAM,KAAK,mBAAmB,MAAM,kBAAkB,EAAE,CAAC;AACrE,cAAQ,IAAI,MAAM,KAAK,mBAAmB,MAAM,qBAAqB,EAAE,CAAC;AACxE,cAAQ,IAAI,MAAM,KAAK,oBAAoB,MAAM,cAAc,KAAK,QAAQ,CAAC,CAAC,GAAG,CAAC;AAClF,cAAQ,IAAI,MAAM,KAAK,qBAAqB,eAAe,MAAM,WAAW,CAAC,EAAE,CAAC;AAChF,cAAQ,IAAI,MAAM,KAAK,mBAAmB,MAAM,gBAAgB,EAAE,CAAC;AAGnE,YAAM,WAAW,QAAQ,OAAA;AACzB,UAAI,eAAe,SAAS;AAE5B,UAAI,QAAQ,OAAO;AACjB,uBAAe,aAAa,OAAO,CAAC,MAAM,EAAE,YAAY,QAAQ,KAAK;AAAA,MACvE;AACA,UAAI,QAAQ,UAAU;AACpB,uBAAe,aAAa,OAAO,CAAC,MAAM,EAAE,eAAe,QAAQ,QAAQ;AAAA,MAC7E;AACA,UAAI,QAAQ,SAAS;AACnB,uBAAe,aAAa,OAAO,CAAC,MAAM,EAAE,OAAO;AAAA,MACrD;AACA,UAAI,QAAQ,QAAQ;AAClB,uBAAe,aAAa,OAAO,CAAC,MAAM,CAAC,EAAE,OAAO;AAAA,MACtD;AAEA,qBAAe,aAAa,MAAM,CAAC,KAAK,EAAE,QAAA;AAE1C,UAAI,aAAa,WAAW,GAAG;AAC7B,gBAAQ,IAAA;AACR,gBAAQ,IAAI,MAAM,KAAK,yBAAyB,CAAC;AACjD,gBAAQ,IAAI,MAAM,KAAK,sDAAsD,CAAC;AAC9E,gBAAQ,IAAA;AACR;AAAA,MACF;AAEA,cAAQ,IAAA;AACR,cAAQ,IAAI,MAAM,MAAM,0BAA0B,aAAa,MAAM,GAAG,CAAC;AAEzE,YAAM,UAAU,CAAC,MAAM,SAAS,SAAS,YAAY,QAAQ;AAC7D,YAAM,OAAO,aAAa,IAAI,CAAC,MAAM;AAAA,QACnC,EAAE,GAAG,UAAU,GAAG,EAAE,IAAI;AAAA,QACxB,EAAE,QAAQ,UAAU,GAAG,EAAE,KAAK,EAAE,QAAQ,SAAS,KAAK,QAAQ;AAAA,QAC9D,OAAO,EAAE,MAAM,MAAM;AAAA,QACrB,eAAe,EAAE,aAAa;AAAA,QAC9B,EAAE,UAAU,MAAM,MAAM,IAAI,IAAI,MAAM,IAAI,MAAM;AAAA,MAAA,CACjD;AAED,iBAAW,SAAS,IAAI;AACxB,cAAQ,IAAA;AAAA,IAEV,SAAS,OAAO;AACd,cAAQ,MAAM,MAAM,IAAI,8BAA8B,GAAG,OAAO,KAAK,CAAC;AACtE,cAAQ,KAAK,CAAC;AAAA,IAChB;AAAA,EACF,CAAC;AAGH,aACG,QAAQ,WAAW,EACnB,YAAY,sCAAsC,EAClD,OAAO,UAAU,gBAAgB,EACjC,OAAO,OAAO,IAAI,YAAY;AAC7B,QAAI;AAEF,YAAM,UAAU,wBAAwB;AAAA,QACtC,iBAAiB;AAAA,QACjB,oBAAoB;AAAA,MAAA,CACrB;AAED,YAAMC,cAAa,QAAQ,cAAc,EAAE;AAE3C,UAAI,CAACA,aAAY;AACf,gBAAQ,IAAI,MAAM,OAAO;AAAA,0BAA6B,EAAE;AAAA,CAAI,CAAC;AAC7D,gBAAQ,IAAI,MAAM,KAAK,kEAAkE,CAAC;AAC1F,gBAAQ,IAAA;AACR;AAAA,MACF;AAEA,UAAI,QAAQ,MAAM;AAChB,gBAAQ,IAAI,KAAK,UAAUA,aAAY,MAAM,CAAC,CAAC;AAC/C;AAAA,MACF;AAEA,cAAQ,IAAI,MAAM,KAAK,KAAK,0BAA0B,CAAC;AAGvD,cAAQ,IAAI,MAAM,MAAM,eAAe,CAAC;AACxC,cAAQ,IAAI,MAAM,KAAK,mBAAmBA,YAAW,EAAE,EAAE,CAAC;AAC1D,cAAQ,IAAI,MAAM,KAAK,mBAAmBA,YAAW,OAAO,EAAE,CAAC;AAC/D,UAAIA,YAAW,YAAY;AACzB,gBAAQ,IAAI,MAAM,KAAK,mBAAmBA,YAAW,UAAU,EAAE,CAAC;AAAA,MACpE;AACA,cAAQ,IAAI,MAAM,KAAK,mBAAmBA,YAAW,UAAU,aAAa,EAAE,CAAC;AAC/E,UAAIA,YAAW,aAAa;AAC1B,gBAAQ,IAAI,MAAM,KAAK,mBAAmBA,YAAW,YAAY,aAAa,EAAE,CAAC;AAAA,MACnF;AACA,cAAQ,IAAI,MAAM,KAAK,mBAAmB,eAAeA,YAAW,aAAa,CAAC,EAAE,CAAC;AACrF,cAAQ;AAAA,QACN,MAAM,KAAK,kBAAkB,KAC1BA,YAAW,UAAU,MAAM,MAAM,SAAS,IAAI,MAAM,IAAI,QAAQ;AAAA,MAAA;AAIrE,UAAIA,YAAW,MAAM,SAAS,GAAG;AAC/B,gBAAQ,IAAA;AACR,gBAAQ,IAAI,MAAM,MAAM,YAAYA,YAAW,MAAM,MAAM,GAAG,CAAC;AAE/D,cAAM,cAAc,CAAC,KAAK,UAAU,WAAW,UAAU;AACzD,cAAM,WAAWA,YAAW,MAAM,IAAI,CAAC,GAAG,MAAM;AAAA,UAC9C,OAAO,IAAI,CAAC;AAAA,UACZ,EAAE,OAAO,UAAU,GAAG,EAAE,KAAK,EAAE,OAAO,SAAS,KAAK,QAAQ;AAAA,UAC5D,EAAE,YAAY,YACV,MAAM,MAAM,EAAE,OAAO,IACrB,EAAE,YAAY,YACd,MAAM,IAAI,EAAE,OAAO,IACnB,MAAM,OAAO,EAAE,OAAO;AAAA,UAC1B,eAAe,EAAE,QAAQ;AAAA,QAAA,CAC1B;AAED,mBAAW,aAAa,QAAQ;AAAA,MAClC;AAGA,UAAIA,YAAW,YAAY,OAAO,KAAKA,YAAW,QAAQ,EAAE,SAAS,GAAG;AACtE,gBAAQ,IAAA;AACR,gBAAQ,IAAI,MAAM,MAAM,YAAY,CAAC;AACrC,mBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQA,YAAW,QAAQ,GAAG;AAC9D,gBAAM,eAAe,OAAO,UAAU,WAAW,KAAK,UAAU,KAAK,IAAI,OAAO,KAAK;AACrF,kBAAQ,IAAI,MAAM,KAAK,OAAO,GAAG,KAAK,aAAa,UAAU,GAAG,EAAE,CAAC,EAAE,CAAC;AAAA,QACxE;AAAA,MACF;AAEA,cAAQ,IAAA;AAAA,IACV,SAAS,OAAO;AACd,cAAQ,MAAM,MAAM,IAAI,4BAA4B,GAAG,OAAO,KAAK,CAAC;AACpE,cAAQ,KAAK,CAAC;AAAA,IAChB;AAAA,EACF,CAAC;AAGH,aACG,QAAQ,UAAU,EAClB,YAAY,+BAA+B,EAC3C,OAAO,wBAAwB,sCAAsC,KAAK,EAC1E,OAAO,iBAAiB,yDAAyD,EACjF,OAAO,UAAU,gBAAgB,EACjC,OAAO,OAAO,YAAY;AACzB,QAAI;AACF,YAAM,gBAAgB,WAAW,QAAQ,aAAa,KAAK;AAG3D,YAAM,UAAU,wBAAwB;AAAA,QACtC,iBAAiB;AAAA,QACjB,oBAAoB;AAAA,MAAA,CACrB;AAED,YAAM,WAAW,QAAQ,YAAY;AAAA,QACnC;AAAA,QACA,MAAM,QAAQ;AAAA,MAAA,CACf;AAED,UAAI,QAAQ,MAAM;AAChB,gBAAQ,IAAI,KAAK,UAAU,UAAU,MAAM,CAAC,CAAC;AAC7C;AAAA,MACF;AAEA,cAAQ,IAAI,MAAM,KAAK,KAAK,yBAAyB,CAAC;AAEtD,UAAI,SAAS,WAAW,GAAG;AACzB,gBAAQ,IAAI,MAAM,KAAK,6BAA6B,CAAC;AACrD,gBAAQ,IAAI,MAAM,KAAK,4DAA4D,CAAC;AACpF,gBAAQ,IAAA;AACR;AAAA,MACF;AAEA,YAAM,UAAU,CAAC,MAAM,QAAQ,aAAa,WAAW,YAAY;AACnE,YAAM,OAAO,SAAS,IAAI,CAAC,MAAM;AAAA,QAC/B,EAAE,GAAG,UAAU,GAAG,EAAE,KAAK,EAAE,GAAG,SAAS,KAAK,QAAQ;AAAA,QACpD,EAAE;AAAA,QACF,OAAO,EAAE,SAAS;AAAA,QAClB,IAAI,EAAE,cAAc,KAAK,QAAQ,CAAC,CAAC;AAAA,QACnC,IAAI,EAAE,aAAa,KAAK,QAAQ,CAAC,CAAC;AAAA,MAAA,CACnC;AAED,iBAAW,SAAS,IAAI;AAGxB,UAAI,SAAS,SAAS,GAAG;AACvB,cAAM,MAAM,SAAS,CAAC;AACtB,gBAAQ,IAAA;AACR,gBAAQ,IAAI,MAAM,MAAM,uBAAuB,CAAC;AAChD,gBAAQ,IAAI,MAAM,KAAK,WAAW,IAAI,EAAE,EAAE,CAAC;AAC3C,gBAAQ,IAAI,MAAM,KAAK,gBAAgB,IAAI,QAAQ,KAAK,MAAM,CAAC,EAAE,CAAC;AAClE,gBAAQ,IAAI,MAAM,KAAK,qBAAqB,eAAe,IAAI,WAAW,CAAC,EAAE,CAAC;AAAA,MAChF;AAEA,cAAQ,IAAA;AAAA,IACV,SAAS,OAAO;AACd,cAAQ,MAAM,MAAM,IAAI,0BAA0B,GAAG,OAAO,KAAK,CAAC;AAClE,cAAQ,KAAK,CAAC;AAAA,IAChB;AAAA,EACF,CAAC;AAGH,aACG,QAAQ,OAAO,EACf,YAAY,2BAA2B,EACvC,OAAO,aAAa,iCAAiC,EACrD,OAAO,OAAO,YAAY;AACzB,QAAI;AACF,UAAI,CAAC,QAAQ,SAAS;AACpB,gBAAQ,IAAI,MAAM,OAAO,sDAAsD,CAAC;AAChF,gBAAQ,IAAI,MAAM,KAAK,6BAA6B,CAAC;AACrD,gBAAQ,IAAA;AACR;AAAA,MACF;AAEA,YAAM,UAAU,wBAAA;AAChB,cAAQ,MAAA;AAER,cAAQ,IAAI,MAAM,MAAM,gCAAgC,CAAC;AAAA,IAC3D,SAAS,OAAO;AACd,cAAQ,MAAM,MAAM,IAAI,+BAA+B,GAAG,OAAO,KAAK,CAAC;AACvE,cAAQ,KAAK,CAAC;AAAA,IAChB;AAAA,EACF,CAAC;AAEH,SAAO;AACT;AAaA,SAAS,oBAAoB,MAAc,YAA8B;AACvE,QAAM,YAAsB,CAAA;AAC5B,QAAM,aAAa,KAAK,YAAA,EAAc,KAAA;AAGtC,WAAS,IAAI,GAAG,IAAI,YAAY,KAAK;AACnC,QAAI,QAAQ;AACZ,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,YAAM,WAAW,WAAW,WAAW,CAAC;AACxC,eAAS,KAAK,IAAI,YAAY,IAAI,KAAK,GAAG,IAAI,KAAK,IAAI,IAAI,GAAG;AAAA,IAChE;AAEA,cAAU,KAAK,KAAK,KAAK,QAAQ,KAAK,IAAI,GAAG,WAAW,MAAM,CAAC,CAAC;AAAA,EAClE;AAGA,QAAM,OAAO,KAAK,KAAK,UAAU,OAAO,CAAC,KAAK,MAAM,MAAM,IAAI,GAAG,CAAC,CAAC;AACnE,SAAO,UAAU,IAAI,CAAC,MAAM,KAAK,QAAQ,EAAE;AAC7C;"}