{"version":3,"file":"workflow.js","sources":["../../../src/cli/commands/workflow.ts"],"sourcesContent":["/**\n * Workflow Command\n *\n * Manage knowledge graph workflows for automated processing,\n * analysis, and synchronization tasks.\n */\n\nimport { Command } from 'commander';\nimport chalk from 'chalk';\nimport ora from 'ora';\nimport { randomUUID } from 'crypto';\n\n/**\n * Workflow types supported by the system\n */\ntype WorkflowType = 'analysis' | 'sync' | 'generation' | 'validation' | 'migration';\n\n/**\n * Workflow status\n */\ntype WorkflowStatus = 'pending' | 'running' | 'completed' | 'failed' | 'stopped';\n\n/**\n * Workflow entry structure\n */\ninterface Workflow {\n  id: string;\n  type: WorkflowType;\n  status: WorkflowStatus;\n  startedAt: string;\n  updatedAt: string;\n  completedAt?: string;\n  progress: number;\n  message?: string;\n  input?: Record<string, unknown>;\n  output?: Record<string, unknown>;\n  error?: string;\n}\n\n/**\n * In-memory workflow storage (would be replaced with persistent storage)\n */\nconst workflows: Map<string, Workflow> = new Map();\n\n/**\n * Valid workflow types\n */\nconst VALID_WORKFLOW_TYPES: WorkflowType[] = [\n  'analysis',\n  'sync',\n  'generation',\n  'validation',\n  'migration',\n];\n\n/**\n * Create workflow command with subcommands\n */\nexport function createWorkflowCommand(): Command {\n  const workflow = new Command('workflow')\n    .alias('wf')\n    .description('Manage knowledge graph workflows');\n\n  // Start workflow\n  workflow\n    .command('start <type>')\n    .description('Start a new workflow')\n    .addHelpText('after', `\nWorkflow Types:\n  analysis    - Analyze codebase and extract knowledge\n  sync        - Synchronize with external systems\n  generation  - Generate knowledge graph artifacts\n  validation  - Validate graph integrity and structure\n  migration   - Migrate data between formats\n\nExamples:\n  $ kg workflow start analysis\n  $ kg workflow start sync --input '{\"namespace\": \"myproject\"}'\n  $ kg workflow start generation --async\n    `)\n    .option('-i, --input <json>', 'Input data as JSON')\n    .option('-a, --async', 'Run workflow asynchronously')\n    .option('--dry-run', 'Preview workflow without executing')\n    .action(async (type: string, options) => {\n      const spinner = ora('Starting workflow...').start();\n\n      try {\n        // Validate workflow type\n        if (!VALID_WORKFLOW_TYPES.includes(type as WorkflowType)) {\n          spinner.fail(`Invalid workflow type: ${type}`);\n          console.log(\n            chalk.gray('\\n  Valid types: ') +\n              chalk.cyan(VALID_WORKFLOW_TYPES.join(', '))\n          );\n          process.exit(1);\n        }\n\n        // Parse input if provided\n        let input: Record<string, unknown> | undefined;\n        if (options.input) {\n          try {\n            input = JSON.parse(options.input);\n          } catch {\n            spinner.fail('Invalid JSON input');\n            console.log(chalk.gray('  Example: --input \\'{\"key\": \"value\"}\\''));\n            process.exit(1);\n          }\n        }\n\n        // Dry run mode\n        if (options.dryRun) {\n          spinner.info('Dry run mode - workflow will not execute');\n          console.log();\n          console.log(chalk.white('  Workflow Configuration:'));\n          console.log(chalk.gray(`    Type:  ${type}`));\n          console.log(chalk.gray(`    Input: ${input ? JSON.stringify(input, null, 2) : 'none'}`));\n          console.log(chalk.gray(`    Async: ${options.async ? 'yes' : 'no'}`));\n          return;\n        }\n\n        // Create workflow entry\n        const workflowId = randomUUID().slice(0, 8);\n        const now = new Date().toISOString();\n\n        const workflowEntry: Workflow = {\n          id: workflowId,\n          type: type as WorkflowType,\n          status: 'running',\n          startedAt: now,\n          updatedAt: now,\n          progress: 0,\n          input,\n        };\n\n        workflows.set(workflowId, workflowEntry);\n\n        spinner.text = `Running ${type} workflow...`;\n\n        // Simulate workflow execution\n        if (options.async) {\n          spinner.succeed(`Workflow started: ${chalk.cyan(workflowId)}`);\n          console.log(\n            chalk.gray(`\\n  Check status: `) +\n              chalk.cyan(`kg workflow status ${workflowId}`)\n          );\n\n          // Start async workflow simulation\n          simulateWorkflow(workflowId);\n        } else {\n          // Synchronous execution simulation\n          await simulateWorkflowSync(workflowId, spinner);\n\n          const completedWorkflow = workflows.get(workflowId);\n          if (completedWorkflow?.status === 'completed') {\n            spinner.succeed(`Workflow completed: ${chalk.cyan(workflowId)}`);\n            printWorkflowResult(completedWorkflow);\n          } else if (completedWorkflow?.status === 'failed') {\n            spinner.fail(`Workflow failed: ${chalk.cyan(workflowId)}`);\n            if (completedWorkflow.error) {\n              console.log(chalk.red(`\\n  Error: ${completedWorkflow.error}`));\n            }\n            process.exit(1);\n          }\n        }\n      } catch (error) {\n        spinner.fail('Failed to start workflow');\n        console.error(chalk.red(`  ${String(error)}`));\n        process.exit(1);\n      }\n    });\n\n  // Status command\n  workflow\n    .command('status [id]')\n    .description('Check workflow status')\n    .option('--json', 'Output as JSON')\n    .option('-w, --watch', 'Watch for status changes')\n    .action(async (id: string | undefined, options) => {\n      try {\n        if (id) {\n          // Get specific workflow\n          const wf = workflows.get(id);\n\n          if (!wf) {\n            console.log(chalk.yellow(`\\n  Workflow not found: ${id}`));\n            console.log(chalk.gray('  Run ') + chalk.cyan('kg workflow list') + chalk.gray(' to see active workflows'));\n            process.exit(1);\n          }\n\n          if (options.json) {\n            console.log(JSON.stringify(wf, null, 2));\n            return;\n          }\n\n          printWorkflowDetails(wf);\n\n          if (options.watch && wf.status === 'running') {\n            await watchWorkflow(id);\n          }\n        } else {\n          // Show all active workflows status\n          const activeWorkflows = Array.from(workflows.values()).filter(\n            (w) => w.status === 'running' || w.status === 'pending'\n          );\n\n          if (activeWorkflows.length === 0) {\n            console.log(chalk.gray('\\n  No active workflows'));\n            console.log(chalk.gray('  Run ') + chalk.cyan('kg workflow start <type>') + chalk.gray(' to start one'));\n            return;\n          }\n\n          if (options.json) {\n            console.log(JSON.stringify(activeWorkflows, null, 2));\n            return;\n          }\n\n          console.log(chalk.cyan.bold('\\n  Active Workflows\\n'));\n          activeWorkflows.forEach((wf) => {\n            printWorkflowSummary(wf);\n          });\n        }\n      } catch (error) {\n        console.error(chalk.red('Failed to get workflow status:'), String(error));\n        process.exit(1);\n      }\n    });\n\n  // List command\n  workflow\n    .command('list')\n    .description('List all workflows')\n    .option('-s, --status <status>', 'Filter by status (running, completed, failed, stopped)')\n    .option('-t, --type <type>', 'Filter by workflow type')\n    .option('-n, --limit <number>', 'Limit number of results', '10')\n    .option('--json', 'Output as JSON')\n    .action((options) => {\n      try {\n        let workflowList = Array.from(workflows.values());\n\n        // Apply filters\n        if (options.status) {\n          workflowList = workflowList.filter((w) => w.status === options.status);\n        }\n        if (options.type) {\n          workflowList = workflowList.filter((w) => w.type === options.type);\n        }\n\n        // Sort by start time (most recent first)\n        workflowList.sort(\n          (a, b) => new Date(b.startedAt).getTime() - new Date(a.startedAt).getTime()\n        );\n\n        // Apply limit\n        const limit = parseInt(options.limit, 10);\n        workflowList = workflowList.slice(0, limit);\n\n        if (workflowList.length === 0) {\n          console.log(chalk.gray('\\n  No workflows found'));\n          if (options.status || options.type) {\n            console.log(chalk.gray('  Try removing filters'));\n          }\n          return;\n        }\n\n        if (options.json) {\n          console.log(JSON.stringify(workflowList, null, 2));\n          return;\n        }\n\n        console.log(chalk.cyan.bold('\\n  Workflows\\n'));\n\n        // Header\n        console.log(\n          chalk.gray(\n            `  ${'ID'.padEnd(10)} ${'Type'.padEnd(12)} ${'Status'.padEnd(12)} ${'Progress'.padEnd(10)} Started`\n          )\n        );\n        console.log(chalk.gray('  ' + '-'.repeat(70)));\n\n        workflowList.forEach((wf) => {\n          const statusColor = getStatusColor(wf.status);\n          const progress = `${wf.progress}%`;\n          const started = formatRelativeTime(wf.startedAt);\n\n          console.log(\n            `  ${chalk.cyan(wf.id.padEnd(10))} ${wf.type.padEnd(12)} ${statusColor(\n              wf.status.padEnd(12)\n            )} ${progress.padEnd(10)} ${chalk.gray(started)}`\n          );\n        });\n\n        console.log();\n        console.log(\n          chalk.gray(`  Showing ${workflowList.length} workflow(s)`)\n        );\n        console.log();\n      } catch (error) {\n        console.error(chalk.red('Failed to list workflows:'), String(error));\n        process.exit(1);\n      }\n    });\n\n  // Stop command\n  workflow\n    .command('stop <id>')\n    .description('Stop a running workflow')\n    .option('-f, --force', 'Force stop without confirmation')\n    .action(async (id: string, options) => {\n      const spinner = ora(`Stopping workflow ${id}...`).start();\n\n      try {\n        const wf = workflows.get(id);\n\n        if (!wf) {\n          spinner.fail(`Workflow not found: ${id}`);\n          process.exit(1);\n        }\n\n        if (wf.status !== 'running' && wf.status !== 'pending') {\n          spinner.warn(`Workflow is not running (status: ${wf.status})`);\n          return;\n        }\n\n        // Update workflow status\n        wf.status = 'stopped';\n        wf.updatedAt = new Date().toISOString();\n        wf.message = 'Stopped by user';\n\n        spinner.succeed(`Workflow stopped: ${chalk.cyan(id)}`);\n\n        console.log();\n        console.log(chalk.white('  Final Status:'));\n        console.log(chalk.gray(`    Progress: ${wf.progress}%`));\n        console.log(chalk.gray(`    Stopped at: ${wf.updatedAt}`));\n        console.log();\n      } catch (error) {\n        spinner.fail('Failed to stop workflow');\n        console.error(chalk.red(`  ${String(error)}`));\n        process.exit(1);\n      }\n    });\n\n  // History command\n  workflow\n    .command('history')\n    .description('Show workflow history')\n    .option('-n, --limit <number>', 'Limit number of results', '20')\n    .option('-t, --type <type>', 'Filter by workflow type')\n    .option('--since <date>', 'Show workflows since date (ISO format)')\n    .option('--json', 'Output as JSON')\n    .action((options) => {\n      try {\n        let historyList = Array.from(workflows.values()).filter(\n          (w) => w.status === 'completed' || w.status === 'failed' || w.status === 'stopped'\n        );\n\n        // Apply filters\n        if (options.type) {\n          historyList = historyList.filter((w) => w.type === options.type);\n        }\n\n        if (options.since) {\n          const sinceDate = new Date(options.since);\n          if (isNaN(sinceDate.getTime())) {\n            console.error(chalk.red('Invalid date format. Use ISO format (e.g., 2024-01-01)'));\n            process.exit(1);\n          }\n          historyList = historyList.filter(\n            (w) => new Date(w.startedAt) >= sinceDate\n          );\n        }\n\n        // Sort by completion time (most recent first)\n        historyList.sort((a, b) => {\n          const timeA = new Date(a.completedAt || a.updatedAt).getTime();\n          const timeB = new Date(b.completedAt || b.updatedAt).getTime();\n          return timeB - timeA;\n        });\n\n        // Apply limit\n        const limit = parseInt(options.limit, 10);\n        historyList = historyList.slice(0, limit);\n\n        if (historyList.length === 0) {\n          console.log(chalk.gray('\\n  No workflow history found'));\n          return;\n        }\n\n        if (options.json) {\n          console.log(JSON.stringify(historyList, null, 2));\n          return;\n        }\n\n        console.log(chalk.cyan.bold('\\n  Workflow History\\n'));\n\n        // Header\n        console.log(\n          chalk.gray(\n            `  ${'ID'.padEnd(10)} ${'Type'.padEnd(12)} ${'Status'.padEnd(12)} ${'Duration'.padEnd(12)} Completed`\n          )\n        );\n        console.log(chalk.gray('  ' + '-'.repeat(75)));\n\n        historyList.forEach((wf) => {\n          const statusColor = getStatusColor(wf.status);\n          const duration = calculateDuration(wf.startedAt, wf.completedAt || wf.updatedAt);\n          const completed = formatRelativeTime(wf.completedAt || wf.updatedAt);\n\n          console.log(\n            `  ${chalk.cyan(wf.id.padEnd(10))} ${wf.type.padEnd(12)} ${statusColor(\n              wf.status.padEnd(12)\n            )} ${duration.padEnd(12)} ${chalk.gray(completed)}`\n          );\n\n          if (wf.error) {\n            console.log(chalk.red(`    Error: ${wf.error}`));\n          }\n        });\n\n        console.log();\n        console.log(\n          chalk.gray(`  Showing ${historyList.length} workflow(s)`)\n        );\n        console.log();\n      } catch (error) {\n        console.error(chalk.red('Failed to get workflow history:'), String(error));\n        process.exit(1);\n      }\n    });\n\n  // Resume command (bonus)\n  workflow\n    .command('resume <id>')\n    .description('Resume a stopped workflow')\n    .action(async (id: string) => {\n      const spinner = ora(`Resuming workflow ${id}...`).start();\n\n      try {\n        const wf = workflows.get(id);\n\n        if (!wf) {\n          spinner.fail(`Workflow not found: ${id}`);\n          process.exit(1);\n        }\n\n        if (wf.status !== 'stopped') {\n          spinner.warn(`Cannot resume workflow (status: ${wf.status})`);\n          console.log(chalk.gray('\\n  Only stopped workflows can be resumed'));\n          return;\n        }\n\n        // Update workflow status\n        wf.status = 'running';\n        wf.updatedAt = new Date().toISOString();\n        wf.message = 'Resumed by user';\n\n        spinner.succeed(`Workflow resumed: ${chalk.cyan(id)}`);\n\n        // Continue simulation\n        simulateWorkflow(id);\n\n        console.log(\n          chalk.gray(`\\n  Check status: `) +\n            chalk.cyan(`kg workflow status ${id}`)\n        );\n      } catch (error) {\n        spinner.fail('Failed to resume workflow');\n        console.error(chalk.red(`  ${String(error)}`));\n        process.exit(1);\n      }\n    });\n\n  return workflow;\n}\n\n/**\n * Simulate async workflow execution\n */\nfunction simulateWorkflow(id: string): void {\n  const wf = workflows.get(id);\n  if (!wf) return;\n\n  const interval = setInterval(() => {\n    const workflow = workflows.get(id);\n    if (!workflow || workflow.status !== 'running') {\n      clearInterval(interval);\n      return;\n    }\n\n    workflow.progress = Math.min(workflow.progress + 10, 100);\n    workflow.updatedAt = new Date().toISOString();\n\n    if (workflow.progress >= 100) {\n      workflow.status = 'completed';\n      workflow.completedAt = new Date().toISOString();\n      workflow.output = {\n        processed: true,\n        itemsProcessed: Math.floor(Math.random() * 100) + 10,\n      };\n      clearInterval(interval);\n    }\n  }, 1000);\n}\n\n/**\n * Simulate synchronous workflow execution\n */\nasync function simulateWorkflowSync(\n  id: string,\n  spinner: ReturnType<typeof ora>\n): Promise<void> {\n  const wf = workflows.get(id);\n  if (!wf) return;\n\n  for (let i = 0; i <= 100; i += 10) {\n    await sleep(300);\n    wf.progress = i;\n    wf.updatedAt = new Date().toISOString();\n    spinner.text = `Running ${wf.type} workflow... ${i}%`;\n  }\n\n  wf.status = 'completed';\n  wf.completedAt = new Date().toISOString();\n  wf.output = {\n    processed: true,\n    itemsProcessed: Math.floor(Math.random() * 100) + 10,\n  };\n}\n\n/**\n * Watch workflow status changes\n */\nasync function watchWorkflow(id: string): Promise<void> {\n  console.log(chalk.gray('\\n  Watching for changes (Ctrl+C to stop)...\\n'));\n\n  while (true) {\n    const wf = workflows.get(id);\n    if (!wf || wf.status !== 'running') {\n      if (wf) {\n        printWorkflowDetails(wf);\n      }\n      break;\n    }\n\n    process.stdout.write(\n      `\\r  Progress: ${chalk.cyan(wf.progress + '%')} | Status: ${chalk.yellow(wf.status)}`\n    );\n\n    await sleep(500);\n  }\n}\n\n/**\n * Print workflow result\n */\nfunction printWorkflowResult(wf: Workflow): void {\n  console.log();\n  console.log(chalk.white('  Result:'));\n  console.log(chalk.gray(`    Duration: ${calculateDuration(wf.startedAt, wf.completedAt || wf.updatedAt)}`));\n  if (wf.output) {\n    console.log(chalk.gray(`    Output: ${JSON.stringify(wf.output)}`));\n  }\n  console.log();\n}\n\n/**\n * Print detailed workflow information\n */\nfunction printWorkflowDetails(wf: Workflow): void {\n  const statusColor = getStatusColor(wf.status);\n\n  console.log(chalk.cyan.bold(`\\n  Workflow: ${wf.id}\\n`));\n\n  console.log(chalk.white('  Details:'));\n  console.log(chalk.gray(`    Type:     ${wf.type}`));\n  console.log(chalk.gray(`    Status:   `) + statusColor(wf.status));\n  console.log(chalk.gray(`    Progress: ${wf.progress}%`));\n\n  console.log();\n  console.log(chalk.white('  Timeline:'));\n  console.log(chalk.gray(`    Started:  ${wf.startedAt}`));\n  console.log(chalk.gray(`    Updated:  ${wf.updatedAt}`));\n  if (wf.completedAt) {\n    console.log(chalk.gray(`    Completed: ${wf.completedAt}`));\n    console.log(chalk.gray(`    Duration:  ${calculateDuration(wf.startedAt, wf.completedAt)}`));\n  }\n\n  if (wf.message) {\n    console.log();\n    console.log(chalk.white('  Message:'));\n    console.log(chalk.gray(`    ${wf.message}`));\n  }\n\n  if (wf.input) {\n    console.log();\n    console.log(chalk.white('  Input:'));\n    console.log(chalk.gray(`    ${JSON.stringify(wf.input, null, 2).replace(/\\n/g, '\\n    ')}`));\n  }\n\n  if (wf.output) {\n    console.log();\n    console.log(chalk.white('  Output:'));\n    console.log(chalk.gray(`    ${JSON.stringify(wf.output, null, 2).replace(/\\n/g, '\\n    ')}`));\n  }\n\n  if (wf.error) {\n    console.log();\n    console.log(chalk.red('  Error:'));\n    console.log(chalk.red(`    ${wf.error}`));\n  }\n\n  console.log();\n}\n\n/**\n * Print workflow summary (one line)\n */\nfunction printWorkflowSummary(wf: Workflow): void {\n  const statusColor = getStatusColor(wf.status);\n  const progressBar = createProgressBar(wf.progress, 20);\n\n  console.log(\n    `  ${chalk.cyan(wf.id)} [${wf.type}] ${statusColor(wf.status)} ${progressBar} ${wf.progress}%`\n  );\n}\n\n/**\n * Get chalk color function based on status\n */\nfunction getStatusColor(status: WorkflowStatus): typeof chalk.green {\n  switch (status) {\n    case 'completed':\n      return chalk.green;\n    case 'running':\n      return chalk.blue;\n    case 'pending':\n      return chalk.yellow;\n    case 'failed':\n      return chalk.red;\n    case 'stopped':\n      return chalk.gray;\n    default:\n      return chalk.white;\n  }\n}\n\n/**\n * Create progress bar string\n */\nfunction createProgressBar(progress: number, width: number): string {\n  const filled = Math.floor((progress / 100) * width);\n  const empty = width - filled;\n  return chalk.green('█'.repeat(filled)) + chalk.gray('░'.repeat(empty));\n}\n\n/**\n * Format relative time\n */\nfunction formatRelativeTime(isoString: string): string {\n  const date = new Date(isoString);\n  const now = new Date();\n  const diffMs = now.getTime() - date.getTime();\n  const diffSeconds = Math.floor(diffMs / 1000);\n  const diffMinutes = Math.floor(diffSeconds / 60);\n  const diffHours = Math.floor(diffMinutes / 60);\n  const diffDays = Math.floor(diffHours / 24);\n\n  if (diffSeconds < 60) return 'just now';\n  if (diffMinutes < 60) return `${diffMinutes}m ago`;\n  if (diffHours < 24) return `${diffHours}h ago`;\n  if (diffDays < 7) return `${diffDays}d ago`;\n\n  return date.toLocaleDateString();\n}\n\n/**\n * Calculate duration between two ISO timestamps\n */\nfunction calculateDuration(start: string, end: string): string {\n  const startTime = new Date(start).getTime();\n  const endTime = new Date(end).getTime();\n  const diffMs = endTime - startTime;\n\n  if (diffMs < 1000) return `${diffMs}ms`;\n  if (diffMs < 60000) return `${(diffMs / 1000).toFixed(1)}s`;\n  if (diffMs < 3600000) return `${Math.floor(diffMs / 60000)}m ${Math.floor((diffMs % 60000) / 1000)}s`;\n\n  const hours = Math.floor(diffMs / 3600000);\n  const minutes = Math.floor((diffMs % 3600000) / 60000);\n  return `${hours}h ${minutes}m`;\n}\n\n/**\n * Sleep utility\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n"],"names":[],"mappings":"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"}