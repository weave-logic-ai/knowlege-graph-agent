{"version":3,"file":"cache.js","sources":["../../src/core/cache.ts"],"sourcesContent":["/**\n * Shadow Cache - File Metadata Caching\n *\n * Provides a caching layer for file metadata to enable incremental updates\n * and improve performance when analyzing large codebases.\n *\n * @module core/cache\n */\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync, statSync } from 'fs';\nimport { join, relative, dirname } from 'path';\nimport { createHash } from 'crypto';\nimport { createLogger } from '../utils/index.js';\n\nconst logger = createLogger('shadow-cache');\n\n/**\n * File metadata stored in cache\n */\nexport interface FileMetadata {\n  /** Relative path from project root */\n  path: string;\n  /** File size in bytes */\n  size: number;\n  /** Modification time (Unix timestamp) */\n  mtime: number;\n  /** Content hash (MD5) */\n  hash: string;\n  /** File type inferred from extension */\n  type: FileType;\n  /** When this entry was cached */\n  cachedAt: number;\n}\n\n/**\n * File types for classification\n */\nexport type FileType =\n  | 'markdown'\n  | 'typescript'\n  | 'javascript'\n  | 'python'\n  | 'rust'\n  | 'go'\n  | 'java'\n  | 'php'\n  | 'ruby'\n  | 'yaml'\n  | 'json'\n  | 'toml'\n  | 'config'\n  | 'docker'\n  | 'other';\n\n/**\n * Cache entry change type\n */\nexport type ChangeType = 'added' | 'modified' | 'deleted' | 'unchanged';\n\n/**\n * File change information\n */\nexport interface FileChange {\n  path: string;\n  change: ChangeType;\n  oldMeta?: FileMetadata;\n  newMeta?: FileMetadata;\n}\n\n/**\n * Cache statistics\n */\nexport interface CacheStats {\n  totalEntries: number;\n  hitCount: number;\n  missCount: number;\n  hitRate: number;\n  sizeBytes: number;\n  lastUpdated: number | null;\n  staleEntries: number;\n}\n\n/**\n * Shadow Cache options\n */\nexport interface ShadowCacheOptions {\n  /** Project root directory */\n  projectRoot: string;\n  /** Cache directory (relative to .kg) */\n  cacheDir?: string;\n  /** Default TTL in milliseconds (default: 1 hour) */\n  defaultTTL?: number;\n  /** Maximum entries before pruning (default: 10000) */\n  maxEntries?: number;\n  /** Enable persistence to disk (default: true) */\n  persist?: boolean;\n}\n\n/**\n * Cache data structure stored on disk\n */\ninterface CacheData {\n  version: number;\n  projectRoot: string;\n  createdAt: number;\n  updatedAt: number;\n  entries: Record<string, FileMetadata>;\n}\n\nconst CACHE_VERSION = 1;\nconst CACHE_FILENAME = 'shadow-cache.json';\n\n/**\n * Shadow Cache for file metadata\n *\n * Provides efficient caching of file metadata to enable:\n * - Incremental graph updates (only process changed files)\n * - Fast file existence/modification checks\n * - Content hash comparison\n *\n * @example\n * ```typescript\n * const cache = new ShadowCache({ projectRoot: '/my/project' });\n * await cache.load();\n *\n * // Check for changes\n * const changes = await cache.detectChanges(['docs/**\\/*.md']);\n *\n * // Process only changed files\n * for (const change of changes) {\n *   if (change.change !== 'unchanged') {\n *     console.log(`${change.path}: ${change.change}`);\n *   }\n * }\n *\n * // Update cache with processed files\n * await cache.save();\n * ```\n */\nexport class ShadowCache {\n  private projectRoot: string;\n  private cacheDir: string;\n  private cachePath: string;\n  private defaultTTL: number;\n  private maxEntries: number;\n  private persist: boolean;\n\n  private entries: Map<string, FileMetadata> = new Map();\n  private hitCount = 0;\n  private missCount = 0;\n  private loaded = false;\n  private dirty = false;\n  private createdAt: number;\n  private updatedAt: number;\n\n  constructor(options: ShadowCacheOptions) {\n    this.projectRoot = options.projectRoot;\n    this.cacheDir = options.cacheDir || '.kg';\n    this.cachePath = join(this.projectRoot, this.cacheDir, CACHE_FILENAME);\n    this.defaultTTL = options.defaultTTL || 60 * 60 * 1000; // 1 hour\n    this.maxEntries = options.maxEntries || 10000;\n    this.persist = options.persist !== false;\n    this.createdAt = Date.now();\n    this.updatedAt = Date.now();\n  }\n\n  /**\n   * Load cache from disk\n   */\n  async load(): Promise<boolean> {\n    if (!this.persist) {\n      this.loaded = true;\n      return true;\n    }\n\n    try {\n      if (existsSync(this.cachePath)) {\n        const data = JSON.parse(readFileSync(this.cachePath, 'utf-8')) as CacheData;\n\n        // Verify cache is for this project\n        if (data.projectRoot !== this.projectRoot) {\n          logger.warn('Cache project root mismatch, starting fresh');\n          this.loaded = true;\n          return false;\n        }\n\n        // Check version compatibility\n        if (data.version !== CACHE_VERSION) {\n          logger.warn('Cache version mismatch, starting fresh', {\n            cacheVersion: data.version,\n            expectedVersion: CACHE_VERSION,\n          });\n          this.loaded = true;\n          return false;\n        }\n\n        // Load entries\n        this.entries = new Map(Object.entries(data.entries));\n        this.createdAt = data.createdAt;\n        this.updatedAt = data.updatedAt;\n        this.loaded = true;\n\n        logger.info('Cache loaded', { entries: this.entries.size });\n        return true;\n      }\n    } catch (error) {\n      logger.error('Failed to load cache', error instanceof Error ? error : new Error(String(error)));\n    }\n\n    this.loaded = true;\n    return false;\n  }\n\n  /**\n   * Save cache to disk\n   */\n  async save(): Promise<boolean> {\n    if (!this.persist || !this.dirty) {\n      return true;\n    }\n\n    try {\n      // Ensure cache directory exists\n      const cacheDir = dirname(this.cachePath);\n      if (!existsSync(cacheDir)) {\n        mkdirSync(cacheDir, { recursive: true });\n      }\n\n      // Prune if needed\n      await this.prune();\n\n      const data: CacheData = {\n        version: CACHE_VERSION,\n        projectRoot: this.projectRoot,\n        createdAt: this.createdAt,\n        updatedAt: Date.now(),\n        entries: Object.fromEntries(this.entries),\n      };\n\n      writeFileSync(this.cachePath, JSON.stringify(data, null, 2));\n      this.updatedAt = data.updatedAt;\n      this.dirty = false;\n\n      logger.info('Cache saved', { entries: this.entries.size });\n      return true;\n    } catch (error) {\n      logger.error('Failed to save cache', error instanceof Error ? error : new Error(String(error)));\n      return false;\n    }\n  }\n\n  /**\n   * Get cached metadata for a file\n   */\n  get(filePath: string): FileMetadata | undefined {\n    const relativePath = this.normalizePath(filePath);\n    const entry = this.entries.get(relativePath);\n\n    if (entry) {\n      this.hitCount++;\n      return entry;\n    }\n\n    this.missCount++;\n    return undefined;\n  }\n\n  /**\n   * Set cached metadata for a file\n   */\n  set(filePath: string, metadata: Partial<FileMetadata>): FileMetadata {\n    const relativePath = this.normalizePath(filePath);\n    const fullPath = join(this.projectRoot, relativePath);\n\n    let entry: FileMetadata;\n\n    if (metadata.hash && metadata.size !== undefined && metadata.mtime !== undefined) {\n      // Full metadata provided\n      entry = {\n        path: relativePath,\n        size: metadata.size,\n        mtime: metadata.mtime,\n        hash: metadata.hash,\n        type: metadata.type || this.inferFileType(relativePath),\n        cachedAt: Date.now(),\n      };\n    } else {\n      // Compute from file\n      entry = this.computeMetadata(fullPath, relativePath);\n    }\n\n    this.entries.set(relativePath, entry);\n    this.dirty = true;\n    return entry;\n  }\n\n  /**\n   * Remove a file from cache\n   */\n  delete(filePath: string): boolean {\n    const relativePath = this.normalizePath(filePath);\n    const deleted = this.entries.delete(relativePath);\n    if (deleted) {\n      this.dirty = true;\n    }\n    return deleted;\n  }\n\n  /**\n   * Check if a file exists in cache\n   */\n  has(filePath: string): boolean {\n    const relativePath = this.normalizePath(filePath);\n    return this.entries.has(relativePath);\n  }\n\n  /**\n   * Check if a file has changed since caching\n   */\n  hasChanged(filePath: string): boolean {\n    const relativePath = this.normalizePath(filePath);\n    const fullPath = join(this.projectRoot, relativePath);\n    const cached = this.entries.get(relativePath);\n\n    if (!cached) {\n      return true; // Not in cache = changed (new file)\n    }\n\n    try {\n      const stats = statSync(fullPath);\n      // Quick check: mtime and size\n      if (stats.mtimeMs !== cached.mtime || stats.size !== cached.size) {\n        return true;\n      }\n      return false;\n    } catch {\n      return true; // File doesn't exist = changed (deleted)\n    }\n  }\n\n  /**\n   * Detect changes for a list of files\n   */\n  async detectChanges(filePaths: string[]): Promise<FileChange[]> {\n    const changes: FileChange[] = [];\n    const currentFiles = new Set<string>();\n\n    for (const filePath of filePaths) {\n      const relativePath = this.normalizePath(filePath);\n      const fullPath = join(this.projectRoot, relativePath);\n      currentFiles.add(relativePath);\n\n      const cached = this.entries.get(relativePath);\n\n      try {\n        const stats = statSync(fullPath);\n        const newMeta = this.computeMetadata(fullPath, relativePath);\n\n        if (!cached) {\n          changes.push({\n            path: relativePath,\n            change: 'added',\n            newMeta,\n          });\n        } else if (cached.mtime !== stats.mtimeMs || cached.size !== stats.size) {\n          // Full hash comparison for definitive change detection\n          if (cached.hash !== newMeta.hash) {\n            changes.push({\n              path: relativePath,\n              change: 'modified',\n              oldMeta: cached,\n              newMeta,\n            });\n          } else {\n            // mtime changed but content same (touch, etc.)\n            changes.push({\n              path: relativePath,\n              change: 'unchanged',\n              oldMeta: cached,\n              newMeta,\n            });\n          }\n        } else {\n          changes.push({\n            path: relativePath,\n            change: 'unchanged',\n            oldMeta: cached,\n            newMeta: cached,\n          });\n        }\n      } catch {\n        if (cached) {\n          changes.push({\n            path: relativePath,\n            change: 'deleted',\n            oldMeta: cached,\n          });\n        }\n      }\n    }\n\n    // Detect deleted files (in cache but not in current list)\n    for (const [path, meta] of this.entries) {\n      if (!currentFiles.has(path)) {\n        changes.push({\n          path,\n          change: 'deleted',\n          oldMeta: meta,\n        });\n      }\n    }\n\n    return changes;\n  }\n\n  /**\n   * Update cache with detected changes\n   */\n  applyChanges(changes: FileChange[]): void {\n    for (const change of changes) {\n      switch (change.change) {\n        case 'added':\n        case 'modified':\n          if (change.newMeta) {\n            this.entries.set(change.path, change.newMeta);\n          }\n          break;\n        case 'deleted':\n          this.entries.delete(change.path);\n          break;\n      }\n    }\n    this.dirty = true;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): CacheStats {\n    let staleCount = 0;\n    const now = Date.now();\n\n    for (const entry of this.entries.values()) {\n      if (now - entry.cachedAt > this.defaultTTL) {\n        staleCount++;\n      }\n    }\n\n    const totalRequests = this.hitCount + this.missCount;\n\n    return {\n      totalEntries: this.entries.size,\n      hitCount: this.hitCount,\n      missCount: this.missCount,\n      hitRate: totalRequests > 0 ? this.hitCount / totalRequests : 0,\n      sizeBytes: this.estimateSize(),\n      lastUpdated: this.updatedAt,\n      staleEntries: staleCount,\n    };\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  clear(): void {\n    this.entries.clear();\n    this.hitCount = 0;\n    this.missCount = 0;\n    this.dirty = true;\n  }\n\n  /**\n   * Prune stale entries\n   */\n  async prune(): Promise<number> {\n    const now = Date.now();\n    let prunedCount = 0;\n\n    // Prune by TTL\n    for (const [path, entry] of this.entries) {\n      if (now - entry.cachedAt > this.defaultTTL) {\n        this.entries.delete(path);\n        prunedCount++;\n      }\n    }\n\n    // Prune by max entries (LRU-ish: oldest cached first)\n    if (this.entries.size > this.maxEntries) {\n      const entries = Array.from(this.entries.entries())\n        .sort((a, b) => a[1].cachedAt - b[1].cachedAt);\n\n      const toRemove = entries.slice(0, entries.length - this.maxEntries);\n      for (const [path] of toRemove) {\n        this.entries.delete(path);\n        prunedCount++;\n      }\n    }\n\n    if (prunedCount > 0) {\n      this.dirty = true;\n      logger.info('Pruned cache entries', { count: prunedCount });\n    }\n\n    return prunedCount;\n  }\n\n  /**\n   * Get all cached file paths\n   */\n  getAllPaths(): string[] {\n    return Array.from(this.entries.keys());\n  }\n\n  /**\n   * Get files by type\n   */\n  getByType(type: FileType): FileMetadata[] {\n    return Array.from(this.entries.values()).filter(e => e.type === type);\n  }\n\n  /**\n   * Invalidate entries matching a pattern\n   */\n  invalidate(pattern: RegExp): number {\n    let count = 0;\n    for (const path of this.entries.keys()) {\n      if (pattern.test(path)) {\n        this.entries.delete(path);\n        count++;\n      }\n    }\n    if (count > 0) {\n      this.dirty = true;\n    }\n    return count;\n  }\n\n  // Private helpers\n\n  private normalizePath(filePath: string): string {\n    // Make path relative to project root\n    if (filePath.startsWith(this.projectRoot)) {\n      return relative(this.projectRoot, filePath);\n    }\n    return filePath;\n  }\n\n  private computeMetadata(fullPath: string, relativePath: string): FileMetadata {\n    const stats = statSync(fullPath);\n    const content = readFileSync(fullPath);\n    const hash = createHash('md5').update(content).digest('hex');\n\n    return {\n      path: relativePath,\n      size: stats.size,\n      mtime: stats.mtimeMs,\n      hash,\n      type: this.inferFileType(relativePath),\n      cachedAt: Date.now(),\n    };\n  }\n\n  private inferFileType(filePath: string): FileType {\n    const ext = filePath.split('.').pop()?.toLowerCase() || '';\n    const filename = filePath.split('/').pop()?.toLowerCase() || '';\n\n    // Docker files\n    if (filename === 'dockerfile' || filename.startsWith('dockerfile.')) {\n      return 'docker';\n    }\n    if (filename.includes('docker-compose') || filename === 'compose.yml' || filename === 'compose.yaml') {\n      return 'docker';\n    }\n\n    // By extension\n    switch (ext) {\n      case 'md':\n      case 'mdx':\n        return 'markdown';\n      case 'ts':\n      case 'tsx':\n      case 'mts':\n      case 'cts':\n        return 'typescript';\n      case 'js':\n      case 'jsx':\n      case 'mjs':\n      case 'cjs':\n        return 'javascript';\n      case 'py':\n      case 'pyw':\n        return 'python';\n      case 'rs':\n        return 'rust';\n      case 'go':\n        return 'go';\n      case 'java':\n        return 'java';\n      case 'php':\n        return 'php';\n      case 'rb':\n        return 'ruby';\n      case 'yml':\n      case 'yaml':\n        return 'yaml';\n      case 'json':\n        return 'json';\n      case 'toml':\n        return 'toml';\n      case 'ini':\n      case 'env':\n      case 'conf':\n      case 'config':\n        return 'config';\n      default:\n        return 'other';\n    }\n  }\n\n  private estimateSize(): number {\n    // Rough estimate: JSON serialization size\n    let size = 0;\n    for (const entry of this.entries.values()) {\n      size += entry.path.length + entry.hash.length + 100; // ~100 bytes overhead per entry\n    }\n    return size;\n  }\n}\n\n/**\n * Create a shadow cache for a project\n */\nexport function createShadowCache(options: ShadowCacheOptions): ShadowCache {\n  return new ShadowCache(options);\n}\n\n/**\n * Load or create shadow cache for a project\n */\nexport async function loadShadowCache(projectRoot: string): Promise<ShadowCache> {\n  const cache = new ShadowCache({ projectRoot });\n  await cache.load();\n  return cache;\n}\n"],"names":[],"mappings":"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"}