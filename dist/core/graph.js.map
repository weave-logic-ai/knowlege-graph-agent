{"version":3,"file":"graph.js","sources":["../../src/core/graph.ts"],"sourcesContent":["/**\n * Knowledge Graph Core\n *\n * Core graph data structure and operations for managing knowledge nodes.\n */\n\nimport type {\n  KnowledgeNode,\n  KnowledgeGraph,\n  GraphEdge,\n  GraphMetadata,\n  GraphStats,\n  NodeType,\n  NodeStatus,\n  NodeLink,\n} from './types.js';\n\n/**\n * Knowledge Graph Manager\n *\n * Manages the in-memory knowledge graph with efficient operations\n * for node/edge management, traversal, and analysis.\n */\nexport class KnowledgeGraphManager {\n  private nodes: Map<string, KnowledgeNode> = new Map();\n  private edges: GraphEdge[] = [];\n  private incomingIndex: Map<string, GraphEdge[]> = new Map();\n  private outgoingIndex: Map<string, GraphEdge[]> = new Map();\n  private tagIndex: Map<string, Set<string>> = new Map();\n  private metadata: GraphMetadata;\n\n  constructor(name: string, rootPath: string) {\n    this.metadata = {\n      name,\n      version: '1.0.0',\n      created: new Date().toISOString(),\n      updated: new Date().toISOString(),\n      nodeCount: 0,\n      edgeCount: 0,\n      rootPath,\n    };\n  }\n\n  // ========================================================================\n  // Node Operations\n  // ========================================================================\n\n  /**\n   * Add a node to the graph\n   */\n  addNode(node: KnowledgeNode): void {\n    this.nodes.set(node.id, node);\n    this.metadata.nodeCount = this.nodes.size;\n    this.metadata.updated = new Date().toISOString();\n\n    // Index tags\n    for (const tag of node.tags) {\n      if (!this.tagIndex.has(tag)) {\n        this.tagIndex.set(tag, new Set());\n      }\n      this.tagIndex.get(tag)!.add(node.id);\n    }\n\n    // Create edges from outgoing links\n    for (const link of node.outgoingLinks) {\n      this.addEdge({\n        source: node.id,\n        target: link.target,\n        type: 'link',\n        weight: 1,\n        context: link.context,\n      });\n    }\n  }\n\n  /**\n   * Get a node by ID\n   */\n  getNode(id: string): KnowledgeNode | undefined {\n    return this.nodes.get(id);\n  }\n\n  /**\n   * Get all nodes\n   */\n  getAllNodes(): KnowledgeNode[] {\n    return Array.from(this.nodes.values());\n  }\n\n  /**\n   * Get nodes by type\n   */\n  getNodesByType(type: NodeType): KnowledgeNode[] {\n    return this.getAllNodes().filter(node => node.type === type);\n  }\n\n  /**\n   * Get nodes by status\n   */\n  getNodesByStatus(status: NodeStatus): KnowledgeNode[] {\n    return this.getAllNodes().filter(node => node.status === status);\n  }\n\n  /**\n   * Get nodes by tag\n   */\n  getNodesByTag(tag: string): KnowledgeNode[] {\n    const nodeIds = this.tagIndex.get(tag);\n    if (!nodeIds) return [];\n    return Array.from(nodeIds)\n      .map(id => this.nodes.get(id))\n      .filter((n): n is KnowledgeNode => n !== undefined);\n  }\n\n  /**\n   * Update a node\n   */\n  updateNode(id: string, updates: Partial<KnowledgeNode>): boolean {\n    const existing = this.nodes.get(id);\n    if (!existing) return false;\n\n    // Handle tag changes\n    if (updates.tags) {\n      // Remove old tags from index\n      for (const tag of existing.tags) {\n        this.tagIndex.get(tag)?.delete(id);\n      }\n      // Add new tags to index\n      for (const tag of updates.tags) {\n        if (!this.tagIndex.has(tag)) {\n          this.tagIndex.set(tag, new Set());\n        }\n        this.tagIndex.get(tag)!.add(id);\n      }\n    }\n\n    const updated: KnowledgeNode = {\n      ...existing,\n      ...updates,\n      lastModified: new Date(),\n    };\n    this.nodes.set(id, updated);\n    this.metadata.updated = new Date().toISOString();\n    return true;\n  }\n\n  /**\n   * Remove a node\n   */\n  removeNode(id: string): boolean {\n    const node = this.nodes.get(id);\n    if (!node) return false;\n\n    // Remove from tag index\n    for (const tag of node.tags) {\n      this.tagIndex.get(tag)?.delete(id);\n    }\n\n    // Remove related edges\n    this.edges = this.edges.filter(e => e.source !== id && e.target !== id);\n    this.incomingIndex.delete(id);\n    this.outgoingIndex.delete(id);\n\n    // Update indices for remaining edges\n    for (const [targetId, edges] of this.incomingIndex) {\n      this.incomingIndex.set(targetId, edges.filter(e => e.source !== id));\n    }\n    for (const [sourceId, edges] of this.outgoingIndex) {\n      this.outgoingIndex.set(sourceId, edges.filter(e => e.target !== id));\n    }\n\n    this.nodes.delete(id);\n    this.metadata.nodeCount = this.nodes.size;\n    this.metadata.edgeCount = this.edges.length;\n    this.metadata.updated = new Date().toISOString();\n    return true;\n  }\n\n  // ========================================================================\n  // Edge Operations\n  // ========================================================================\n\n  /**\n   * Add an edge to the graph\n   */\n  addEdge(edge: GraphEdge): void {\n    // Check for duplicates\n    const exists = this.edges.some(\n      e => e.source === edge.source && e.target === edge.target && e.type === edge.type\n    );\n    if (exists) return;\n\n    this.edges.push(edge);\n\n    // Update incoming index\n    if (!this.incomingIndex.has(edge.target)) {\n      this.incomingIndex.set(edge.target, []);\n    }\n    this.incomingIndex.get(edge.target)!.push(edge);\n\n    // Update outgoing index\n    if (!this.outgoingIndex.has(edge.source)) {\n      this.outgoingIndex.set(edge.source, []);\n    }\n    this.outgoingIndex.get(edge.source)!.push(edge);\n\n    this.metadata.edgeCount = this.edges.length;\n    this.metadata.updated = new Date().toISOString();\n  }\n\n  /**\n   * Get incoming edges for a node\n   */\n  getIncomingEdges(nodeId: string): GraphEdge[] {\n    return this.incomingIndex.get(nodeId) || [];\n  }\n\n  /**\n   * Get outgoing edges for a node\n   */\n  getOutgoingEdges(nodeId: string): GraphEdge[] {\n    return this.outgoingIndex.get(nodeId) || [];\n  }\n\n  /**\n   * Get all edges\n   */\n  getAllEdges(): GraphEdge[] {\n    return [...this.edges];\n  }\n\n  // ========================================================================\n  // Graph Analysis\n  // ========================================================================\n\n  /**\n   * Find orphan nodes (no incoming or outgoing links)\n   */\n  findOrphanNodes(): KnowledgeNode[] {\n    return this.getAllNodes().filter(node => {\n      const incoming = this.getIncomingEdges(node.id);\n      const outgoing = this.getOutgoingEdges(node.id);\n      return incoming.length === 0 && outgoing.length === 0;\n    });\n  }\n\n  /**\n   * Find most connected nodes\n   */\n  findMostConnected(limit = 10): Array<{ node: KnowledgeNode; connections: number }> {\n    const connections = new Map<string, number>();\n\n    for (const node of this.nodes.keys()) {\n      const incoming = this.getIncomingEdges(node).length;\n      const outgoing = this.getOutgoingEdges(node).length;\n      connections.set(node, incoming + outgoing);\n    }\n\n    return Array.from(connections.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, limit)\n      .map(([id, count]) => ({\n        node: this.nodes.get(id)!,\n        connections: count,\n      }));\n  }\n\n  /**\n   * Find path between two nodes (BFS)\n   */\n  findPath(sourceId: string, targetId: string): string[] | null {\n    if (!this.nodes.has(sourceId) || !this.nodes.has(targetId)) {\n      return null;\n    }\n\n    if (sourceId === targetId) {\n      return [sourceId];\n    }\n\n    const visited = new Set<string>();\n    const queue: Array<{ node: string; path: string[] }> = [\n      { node: sourceId, path: [sourceId] },\n    ];\n\n    while (queue.length > 0) {\n      const { node, path } = queue.shift()!;\n\n      if (visited.has(node)) continue;\n      visited.add(node);\n\n      const outgoing = this.getOutgoingEdges(node);\n      for (const edge of outgoing) {\n        if (edge.target === targetId) {\n          return [...path, targetId];\n        }\n        if (!visited.has(edge.target)) {\n          queue.push({ node: edge.target, path: [...path, edge.target] });\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Find related nodes (nodes connected within n hops)\n   */\n  findRelated(nodeId: string, maxHops = 2): KnowledgeNode[] {\n    const related = new Set<string>();\n    const visited = new Set<string>();\n    const queue: Array<{ node: string; hops: number }> = [{ node: nodeId, hops: 0 }];\n\n    while (queue.length > 0) {\n      const { node, hops } = queue.shift()!;\n\n      if (visited.has(node) || hops > maxHops) continue;\n      visited.add(node);\n\n      if (node !== nodeId) {\n        related.add(node);\n      }\n\n      if (hops < maxHops) {\n        const outgoing = this.getOutgoingEdges(node);\n        const incoming = this.getIncomingEdges(node);\n\n        for (const edge of [...outgoing, ...incoming]) {\n          const neighbor = edge.source === node ? edge.target : edge.source;\n          if (!visited.has(neighbor)) {\n            queue.push({ node: neighbor, hops: hops + 1 });\n          }\n        }\n      }\n    }\n\n    return Array.from(related)\n      .map(id => this.nodes.get(id))\n      .filter((n): n is KnowledgeNode => n !== undefined);\n  }\n\n  /**\n   * Get graph statistics\n   */\n  getStats(): GraphStats {\n    const nodesByType: Record<NodeType, number> = {\n      concept: 0,\n      technical: 0,\n      feature: 0,\n      primitive: 0,\n      service: 0,\n      guide: 0,\n      standard: 0,\n      integration: 0,\n    };\n\n    const nodesByStatus: Record<NodeStatus, number> = {\n      draft: 0,\n      active: 0,\n      deprecated: 0,\n      archived: 0,\n    };\n\n    for (const node of this.nodes.values()) {\n      nodesByType[node.type]++;\n      nodesByStatus[node.status]++;\n    }\n\n    const orphanNodes = this.findOrphanNodes().length;\n    const avgLinksPerNode = this.nodes.size > 0\n      ? this.edges.length / this.nodes.size\n      : 0;\n\n    const mostConnected = this.findMostConnected(5).map(({ node, connections }) => ({\n      id: node.id,\n      connections,\n    }));\n\n    return {\n      totalNodes: this.nodes.size,\n      totalEdges: this.edges.length,\n      nodesByType,\n      nodesByStatus,\n      orphanNodes,\n      avgLinksPerNode: Math.round(avgLinksPerNode * 100) / 100,\n      mostConnected,\n    };\n  }\n\n  // ========================================================================\n  // Serialization\n  // ========================================================================\n\n  /**\n   * Export graph to JSON\n   */\n  toJSON(): KnowledgeGraph {\n    return {\n      nodes: this.nodes,\n      edges: [...this.edges],\n      metadata: { ...this.metadata },\n    };\n  }\n\n  /**\n   * Import graph from JSON\n   */\n  static fromJSON(data: KnowledgeGraph): KnowledgeGraphManager {\n    const manager = new KnowledgeGraphManager(\n      data.metadata.name,\n      data.metadata.rootPath\n    );\n\n    // Add nodes (this will also create edges from outgoing links)\n    for (const [id, node] of data.nodes) {\n      manager.nodes.set(id, node);\n\n      // Index tags\n      for (const tag of node.tags) {\n        if (!manager.tagIndex.has(tag)) {\n          manager.tagIndex.set(tag, new Set());\n        }\n        manager.tagIndex.get(tag)!.add(id);\n      }\n    }\n\n    // Add edges\n    for (const edge of data.edges) {\n      manager.addEdge(edge);\n    }\n\n    manager.metadata = { ...data.metadata };\n    return manager;\n  }\n\n  /**\n   * Get graph metadata\n   */\n  getMetadata(): GraphMetadata {\n    return { ...this.metadata };\n  }\n}\n\n/**\n * Create a new knowledge graph manager\n */\nexport function createKnowledgeGraph(name: string, rootPath: string): KnowledgeGraphManager {\n  return new KnowledgeGraphManager(name, rootPath);\n}\n"],"names":[],"mappings":"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"}