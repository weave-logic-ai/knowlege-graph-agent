{"version":3,"file":"security.js","sources":["../../src/core/security.ts"],"sourcesContent":["/**\n * Security Utilities\n *\n * Helper functions for input validation and security.\n */\n\nimport { resolve, normalize, isAbsolute } from 'path';\n\n/**\n * Validate that a path stays within a base directory\n * Prevents path traversal attacks\n *\n * @param basePath - The base directory that paths must stay within\n * @param relativePath - The relative path to validate\n * @returns The resolved absolute path\n * @throws Error if path traversal is detected\n */\nexport function validatePath(basePath: string, relativePath: string): string {\n  // Resolve the base path to absolute\n  const resolvedBase = resolve(basePath);\n\n  // Handle absolute paths - must still be within base\n  const targetPath = isAbsolute(relativePath)\n    ? normalize(relativePath)\n    : resolve(resolvedBase, relativePath);\n\n  const normalizedTarget = normalize(targetPath);\n\n  // Ensure the resolved path is within the base path\n  if (!normalizedTarget.startsWith(resolvedBase + '/') && normalizedTarget !== resolvedBase) {\n    throw new Error(`Path traversal detected: \"${relativePath}\" escapes base directory`);\n  }\n\n  return normalizedTarget;\n}\n\n/**\n * Validate and sanitize a project root path\n * Ensures the path exists and is a directory\n *\n * @param projectRoot - The project root path\n * @returns The resolved absolute path\n * @throws Error if invalid\n */\nexport function validateProjectRoot(projectRoot: string): string {\n  if (!projectRoot || typeof projectRoot !== 'string') {\n    throw new Error('Project root path is required');\n  }\n\n  // Resolve to absolute path\n  const resolved = resolve(projectRoot);\n\n  // Check for suspicious patterns\n  if (resolved.includes('\\0')) {\n    throw new Error('Invalid null byte in path');\n  }\n\n  return resolved;\n}\n\n/**\n * Validate a docs path relative to project root\n *\n * @param projectRoot - The project root path\n * @param docsPath - The docs directory path (relative or absolute)\n * @returns The validated absolute path\n * @throws Error if path traversal detected\n */\nexport function validateDocsPath(projectRoot: string, docsPath: string): string {\n  const resolvedRoot = validateProjectRoot(projectRoot);\n\n  // Default to 'docs' if empty\n  const safeDocs = docsPath?.trim() || 'docs';\n\n  // Validate it stays within project\n  return validatePath(resolvedRoot, safeDocs);\n}\n\n/**\n * Sanitize a filename to prevent directory traversal\n *\n * @param filename - The filename to sanitize\n * @returns The sanitized filename\n */\nexport function sanitizeFilename(filename: string): string {\n  if (!filename || typeof filename !== 'string') {\n    return 'untitled';\n  }\n\n  return filename\n    .replace(/\\.\\./g, '') // Remove parent directory references\n    .replace(/[<>:\"|?*\\0]/g, '') // Remove invalid filename chars\n    .replace(/^\\/+|\\/+$/g, '') // Remove leading/trailing slashes\n    .slice(0, 255); // Limit length\n}\n\n/**\n * Sanitize user input for safe display\n * Removes potentially dangerous characters\n *\n * @param input - The input string to sanitize\n * @param maxLength - Maximum length (default 1000)\n * @returns The sanitized string\n */\nexport function sanitizeInput(input: string, maxLength = 1000): string {\n  if (!input || typeof input !== 'string') {\n    return '';\n  }\n\n  return input\n    .replace(/[<>&\"'`]/g, '') // Remove HTML-sensitive chars\n    .slice(0, maxLength)\n    .trim();\n}\n\n/**\n * Validate a template path - must be within project and be a .md file\n *\n * @param projectRoot - The project root path\n * @param templatePath - The template path to validate\n * @returns The validated absolute path or null if invalid\n */\nexport function validateTemplatePath(\n  projectRoot: string,\n  templatePath: string\n): string | null {\n  try {\n    const resolvedRoot = validateProjectRoot(projectRoot);\n    const validated = validatePath(resolvedRoot, templatePath);\n\n    // Must be a markdown file\n    if (!validated.endsWith('.md')) {\n      return null;\n    }\n\n    return validated;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Check if a string looks like a file path\n */\nexport function looksLikePath(str: string): boolean {\n  return str.includes('/') || str.includes('\\\\') || str.startsWith('.');\n}\n"],"names":[],"mappings":";AAiBO,SAAS,aAAa,UAAkB,cAA8B;AAE3E,QAAM,eAAe,QAAQ,QAAQ;AAGrC,QAAM,aAAa,WAAW,YAAY,IACtC,UAAU,YAAY,IACtB,QAAQ,cAAc,YAAY;AAEtC,QAAM,mBAAmB,UAAU,UAAU;AAG7C,MAAI,CAAC,iBAAiB,WAAW,eAAe,GAAG,KAAK,qBAAqB,cAAc;AACzF,UAAM,IAAI,MAAM,6BAA6B,YAAY,0BAA0B;AAAA,EACrF;AAEA,SAAO;AACT;AAUO,SAAS,oBAAoB,aAA6B;AAC/D,MAAI,CAAC,eAAe,OAAO,gBAAgB,UAAU;AACnD,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACjD;AAGA,QAAM,WAAW,QAAQ,WAAW;AAGpC,MAAI,SAAS,SAAS,IAAI,GAAG;AAC3B,UAAM,IAAI,MAAM,2BAA2B;AAAA,EAC7C;AAEA,SAAO;AACT;AAUO,SAAS,iBAAiB,aAAqB,UAA0B;AAC9E,QAAM,eAAe,oBAAoB,WAAW;AAGpD,QAAM,WAAW,UAAU,KAAA,KAAU;AAGrC,SAAO,aAAa,cAAc,QAAQ;AAC5C;"}