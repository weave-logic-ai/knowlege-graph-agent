import { existsSync, writeFileSync, readFileSync } from "fs";
import { join, basename, resolve, normalize } from "path";
import Handlebars from "handlebars";
function validateTemplatePath(projectRoot, templatePath) {
  const resolvedRoot = resolve(projectRoot);
  const resolvedTemplate = resolve(projectRoot, templatePath);
  const normalizedTemplate = normalize(resolvedTemplate);
  if (!normalizedTemplate.startsWith(resolvedRoot + "/") && normalizedTemplate !== resolvedRoot) {
    return null;
  }
  if (!normalizedTemplate.endsWith(".md")) {
    return null;
  }
  return normalizedTemplate;
}
const DEFAULT_TEMPLATE = `# Claude Code Configuration - {{projectName}}

## Project Overview

{{description}}

## Knowledge Graph Integration

This project uses @weavelogic/knowledge-graph-agent for documentation and planning.

### Quick Commands

\`\`\`bash
# Initialize knowledge graph
npx kg init

# Generate/update graph from docs
npx kg graph

# Sync with claude-flow memory
npx kg sync

# Initialize docs directory
npx kg docs init

# Update CLAUDE.md
npx kg claude update
\`\`\`

### Vault Location

Documentation is stored in: \`{{docsPath}}\`

## File Organization

{{#if customDirectories}}
{{#each customDirectories}}
- \`{{this.path}}\` - {{this.description}}
{{/each}}
{{else}}
- \`/src\` - Source code files
- \`/docs\` - Documentation and knowledge base
- \`/tests\` - Test files
- \`/config\` - Configuration files
{{/if}}

## Build Commands

{{#each buildCommands}}
- \`{{this.command}}\` - {{this.description}}
{{/each}}

## Code Style & Best Practices

{{#each codeStyleRules}}
- **{{this.name}}**: {{this.description}}
{{/each}}

{{#if includeClaudeFlow}}
## Claude-Flow Integration

This project uses claude-flow for AI coordination:

### MCP Configuration

\`\`\`bash
claude mcp add claude-flow npx claude-flow@alpha mcp start
\`\`\`

### Memory Namespace

- **Namespace**: \`{{namespace}}\`
- **Sync on change**: {{syncOnChange}}

### Available Tools

- \`mcp__claude-flow__memory_usage\` - Store/retrieve knowledge
- \`mcp__claude-flow__swarm_init\` - Initialize agent swarms
- \`mcp__claude-flow__task_orchestrate\` - Coordinate tasks

{{/if}}
{{#if includeKnowledgeGraph}}
## Knowledge Graph Commands

The knowledge graph provides semantic navigation of the codebase:

### CLI Commands

| Command | Description |
|---------|-------------|
| \`kg init\` | Initialize knowledge graph in project |
| \`kg graph\` | Generate/update knowledge graph |
| \`kg docs init\` | Initialize docs directory |
| \`kg docs generate\` | Generate docs from codebase |
| \`kg claude update\` | Update CLAUDE.md |
| \`kg sync\` | Sync with claude-flow memory |
| \`kg stats\` | Show graph statistics |
| \`kg search <query>\` | Search the knowledge graph |

### Graph Structure

\`\`\`
{{docsPath}}/
├── concepts/        # Abstract concepts
├── components/      # Reusable components
├── services/        # Backend services
├── features/        # Product features
├── integrations/    # External integrations
├── standards/       # Coding standards
├── guides/          # How-to guides
└── references/      # API references
\`\`\`

{{/if}}
{{#if customSections}}
{{#each customSections}}
## {{this.title}}

{{this.content}}

{{/each}}
{{/if}}
## Important Instructions

- NEVER create files unless absolutely necessary
- ALWAYS prefer editing existing files
- Use the knowledge graph for documentation
- Follow the file organization above
- Run tests before committing

---
*Generated by @weavelogic/knowledge-graph-agent*
`;
const SECTION_TEMPLATES = {
  sparc: {
    title: "SPARC Methodology",
    order: 10,
    content: `This project follows the SPARC development methodology:

1. **Specification** - Requirements analysis
2. **Pseudocode** - Algorithm design
3. **Architecture** - System design
4. **Refinement** - TDD implementation
5. **Completion** - Integration

### SPARC Commands

\`\`\`bash
npx claude-flow sparc modes        # List available modes
npx claude-flow sparc tdd "<task>" # Run TDD workflow
npx claude-flow sparc run <mode>   # Execute specific mode
\`\`\``
  },
  testing: {
    title: "Testing Requirements",
    order: 20,
    content: `All code changes must include appropriate tests:

- **Unit tests**: For individual functions and components
- **Integration tests**: For API endpoints and services
- **E2E tests**: For critical user flows

### Running Tests

\`\`\`bash
npm run test         # Run all tests
npm run test:watch   # Watch mode
npm run test:cov     # With coverage
\`\`\``
  },
  security: {
    title: "Security Guidelines",
    order: 30,
    content: `Security is a priority. Follow these guidelines:

- Never hardcode secrets or API keys
- Use environment variables for sensitive data
- Validate all user inputs
- Sanitize outputs to prevent XSS
- Follow OWASP guidelines`
  },
  agents: {
    title: "Available Agents",
    order: 40,
    content: `Use Claude Code's Task tool to spawn specialized agents:

### Core Agents
\`coder\`, \`reviewer\`, \`tester\`, \`planner\`, \`researcher\`

### SPARC Agents
\`sparc-coord\`, \`sparc-coder\`, \`specification\`, \`architecture\`

### Specialized Agents
\`backend-dev\`, \`system-architect\`, \`code-analyzer\`, \`api-docs\`

### Usage

\`\`\`javascript
Task("Implement feature", "Description...", "coder")
Task("Review code", "Description...", "reviewer")
\`\`\``
  }
};
function generateClaudeMd(options) {
  const {
    projectRoot,
    template,
    includeKnowledgeGraph = true,
    includeClaudeFlow = true,
    customSections = []
  } = options;
  const projectInfo = detectProjectInfo(projectRoot);
  const context = {
    projectName: projectInfo.name,
    description: projectInfo.description || `${projectInfo.name} project`,
    docsPath: getDocsPath(projectRoot),
    includeKnowledgeGraph,
    includeClaudeFlow,
    namespace: "knowledge-graph",
    syncOnChange: true,
    buildCommands: projectInfo.scripts,
    codeStyleRules: getDefaultCodeStyleRules(),
    customSections: [...customSections],
    customDirectories: null
  };
  const templateContent = template ? getTemplateContent(template, projectRoot) : DEFAULT_TEMPLATE;
  const compiled = Handlebars.compile(templateContent);
  return compiled(context);
}
async function updateClaudeMd(options) {
  const { projectRoot, outputPath } = options;
  const filePath = outputPath || join(projectRoot, "CLAUDE.md");
  const exists = existsSync(filePath);
  const content = generateClaudeMd(options);
  writeFileSync(filePath, content, "utf-8");
  return {
    created: !exists,
    updated: exists,
    path: filePath,
    content
  };
}
function addSection(projectRoot, section) {
  const filePath = join(projectRoot, "CLAUDE.md");
  if (!existsSync(filePath)) {
    return false;
  }
  const content = readFileSync(filePath, "utf-8");
  const sectionRegex = new RegExp(`^## ${section.title}`, "m");
  if (sectionRegex.test(content)) {
    return false;
  }
  const importantMatch = content.match(/^## Important Instructions/m);
  let newContent;
  const sectionContent = `
## ${section.title}

${section.content}
`;
  if (importantMatch && importantMatch.index !== void 0) {
    newContent = content.slice(0, importantMatch.index) + sectionContent + "\n" + content.slice(importantMatch.index);
  } else {
    newContent = content + sectionContent;
  }
  writeFileSync(filePath, newContent, "utf-8");
  return true;
}
function getSectionTemplate(name) {
  return SECTION_TEMPLATES[name] || null;
}
function listSectionTemplates() {
  return Object.keys(SECTION_TEMPLATES);
}
function sanitizeForTemplate(str, maxLength = 200) {
  if (!str || typeof str !== "string") return "";
  return str.replace(/[<>&"'`{}\\]/g, "").replace(/\{\{/g, "").replace(/\}\}/g, "").slice(0, maxLength).trim();
}
function detectProjectInfo(projectRoot) {
  const info = {
    name: sanitizeForTemplate(basename(projectRoot), 100) || "project",
    scripts: []
  };
  try {
    const pkgPath = join(projectRoot, "package.json");
    if (existsSync(pkgPath)) {
      let pkg;
      try {
        pkg = JSON.parse(readFileSync(pkgPath, "utf-8"));
      } catch {
        return info;
      }
      const rawName = (pkg.name || basename(projectRoot)).replace(/^@[^/]+\//, "");
      info.name = sanitizeForTemplate(rawName, 100) || "project";
      info.description = sanitizeForTemplate(pkg.description, 500);
      if (pkg.scripts && typeof pkg.scripts === "object") {
        const commonScripts = ["build", "test", "dev", "start", "lint", "typecheck"];
        for (const script of commonScripts) {
          if (pkg.scripts[script] && typeof pkg.scripts[script] === "string") {
            info.scripts.push({
              command: `npm run ${script}`,
              description: sanitizeForTemplate(
                getScriptDescription(script, pkg.scripts[script]),
                200
              )
            });
          }
        }
      }
    }
  } catch {
  }
  if (info.scripts.length === 0) {
    info.scripts = [
      { command: "npm run build", description: "Build the project" },
      { command: "npm run test", description: "Run tests" },
      { command: "npm run dev", description: "Development mode" }
    ];
  }
  return info;
}
function getScriptDescription(name, script) {
  const descriptions = {
    build: "Build the project",
    test: "Run tests",
    dev: "Start development server",
    start: "Start production server",
    lint: "Run linter",
    typecheck: "Type checking"
  };
  return descriptions[name] || `Run ${name}`;
}
function getDocsPath(projectRoot) {
  const possiblePaths = ["docs", "documentation", "doc"];
  for (const path of possiblePaths) {
    if (existsSync(join(projectRoot, path))) {
      return path;
    }
  }
  return "docs";
}
function getDefaultCodeStyleRules() {
  return [
    { name: "Modular Design", description: "Files under 500 lines" },
    { name: "Environment Safety", description: "Never hardcode secrets" },
    { name: "Test-First", description: "Write tests before implementation" },
    { name: "Clean Architecture", description: "Separate concerns" },
    { name: "Documentation", description: "Keep docs updated" }
  ];
}
function getTemplateContent(templateName, projectRoot) {
  if (templateName === "minimal") {
    return `# {{projectName}}

{{description}}

## Commands

{{#each buildCommands}}
- \`{{this.command}}\` - {{this.description}}
{{/each}}

---
*Generated by @weavelogic/knowledge-graph-agent*
`;
  }
  if (templateName === "full") {
    let content = DEFAULT_TEMPLATE;
    for (const section of Object.values(SECTION_TEMPLATES)) {
      content = content.replace(
        /^## Important Instructions/m,
        `## ${section.title}

${section.content}

## Important Instructions`
      );
    }
    return content;
  }
  if (projectRoot && (templateName.includes("/") || templateName.includes("."))) {
    const validatedPath = validateTemplatePath(projectRoot, templateName);
    if (validatedPath && existsSync(validatedPath)) {
      return readFileSync(validatedPath, "utf-8");
    }
  }
  return DEFAULT_TEMPLATE;
}
export {
  addSection,
  generateClaudeMd,
  getSectionTemplate,
  listSectionTemplates,
  updateClaudeMd
};
//# sourceMappingURL=claude-md.js.map
