{"version":3,"file":"docs-analyzer.js","sources":["../../src/generators/docs-analyzer.ts"],"sourcesContent":["/**\n * Docs Analyzer\n *\n * Advanced documentation analyzer that uses claude-flow to create\n * comprehensive knowledge graph documentation with proper structure,\n * wikilinks, frontmatter, and tags following Obsidian conventions.\n */\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';\nimport { join, basename, dirname, relative, extname } from 'path';\nimport { execSync, spawn } from 'child_process';\nimport fg from 'fast-glob';\nimport matter from 'gray-matter';\nimport type { NodeType, NodeStatus, NodeFrontmatter } from '../core/types.js';\n\n/**\n * Analyzer options\n */\nexport interface AnalyzerOptions {\n  /** Source directory with existing docs */\n  sourceDir: string;\n  /** Target directory (default: docs-nn) */\n  targetDir?: string;\n  /** Project root for path resolution */\n  projectRoot: string;\n  /** Use claude-flow for deep analysis */\n  useClaudeFlow?: boolean;\n  /** Create MOC (Map of Content) files */\n  createMOC?: boolean;\n  /** Link back to original docs */\n  linkOriginal?: boolean;\n  /** Maximum depth for analysis */\n  maxDepth?: number;\n  /** Dry run - show what would be done */\n  dryRun?: boolean;\n  /** Verbose output */\n  verbose?: boolean;\n}\n\n/**\n * Analyzed document\n */\nexport interface AnalyzedDoc {\n  /** Original file path */\n  originalPath: string;\n  /** New file path in docs-nn */\n  newPath: string;\n  /** Document title */\n  title: string;\n  /** Detected node type */\n  type: NodeType;\n  /** Extracted tags */\n  tags: string[];\n  /** Related documents (wikilinks) */\n  related: string[];\n  /** Key concepts extracted */\n  concepts: string[];\n  /** Areas needing research */\n  researchNeeded: string[];\n  /** TODOs found or generated */\n  todos: string[];\n  /** Summary/description */\n  summary: string;\n  /** Category path in structure */\n  category: string;\n}\n\n/**\n * Analyzer result\n */\nexport interface AnalyzerResult {\n  success: boolean;\n  filesAnalyzed: number;\n  filesCreated: number;\n  mocFilesCreated: number;\n  errors: string[];\n  analyzed: AnalyzedDoc[];\n  structure: Map<string, string[]>;\n}\n\n/**\n * Weave-NN category structure with descriptions\n */\nconst CATEGORY_STRUCTURE: Record<string, { type: NodeType; description: string; subcategories: string[] }> = {\n  concepts: {\n    type: 'concept',\n    description: 'Abstract concepts, theories, and architectural principles',\n    subcategories: ['architecture', 'patterns', 'principles', 'models'],\n  },\n  components: {\n    type: 'technical',\n    description: 'Reusable technical components and implementations',\n    subcategories: ['ui', 'utilities', 'core', 'shared'],\n  },\n  services: {\n    type: 'service',\n    description: 'Backend services, APIs, and workers',\n    subcategories: ['api', 'workers', 'handlers', 'middleware'],\n  },\n  features: {\n    type: 'feature',\n    description: 'Product features and capabilities',\n    subcategories: ['core', 'advanced', 'experimental'],\n  },\n  integrations: {\n    type: 'integration',\n    description: 'External integrations and adapters',\n    subcategories: ['databases', 'auth', 'storage', 'monitoring', 'third-party'],\n  },\n  standards: {\n    type: 'standard',\n    description: 'Coding standards, conventions, and best practices',\n    subcategories: ['coding', 'documentation', 'testing', 'security'],\n  },\n  guides: {\n    type: 'guide',\n    description: 'How-to guides and tutorials',\n    subcategories: ['getting-started', 'tutorials', 'troubleshooting', 'deployment'],\n  },\n  references: {\n    type: 'technical',\n    description: 'API references and technical documentation',\n    subcategories: ['api', 'cli', 'config', 'schemas'],\n  },\n};\n\n/**\n * Analyze and migrate documentation to weave-nn structure\n */\nexport async function analyzeDocs(options: AnalyzerOptions): Promise<AnalyzerResult> {\n  const {\n    sourceDir,\n    targetDir = 'docs-nn',\n    projectRoot,\n    useClaudeFlow = false,\n    createMOC = true,\n    linkOriginal = true,\n    maxDepth = 3,\n    dryRun = false,\n    verbose = false,\n  } = options;\n\n  const result: AnalyzerResult = {\n    success: true,\n    filesAnalyzed: 0,\n    filesCreated: 0,\n    mocFilesCreated: 0,\n    errors: [],\n    analyzed: [],\n    structure: new Map(),\n  };\n\n  const sourcePath = join(projectRoot, sourceDir);\n  const targetPath = join(projectRoot, targetDir);\n\n  // Validate source exists\n  if (!existsSync(sourcePath)) {\n    result.success = false;\n    result.errors.push(`Source directory not found: ${sourcePath}`);\n    return result;\n  }\n\n  // Create target structure\n  if (!dryRun) {\n    createFullStructure(targetPath);\n  }\n\n  // Find all markdown files\n  const files = await fg('**/*.md', {\n    cwd: sourcePath,\n    ignore: ['node_modules/**', '.git/**', '_templates/**', 'docs-nn/**'],\n  });\n\n  // First pass: Analyze all documents\n  const analyzedDocs: AnalyzedDoc[] = [];\n\n  for (const file of files) {\n    result.filesAnalyzed++;\n    const sourceFile = join(sourcePath, file);\n\n    try {\n      const analyzed = await analyzeDocument(sourceFile, file, sourcePath, {\n        useClaudeFlow,\n        linkOriginal,\n        verbose,\n      });\n      analyzedDocs.push(analyzed);\n\n      // Track structure\n      const category = analyzed.category.split('/')[0];\n      if (!result.structure.has(category)) {\n        result.structure.set(category, []);\n      }\n      result.structure.get(category)!.push(analyzed.title);\n\n    } catch (error) {\n      result.errors.push(`Failed to analyze ${file}: ${error}`);\n    }\n  }\n\n  // Build cross-references between documents\n  buildCrossReferences(analyzedDocs);\n\n  // Second pass: Create new documents\n  for (const doc of analyzedDocs) {\n    try {\n      const targetFile = join(targetPath, doc.newPath);\n\n      if (!dryRun) {\n        mkdirSync(dirname(targetFile), { recursive: true });\n        const content = generateKnowledgeDoc(doc, sourceDir, linkOriginal, analyzedDocs);\n        writeFileSync(targetFile, content, 'utf-8');\n      }\n\n      result.filesCreated++;\n      result.analyzed.push(doc);\n\n    } catch (error) {\n      result.errors.push(`Failed to create ${doc.newPath}: ${error}`);\n    }\n  }\n\n  // Create MOC files for each category\n  if (createMOC && !dryRun) {\n    for (const [category, docs] of result.structure) {\n      const mocPath = join(targetPath, category, '_MOC.md');\n      const mocContent = generateMOC(category, docs, analyzedDocs);\n      writeFileSync(mocPath, mocContent, 'utf-8');\n      result.mocFilesCreated++;\n    }\n\n    // Create master MOC\n    const masterMocPath = join(targetPath, 'MOC.md');\n    const masterMocContent = generateMasterMOC(result.structure, analyzedDocs);\n    writeFileSync(masterMocPath, masterMocContent, 'utf-8');\n    result.mocFilesCreated++;\n\n    // Create PRIMITIVES.md\n    const primitivesPath = join(targetPath, 'PRIMITIVES.md');\n    const primitivesContent = generatePrimitives(analyzedDocs);\n    writeFileSync(primitivesPath, primitivesContent, 'utf-8');\n  }\n\n  result.success = result.errors.length === 0;\n  return result;\n}\n\n/**\n * Analyze a single document\n */\nasync function analyzeDocument(\n  filePath: string,\n  relativePath: string,\n  sourcePath: string,\n  options: { useClaudeFlow?: boolean; linkOriginal?: boolean; verbose?: boolean }\n): Promise<AnalyzedDoc> {\n  const content = readFileSync(filePath, 'utf-8');\n  const { data: existingFrontmatter, content: body } = matter(content);\n\n  const filename = basename(filePath, '.md');\n  const title = existingFrontmatter.title as string || formatTitle(filename);\n\n  // Detect node type and category\n  const { type, category } = detectTypeAndCategory(relativePath, body, existingFrontmatter);\n\n  // Extract tags\n  const tags = extractAllTags(body, existingFrontmatter, relativePath);\n\n  // Extract wikilinks and markdown links\n  const related = extractLinks(body);\n\n  // Extract key concepts\n  const concepts = extractConcepts(body);\n\n  // Find areas needing research\n  const researchNeeded = findResearchAreas(body, filename);\n\n  // Extract existing TODOs and generate new ones\n  const todos = extractAndGenerateTodos(body, content, filename);\n\n  // Generate summary\n  const summary = generateSummary(body, existingFrontmatter);\n\n  // Determine new path\n  const newPath = join(category, formatFilename(filename) + '.md');\n\n  return {\n    originalPath: relativePath,\n    newPath,\n    title,\n    type,\n    tags,\n    related,\n    concepts,\n    researchNeeded,\n    todos,\n    summary,\n    category,\n  };\n}\n\n/**\n * Create full target directory structure\n */\nfunction createFullStructure(targetPath: string): void {\n  // Create all category directories and subcategories\n  for (const [category, config] of Object.entries(CATEGORY_STRUCTURE)) {\n    mkdirSync(join(targetPath, category), { recursive: true });\n    for (const sub of config.subcategories) {\n      mkdirSync(join(targetPath, category, sub), { recursive: true });\n    }\n  }\n\n  // Create meta directories\n  mkdirSync(join(targetPath, '_templates'), { recursive: true });\n  mkdirSync(join(targetPath, '_attachments'), { recursive: true });\n  mkdirSync(join(targetPath, '_archive'), { recursive: true });\n}\n\n/**\n * Detect node type and category from content\n */\nfunction detectTypeAndCategory(\n  filePath: string,\n  content: string,\n  frontmatter: Record<string, unknown>\n): { type: NodeType; category: string } {\n  // Check frontmatter first\n  if (frontmatter.type && frontmatter.category) {\n    return {\n      type: frontmatter.type as NodeType,\n      category: frontmatter.category as string,\n    };\n  }\n\n  const lowerContent = content.toLowerCase();\n  const lowerPath = filePath.toLowerCase();\n\n  // Score each category\n  const scores: Record<string, number> = {};\n\n  for (const [category, config] of Object.entries(CATEGORY_STRUCTURE)) {\n    scores[category] = 0;\n\n    // Path matching\n    if (lowerPath.includes(category)) scores[category] += 10;\n    for (const sub of config.subcategories) {\n      if (lowerPath.includes(sub)) scores[category] += 5;\n    }\n\n    // Content analysis based on type\n    const keywords = getKeywordsForType(config.type);\n    for (const keyword of keywords) {\n      const regex = new RegExp(`\\\\b${keyword}\\\\b`, 'gi');\n      const matches = content.match(regex);\n      if (matches) scores[category] += matches.length;\n    }\n  }\n\n  // Find best match\n  let bestCategory = 'concepts';\n  let bestScore = 0;\n\n  for (const [category, score] of Object.entries(scores)) {\n    if (score > bestScore) {\n      bestScore = score;\n      bestCategory = category;\n    }\n  }\n\n  return {\n    type: CATEGORY_STRUCTURE[bestCategory].type,\n    category: bestCategory,\n  };\n}\n\n/**\n * Get keywords for a node type\n */\nfunction getKeywordsForType(type: NodeType): string[] {\n  const keywords: Record<NodeType, string[]> = {\n    concept: ['concept', 'theory', 'principle', 'overview', 'introduction', 'architecture', 'design', 'pattern'],\n    technical: ['component', 'implementation', 'class', 'function', 'module', 'utility', 'helper'],\n    feature: ['feature', 'capability', 'functionality', 'user', 'requirement', 'use case'],\n    primitive: ['library', 'framework', 'dependency', 'tool', 'sdk'],\n    service: ['api', 'endpoint', 'service', 'server', 'backend', 'worker', 'handler'],\n    guide: ['how to', 'tutorial', 'guide', 'step', 'walkthrough', 'getting started'],\n    standard: ['standard', 'convention', 'best practice', 'rule', 'guideline', 'style'],\n    integration: ['integration', 'connect', 'plugin', 'adapter', 'sync', 'import', 'export'],\n  };\n\n  return keywords[type] || [];\n}\n\n/**\n * Extract all tags from content and path\n */\nfunction extractAllTags(\n  content: string,\n  frontmatter: Record<string, unknown>,\n  filePath: string\n): string[] {\n  const tags = new Set<string>();\n\n  // Add existing frontmatter tags\n  if (Array.isArray(frontmatter.tags)) {\n    frontmatter.tags.forEach(t => tags.add(String(t)));\n  }\n\n  // Extract #tags from content\n  const hashTags = content.match(/#[\\w-]+/g);\n  if (hashTags) {\n    hashTags.forEach(t => tags.add(t.slice(1)));\n  }\n\n  // Generate tags from path\n  const pathParts = filePath.split('/').filter(p => p && !p.endsWith('.md'));\n  pathParts.forEach(p => {\n    if (p.length > 2 && p.length < 20) {\n      tags.add(p.replace(/[-_]/g, '-').toLowerCase());\n    }\n  });\n\n  // Add status tags\n  if (content.match(/\\b(wip|draft|todo)\\b/i)) tags.add('needs-work');\n  if (content.match(/\\b(deprecated|legacy)\\b/i)) tags.add('deprecated');\n  if (content.match(/\\b(experimental|beta)\\b/i)) tags.add('experimental');\n\n  return [...tags].slice(0, 15);\n}\n\n/**\n * Extract wikilinks and markdown links\n */\nfunction extractLinks(content: string): string[] {\n  const links = new Set<string>();\n\n  // Wikilinks\n  const wikilinks = content.match(/\\[\\[([^\\]|]+)(?:\\|[^\\]]+)?\\]\\]/g);\n  if (wikilinks) {\n    wikilinks.forEach(link => {\n      const match = link.match(/\\[\\[([^\\]|]+)/);\n      if (match) links.add(match[1].trim());\n    });\n  }\n\n  // Markdown links (internal only)\n  const mdLinks = content.match(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g);\n  if (mdLinks) {\n    mdLinks.forEach(link => {\n      const match = link.match(/\\]\\(([^)]+)\\)/);\n      if (match && !match[1].startsWith('http')) {\n        links.add(match[1].replace(/\\.md$/, '').trim());\n      }\n    });\n  }\n\n  return [...links];\n}\n\n/**\n * Extract key concepts from content\n */\nfunction extractConcepts(content: string): string[] {\n  const concepts: string[] = [];\n\n  // Look for headers as concepts\n  const headers = content.match(/^##\\s+(.+)$/gm);\n  if (headers) {\n    headers.slice(0, 5).forEach(h => {\n      concepts.push(h.replace(/^##\\s+/, '').trim());\n    });\n  }\n\n  // Look for bold terms as concepts\n  const boldTerms = content.match(/\\*\\*([^*]+)\\*\\*/g);\n  if (boldTerms) {\n    boldTerms.slice(0, 5).forEach(term => {\n      const clean = term.replace(/\\*\\*/g, '').trim();\n      if (clean.length > 2 && clean.length < 50) {\n        concepts.push(clean);\n      }\n    });\n  }\n\n  return [...new Set(concepts)].slice(0, 10);\n}\n\n/**\n * Find areas needing research\n */\nfunction findResearchAreas(content: string, filename: string): string[] {\n  const areas: string[] = [];\n\n  // Look for question marks indicating uncertainty\n  const questions = content.match(/[^.!?]*\\?/g);\n  if (questions) {\n    questions.slice(0, 3).forEach(q => {\n      if (q.length > 10 && q.length < 200) {\n        areas.push(q.trim());\n      }\n    });\n  }\n\n  // Look for placeholders\n  if (content.match(/\\bTBD\\b|\\bTODO\\b|\\bFIXME\\b/i)) {\n    areas.push('Contains placeholders that need completion');\n  }\n\n  // Look for empty sections\n  const emptyHeaders = content.match(/^##[^#\\n]+\\n\\n##/gm);\n  if (emptyHeaders) {\n    areas.push('Has empty sections that need content');\n  }\n\n  // Check for missing content indicators\n  if (content.length < 500) {\n    areas.push('Document is short - may need expansion');\n  }\n\n  return areas;\n}\n\n/**\n * Extract and generate TODOs\n */\nfunction extractAndGenerateTodos(body: string, fullContent: string, filename: string): string[] {\n  const todos: string[] = [];\n\n  // Extract existing TODOs\n  const existingTodos = fullContent.match(/[-*]\\s*\\[[ x]\\]\\s*(.+)/g);\n  if (existingTodos) {\n    existingTodos.forEach(todo => {\n      todos.push(todo.replace(/^[-*]\\s*\\[[ x]\\]\\s*/, '').trim());\n    });\n  }\n\n  // Extract TODO comments\n  const todoComments = fullContent.match(/(?:TODO|FIXME|XXX):\\s*(.+)/gi);\n  if (todoComments) {\n    todoComments.forEach(todo => {\n      todos.push(todo.replace(/^(?:TODO|FIXME|XXX):\\s*/i, '').trim());\n    });\n  }\n\n  // Generate suggested TODOs based on analysis\n  if (!fullContent.match(/^---[\\s\\S]*?---/)) {\n    todos.push('Add proper frontmatter');\n  }\n\n  if (!fullContent.match(/\\[\\[/)) {\n    todos.push('Add wikilinks to related documents');\n  }\n\n  if (!fullContent.match(/^##\\s/m)) {\n    todos.push('Add section structure with headers');\n  }\n\n  return [...new Set(todos)].slice(0, 10);\n}\n\n/**\n * Generate summary from content\n */\nfunction generateSummary(body: string, frontmatter: Record<string, unknown>): string {\n  // Use existing description\n  if (frontmatter.description) {\n    return String(frontmatter.description);\n  }\n\n  // Extract first meaningful paragraph\n  const lines = body.split('\\n');\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (trimmed && !trimmed.startsWith('#') && !trimmed.startsWith('```') && trimmed.length > 30) {\n      return trimmed.length > 200 ? trimmed.slice(0, 197) + '...' : trimmed;\n    }\n  }\n\n  return 'Documentation requiring summary.';\n}\n\n/**\n * Build cross-references between documents\n */\nfunction buildCrossReferences(docs: AnalyzedDoc[]): void {\n  const titleMap = new Map<string, AnalyzedDoc>();\n\n  // Build title lookup\n  docs.forEach(doc => {\n    titleMap.set(doc.title.toLowerCase(), doc);\n    titleMap.set(formatFilename(doc.title), doc);\n  });\n\n  // Update related links\n  docs.forEach(doc => {\n    const newRelated: string[] = [];\n\n    doc.related.forEach(link => {\n      const linkedDoc = titleMap.get(link.toLowerCase()) || titleMap.get(formatFilename(link));\n      if (linkedDoc) {\n        newRelated.push(linkedDoc.title);\n      } else {\n        newRelated.push(link);\n      }\n    });\n\n    // Find related docs by shared tags\n    const sharedTagDocs = docs.filter(other =>\n      other !== doc &&\n      other.tags.some(t => doc.tags.includes(t))\n    );\n\n    sharedTagDocs.slice(0, 3).forEach(other => {\n      if (!newRelated.includes(other.title)) {\n        newRelated.push(other.title);\n      }\n    });\n\n    doc.related = [...new Set(newRelated)].slice(0, 10);\n  });\n}\n\n/**\n * Generate knowledge document content\n */\nfunction generateKnowledgeDoc(\n  doc: AnalyzedDoc,\n  sourceDir: string,\n  linkOriginal: boolean,\n  allDocs: AnalyzedDoc[]\n): string {\n  const lines: string[] = [];\n\n  // Frontmatter\n  lines.push('---');\n  lines.push(`title: \"${doc.title}\"`);\n  lines.push(`type: ${doc.type}`);\n  lines.push(`status: active`);\n  if (doc.tags.length > 0) {\n    lines.push('tags:');\n    doc.tags.forEach(tag => lines.push(`  - ${tag}`));\n  }\n  lines.push(`category: ${doc.category}`);\n  lines.push(`description: \"${doc.summary.replace(/\"/g, '\\\\\"')}\"`);\n  lines.push(`created: ${new Date().toISOString().split('T')[0]}`);\n  lines.push(`updated: ${new Date().toISOString().split('T')[0]}`);\n  if (linkOriginal) {\n    lines.push(`original: \"${sourceDir}/${doc.originalPath}\"`);\n  }\n  if (doc.related.length > 0) {\n    lines.push('related:');\n    doc.related.slice(0, 5).forEach(r => lines.push(`  - \"[[${r}]]\"`));\n  }\n  lines.push('---');\n  lines.push('');\n\n  // Title\n  lines.push(`# ${doc.title}`);\n  lines.push('');\n\n  // Summary\n  lines.push('## Overview');\n  lines.push('');\n  lines.push(doc.summary);\n  lines.push('');\n\n  // Original reference\n  if (linkOriginal) {\n    lines.push(`> [!info] Original Documentation`);\n    lines.push(`> See [[${sourceDir}/${doc.originalPath}|original document]] for full details.`);\n    lines.push('');\n  }\n\n  // Key concepts\n  if (doc.concepts.length > 0) {\n    lines.push('## Key Concepts');\n    lines.push('');\n    doc.concepts.forEach(concept => {\n      lines.push(`- **${concept}**`);\n    });\n    lines.push('');\n  }\n\n  // Related documents\n  if (doc.related.length > 0) {\n    lines.push('## Related');\n    lines.push('');\n    doc.related.forEach(rel => {\n      lines.push(`- [[${rel}]]`);\n    });\n    lines.push('');\n  }\n\n  // Research needed\n  if (doc.researchNeeded.length > 0) {\n    lines.push('## Research Needed');\n    lines.push('');\n    lines.push('> [!warning] Areas Requiring Further Research');\n    doc.researchNeeded.forEach(area => {\n      lines.push(`> - ${area}`);\n    });\n    lines.push('');\n  }\n\n  // TODOs\n  if (doc.todos.length > 0) {\n    lines.push('## TODOs');\n    lines.push('');\n    doc.todos.forEach(todo => {\n      lines.push(`- [ ] ${todo}`);\n    });\n    lines.push('');\n  }\n\n  // Tags section\n  lines.push('## Tags');\n  lines.push('');\n  lines.push(doc.tags.map(t => `#${t}`).join(' '));\n  lines.push('');\n\n  return lines.join('\\n');\n}\n\n/**\n * Generate MOC (Map of Content) for a category\n */\nfunction generateMOC(category: string, docTitles: string[], allDocs: AnalyzedDoc[]): string {\n  const config = CATEGORY_STRUCTURE[category];\n  const categoryDocs = allDocs.filter(d => d.category.startsWith(category));\n\n  const lines: string[] = [];\n\n  lines.push('---');\n  lines.push(`title: \"${formatTitle(category)} - Map of Content\"`);\n  lines.push('type: concept');\n  lines.push('status: active');\n  lines.push('tags:');\n  lines.push('  - moc');\n  lines.push(`  - ${category}`);\n  lines.push(`created: ${new Date().toISOString().split('T')[0]}`);\n  lines.push('---');\n  lines.push('');\n  lines.push(`# ${formatTitle(category)}`);\n  lines.push('');\n  lines.push(config?.description || `Documentation related to ${category}.`);\n  lines.push('');\n\n  // Group by subcategory\n  const bySubcategory = new Map<string, AnalyzedDoc[]>();\n  categoryDocs.forEach(doc => {\n    const parts = doc.category.split('/');\n    const sub = parts[1] || 'general';\n    if (!bySubcategory.has(sub)) {\n      bySubcategory.set(sub, []);\n    }\n    bySubcategory.get(sub)!.push(doc);\n  });\n\n  for (const [sub, docs] of bySubcategory) {\n    lines.push(`## ${formatTitle(sub)}`);\n    lines.push('');\n    docs.forEach(doc => {\n      lines.push(`- [[${doc.title}]] - ${doc.summary.slice(0, 60)}...`);\n    });\n    lines.push('');\n  }\n\n  lines.push('---');\n  lines.push(`*${categoryDocs.length} documents in this category*`);\n\n  return lines.join('\\n');\n}\n\n/**\n * Generate master MOC\n */\nfunction generateMasterMOC(structure: Map<string, string[]>, allDocs: AnalyzedDoc[]): string {\n  const lines: string[] = [];\n\n  lines.push('---');\n  lines.push('title: \"Knowledge Graph - Master Index\"');\n  lines.push('type: concept');\n  lines.push('status: active');\n  lines.push('tags:');\n  lines.push('  - moc');\n  lines.push('  - index');\n  lines.push('  - knowledge-graph');\n  lines.push(`created: ${new Date().toISOString().split('T')[0]}`);\n  lines.push('---');\n  lines.push('');\n  lines.push('# Knowledge Graph');\n  lines.push('');\n  lines.push('Welcome to the knowledge graph. This is the master index of all documentation.');\n  lines.push('');\n  lines.push('## Categories');\n  lines.push('');\n\n  for (const [category, config] of Object.entries(CATEGORY_STRUCTURE)) {\n    const count = structure.get(category)?.length || 0;\n    lines.push(`### [[${category}/_MOC|${formatTitle(category)}]]`);\n    lines.push('');\n    lines.push(`${config.description}`);\n    lines.push(`*${count} documents*`);\n    lines.push('');\n  }\n\n  lines.push('## Quick Links');\n  lines.push('');\n  lines.push('- [[PRIMITIVES]] - Core building blocks and technologies');\n  lines.push('- [[guides/_MOC|Getting Started]]');\n  lines.push('- [[standards/_MOC|Coding Standards]]');\n  lines.push('');\n\n  lines.push('## Statistics');\n  lines.push('');\n  lines.push(`- **Total Documents**: ${allDocs.length}`);\n  lines.push(`- **Categories**: ${structure.size}`);\n  lines.push(`- **Generated**: ${new Date().toISOString()}`);\n  lines.push('');\n\n  return lines.join('\\n');\n}\n\n/**\n * Generate PRIMITIVES.md\n */\nfunction generatePrimitives(allDocs: AnalyzedDoc[]): string {\n  const lines: string[] = [];\n\n  lines.push('---');\n  lines.push('title: \"Primitives\"');\n  lines.push('type: primitive');\n  lines.push('status: active');\n  lines.push('tags:');\n  lines.push('  - primitives');\n  lines.push('  - foundation');\n  lines.push('  - knowledge-graph');\n  lines.push(`created: ${new Date().toISOString().split('T')[0]}`);\n  lines.push('---');\n  lines.push('');\n  lines.push('# Primitives');\n  lines.push('');\n  lines.push('Core building blocks and foundational technologies used in this project.');\n  lines.push('');\n\n  // Group docs by type\n  const byType = new Map<NodeType, AnalyzedDoc[]>();\n  allDocs.forEach(doc => {\n    if (!byType.has(doc.type)) {\n      byType.set(doc.type, []);\n    }\n    byType.get(doc.type)!.push(doc);\n  });\n\n  for (const [type, docs] of byType) {\n    lines.push(`## ${formatTitle(type)}`);\n    lines.push('');\n    docs.slice(0, 10).forEach(doc => {\n      lines.push(`- [[${doc.title}]]`);\n    });\n    if (docs.length > 10) {\n      lines.push(`- *...and ${docs.length - 10} more*`);\n    }\n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Format filename from title\n */\nfunction formatFilename(title: string): string {\n  return title\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-|-$/g, '')\n    .slice(0, 50);\n}\n\n/**\n * Format title from filename\n */\nfunction formatTitle(filename: string): string {\n  return filename\n    .replace(/[-_]/g, ' ')\n    .replace(/\\b\\w/g, c => c.toUpperCase())\n    .trim();\n}\n"],"names":[],"mappings":"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"}