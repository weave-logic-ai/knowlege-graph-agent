{"version":3,"file":"docs-convert.js","sources":["../../src/generators/docs-convert.ts"],"sourcesContent":["/**\n * Docs Converter\n *\n * Converts existing documentation to weave-nn structure with proper\n * frontmatter and directory organization.\n */\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync, copyFileSync } from 'fs';\nimport { join, basename, dirname, relative, extname } from 'path';\nimport fg from 'fast-glob';\nimport matter from 'gray-matter';\nimport type { NodeType, NodeStatus, NodeFrontmatter } from '../core/types.js';\n\n/**\n * Conversion options\n */\nexport interface ConvertOptions {\n  /** Source directory with existing docs */\n  sourceDir: string;\n  /** Target directory (default: docs-nn) */\n  targetDir?: string;\n  /** Project root for path resolution */\n  projectRoot: string;\n  /** Preserve original files (copy instead of move) */\n  preserveOriginal?: boolean;\n  /** Overwrite existing files in target */\n  force?: boolean;\n  /** Auto-categorize based on content analysis */\n  autoCategory?: boolean;\n  /** Dry run - show what would be done */\n  dryRun?: boolean;\n}\n\n/**\n * Frontmatter options\n */\nexport interface FrontmatterOptions {\n  /** Target file or directory */\n  target: string;\n  /** Project root */\n  projectRoot: string;\n  /** Override type detection */\n  type?: NodeType;\n  /** Override status */\n  status?: NodeStatus;\n  /** Additional tags to add */\n  tags?: string[];\n  /** Force overwrite existing frontmatter */\n  force?: boolean;\n  /** Dry run */\n  dryRun?: boolean;\n}\n\n/**\n * Conversion result\n */\nexport interface ConvertResult {\n  success: boolean;\n  filesProcessed: number;\n  filesConverted: number;\n  filesSkipped: number;\n  errors: string[];\n  converted: Array<{\n    source: string;\n    target: string;\n    type: NodeType;\n  }>;\n}\n\n/**\n * Frontmatter result\n */\nexport interface FrontmatterResult {\n  success: boolean;\n  filesProcessed: number;\n  filesUpdated: number;\n  filesSkipped: number;\n  errors: string[];\n}\n\n/**\n * Weave-NN directory structure mapping\n */\nconst CATEGORY_DIRS: Record<NodeType, string> = {\n  concept: 'concepts',\n  technical: 'components',\n  feature: 'features',\n  primitive: 'integrations',\n  service: 'services',\n  guide: 'guides',\n  standard: 'standards',\n  integration: 'integrations',\n};\n\n/**\n * Keywords for content-based categorization\n */\nconst CATEGORY_KEYWORDS: Record<NodeType, string[]> = {\n  concept: [\n    'overview', 'introduction', 'theory', 'principle', 'concept',\n    'philosophy', 'approach', 'methodology', 'paradigm', 'model',\n  ],\n  technical: [\n    'component', 'implementation', 'class', 'function', 'module',\n    'algorithm', 'data structure', 'interface', 'abstract', 'utility',\n  ],\n  feature: [\n    'feature', 'capability', 'functionality', 'use case', 'user story',\n    'requirement', 'specification', 'product', 'roadmap',\n  ],\n  primitive: [\n    'library', 'framework', 'dependency', 'package', 'tool',\n    'sdk', 'runtime', 'platform', 'language',\n  ],\n  service: [\n    'api', 'endpoint', 'service', 'server', 'backend', 'microservice',\n    'rest', 'graphql', 'webhook', 'worker', 'queue',\n  ],\n  guide: [\n    'how to', 'tutorial', 'guide', 'walkthrough', 'step by step',\n    'getting started', 'setup', 'installation', 'configuration',\n  ],\n  standard: [\n    'standard', 'convention', 'best practice', 'rule', 'policy',\n    'guideline', 'coding style', 'lint', 'format',\n  ],\n  integration: [\n    'integration', 'connect', 'plugin', 'adapter', 'bridge',\n    'sync', 'import', 'export', 'webhook',\n  ],\n};\n\n/**\n * Path-based categorization patterns\n */\nconst PATH_PATTERNS: Array<{ pattern: RegExp; type: NodeType }> = [\n  { pattern: /\\/(api|endpoints?|routes?)\\//i, type: 'service' },\n  { pattern: /\\/(guide|tutorial|howto|getting-started)\\//i, type: 'guide' },\n  { pattern: /\\/(component|ui|widget)\\//i, type: 'technical' },\n  { pattern: /\\/(feature|capability)\\//i, type: 'feature' },\n  { pattern: /\\/(standard|convention|style)\\//i, type: 'standard' },\n  { pattern: /\\/(integration|plugin|adapter)\\//i, type: 'integration' },\n  { pattern: /\\/(service|worker|job)\\//i, type: 'service' },\n  { pattern: /\\/(concept|architecture|design)\\//i, type: 'concept' },\n];\n\n/**\n * Convert existing docs to weave-nn structure\n */\nexport async function convertDocs(options: ConvertOptions): Promise<ConvertResult> {\n  const {\n    sourceDir,\n    targetDir = 'docs-nn',\n    projectRoot,\n    preserveOriginal = true,\n    force = false,\n    autoCategory = true,\n    dryRun = false,\n  } = options;\n\n  const result: ConvertResult = {\n    success: true,\n    filesProcessed: 0,\n    filesConverted: 0,\n    filesSkipped: 0,\n    errors: [],\n    converted: [],\n  };\n\n  const sourcePath = join(projectRoot, sourceDir);\n  const targetPath = join(projectRoot, targetDir);\n\n  // Validate source exists\n  if (!existsSync(sourcePath)) {\n    result.success = false;\n    result.errors.push(`Source directory not found: ${sourcePath}`);\n    return result;\n  }\n\n  // Create target structure\n  if (!dryRun) {\n    createTargetStructure(targetPath);\n  }\n\n  // Find all markdown files\n  const files = await fg('**/*.md', {\n    cwd: sourcePath,\n    ignore: ['node_modules/**', '.git/**', '_templates/**'],\n  });\n\n  for (const file of files) {\n    result.filesProcessed++;\n    const sourceFile = join(sourcePath, file);\n\n    try {\n      // Read and parse file\n      const content = readFileSync(sourceFile, 'utf-8');\n      const { data: existingFrontmatter, content: body } = matter(content);\n\n      // Determine node type\n      const nodeType = autoCategory\n        ? detectNodeType(file, body, existingFrontmatter)\n        : (existingFrontmatter.type as NodeType) || 'concept';\n\n      // Determine target path\n      const targetSubdir = CATEGORY_DIRS[nodeType];\n      const targetFile = join(targetPath, targetSubdir, basename(file));\n\n      // Check if target exists\n      if (existsSync(targetFile) && !force) {\n        result.filesSkipped++;\n        continue;\n      }\n\n      // Generate frontmatter\n      const frontmatter = generateFrontmatter(file, body, nodeType, existingFrontmatter);\n\n      // Build new content\n      const newContent = buildMarkdownWithFrontmatter(frontmatter, body);\n\n      if (!dryRun) {\n        // Ensure directory exists\n        mkdirSync(dirname(targetFile), { recursive: true });\n\n        // Write converted file\n        writeFileSync(targetFile, newContent, 'utf-8');\n      }\n\n      result.filesConverted++;\n      result.converted.push({\n        source: file,\n        target: relative(projectRoot, targetFile),\n        type: nodeType,\n      });\n\n    } catch (error) {\n      result.errors.push(`Failed to convert ${file}: ${error}`);\n    }\n  }\n\n  result.success = result.errors.length === 0;\n  return result;\n}\n\n/**\n * Add or update frontmatter in existing files\n */\nexport async function addFrontmatter(options: FrontmatterOptions): Promise<FrontmatterResult> {\n  const {\n    target,\n    projectRoot,\n    type,\n    status = 'active',\n    tags = [],\n    force = false,\n    dryRun = false,\n  } = options;\n\n  const result: FrontmatterResult = {\n    success: true,\n    filesProcessed: 0,\n    filesUpdated: 0,\n    filesSkipped: 0,\n    errors: [],\n  };\n\n  const targetPath = join(projectRoot, target);\n\n  // Handle single file or directory\n  let files: string[];\n  if (existsSync(targetPath) && !targetPath.endsWith('.md')) {\n    // Directory - find all markdown files\n    files = await fg('**/*.md', {\n      cwd: targetPath,\n      ignore: ['node_modules/**', '.git/**', '_templates/**'],\n      absolute: true,\n    });\n  } else if (existsSync(targetPath)) {\n    files = [targetPath];\n  } else {\n    result.success = false;\n    result.errors.push(`Target not found: ${targetPath}`);\n    return result;\n  }\n\n  for (const file of files) {\n    result.filesProcessed++;\n\n    try {\n      const content = readFileSync(file, 'utf-8');\n      const { data: existingFrontmatter, content: body } = matter(content);\n\n      // Skip if has frontmatter and not forcing\n      if (Object.keys(existingFrontmatter).length > 0 && !force) {\n        result.filesSkipped++;\n        continue;\n      }\n\n      // Detect type if not specified\n      const relPath = relative(projectRoot, file);\n      const nodeType = type || detectNodeType(relPath, body, existingFrontmatter);\n\n      // Generate frontmatter\n      const frontmatter = generateFrontmatter(\n        relPath,\n        body,\n        nodeType,\n        force ? {} : existingFrontmatter,\n        status,\n        tags\n      );\n\n      // Build new content\n      const newContent = buildMarkdownWithFrontmatter(frontmatter, body);\n\n      if (!dryRun) {\n        writeFileSync(file, newContent, 'utf-8');\n      }\n\n      result.filesUpdated++;\n\n    } catch (error) {\n      result.errors.push(`Failed to update ${file}: ${error}`);\n    }\n  }\n\n  result.success = result.errors.length === 0;\n  return result;\n}\n\n/**\n * Validate frontmatter in files\n */\nexport async function validateFrontmatter(\n  target: string,\n  projectRoot: string\n): Promise<{\n  valid: number;\n  invalid: number;\n  missing: number;\n  issues: Array<{ file: string; issues: string[] }>;\n}> {\n  const result = {\n    valid: 0,\n    invalid: 0,\n    missing: 0,\n    issues: [] as Array<{ file: string; issues: string[] }>,\n  };\n\n  const targetPath = join(projectRoot, target);\n\n  const files = await fg('**/*.md', {\n    cwd: targetPath,\n    ignore: ['node_modules/**', '.git/**', '_templates/**'],\n    absolute: true,\n  });\n\n  const validTypes: NodeType[] = [\n    'concept', 'technical', 'feature', 'primitive',\n    'service', 'guide', 'standard', 'integration',\n  ];\n\n  const validStatuses: NodeStatus[] = ['draft', 'active', 'deprecated', 'archived'];\n\n  for (const file of files) {\n    const content = readFileSync(file, 'utf-8');\n    const { data: frontmatter } = matter(content);\n    const fileIssues: string[] = [];\n\n    if (Object.keys(frontmatter).length === 0) {\n      result.missing++;\n      fileIssues.push('Missing frontmatter');\n    } else {\n      // Check required fields\n      if (!frontmatter.title) {\n        fileIssues.push('Missing title');\n      }\n      if (!frontmatter.type) {\n        fileIssues.push('Missing type');\n      } else if (!validTypes.includes(frontmatter.type)) {\n        fileIssues.push(`Invalid type: ${frontmatter.type}`);\n      }\n      if (frontmatter.status && !validStatuses.includes(frontmatter.status)) {\n        fileIssues.push(`Invalid status: ${frontmatter.status}`);\n      }\n      if (!frontmatter.created) {\n        fileIssues.push('Missing created date');\n      }\n    }\n\n    if (fileIssues.length > 0) {\n      result.invalid++;\n      result.issues.push({\n        file: relative(projectRoot, file),\n        issues: fileIssues,\n      });\n    } else if (Object.keys(frontmatter).length > 0) {\n      result.valid++;\n    }\n  }\n\n  return result;\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Create target directory structure\n */\nfunction createTargetStructure(targetPath: string): void {\n  const dirs = [\n    '',\n    'concepts',\n    'concepts/architecture',\n    'concepts/patterns',\n    'components',\n    'components/ui',\n    'components/utilities',\n    'services',\n    'services/api',\n    'services/workers',\n    'features',\n    'features/core',\n    'features/advanced',\n    'integrations',\n    'integrations/databases',\n    'integrations/auth',\n    'standards',\n    'standards/coding',\n    'standards/documentation',\n    'guides',\n    'guides/getting-started',\n    'guides/tutorials',\n    'references',\n    'references/api',\n    '_templates',\n    '_attachments',\n  ];\n\n  for (const dir of dirs) {\n    const fullPath = join(targetPath, dir);\n    if (!existsSync(fullPath)) {\n      mkdirSync(fullPath, { recursive: true });\n    }\n  }\n}\n\n/**\n * Detect node type from file path and content\n */\nfunction detectNodeType(\n  filePath: string,\n  content: string,\n  existingFrontmatter: Record<string, unknown>\n): NodeType {\n  // Use existing type if valid\n  const validTypes: NodeType[] = [\n    'concept', 'technical', 'feature', 'primitive',\n    'service', 'guide', 'standard', 'integration',\n  ];\n\n  if (existingFrontmatter.type && validTypes.includes(existingFrontmatter.type as NodeType)) {\n    return existingFrontmatter.type as NodeType;\n  }\n\n  // Check path patterns\n  for (const { pattern, type } of PATH_PATTERNS) {\n    if (pattern.test(filePath)) {\n      return type;\n    }\n  }\n\n  // Analyze content\n  const lowerContent = content.toLowerCase();\n  const scores: Record<NodeType, number> = {\n    concept: 0,\n    technical: 0,\n    feature: 0,\n    primitive: 0,\n    service: 0,\n    guide: 0,\n    standard: 0,\n    integration: 0,\n  };\n\n  for (const [nodeType, keywords] of Object.entries(CATEGORY_KEYWORDS)) {\n    for (const keyword of keywords) {\n      const regex = new RegExp(`\\\\b${keyword}\\\\b`, 'gi');\n      const matches = lowerContent.match(regex);\n      if (matches) {\n        scores[nodeType as NodeType] += matches.length;\n      }\n    }\n  }\n\n  // Find highest scoring type\n  let maxScore = 0;\n  let detectedType: NodeType = 'concept';\n\n  for (const [nodeType, score] of Object.entries(scores)) {\n    if (score > maxScore) {\n      maxScore = score;\n      detectedType = nodeType as NodeType;\n    }\n  }\n\n  return detectedType;\n}\n\n/**\n * Generate frontmatter for a file\n */\nfunction generateFrontmatter(\n  filePath: string,\n  content: string,\n  nodeType: NodeType,\n  existing: Record<string, unknown> = {},\n  status: NodeStatus = 'active',\n  additionalTags: string[] = []\n): NodeFrontmatter {\n  const filename = basename(filePath, '.md');\n  const title = existing.title as string || formatTitle(filename);\n\n  // Extract tags from content\n  const extractedTags = extractTags(content);\n  const allTags = [...new Set([\n    ...(existing.tags as string[] || []),\n    ...extractedTags,\n    ...additionalTags,\n  ])];\n\n  // Get dates\n  const now = new Date().toISOString().split('T')[0];\n  const created = existing.created as string || now;\n\n  return {\n    title,\n    type: nodeType,\n    status: existing.status as NodeStatus || status,\n    tags: allTags.length > 0 ? allTags : undefined,\n    category: existing.category as string || undefined,\n    description: existing.description as string || extractDescription(content),\n    created,\n    updated: now,\n    aliases: existing.aliases as string[] || undefined,\n    related: existing.related as string[] || undefined,\n  };\n}\n\n/**\n * Format filename as title\n */\nfunction formatTitle(filename: string): string {\n  return filename\n    .replace(/[-_]/g, ' ')\n    .replace(/\\b\\w/g, c => c.toUpperCase())\n    .trim();\n}\n\n/**\n * Extract tags from content\n */\nfunction extractTags(content: string): string[] {\n  const tags: string[] = [];\n\n  // Look for #tags in content\n  const tagMatches = content.match(/#[\\w-]+/g);\n  if (tagMatches) {\n    tags.push(...tagMatches.map(t => t.slice(1)));\n  }\n\n  return tags.slice(0, 10); // Limit to 10 tags\n}\n\n/**\n * Extract description from first paragraph\n */\nfunction extractDescription(content: string): string | undefined {\n  // Skip headers and find first paragraph\n  const lines = content.split('\\n');\n  let description = '';\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (trimmed && !trimmed.startsWith('#') && !trimmed.startsWith('```')) {\n      description = trimmed;\n      break;\n    }\n  }\n\n  if (description.length > 200) {\n    description = description.slice(0, 197) + '...';\n  }\n\n  return description || undefined;\n}\n\n/**\n * Build markdown content with frontmatter\n */\nfunction buildMarkdownWithFrontmatter(\n  frontmatter: NodeFrontmatter,\n  content: string\n): string {\n  // Clean undefined values\n  const cleanFrontmatter: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(frontmatter)) {\n    if (value !== undefined) {\n      cleanFrontmatter[key] = value;\n    }\n  }\n\n  // Build YAML frontmatter\n  const yamlLines = ['---'];\n\n  // Order: title, type, status, tags, description, dates, others\n  const orderedKeys = ['title', 'type', 'status', 'tags', 'category', 'description', 'created', 'updated', 'aliases', 'related'];\n\n  for (const key of orderedKeys) {\n    if (cleanFrontmatter[key] !== undefined) {\n      yamlLines.push(formatYamlLine(key, cleanFrontmatter[key]));\n    }\n  }\n\n  yamlLines.push('---');\n  yamlLines.push('');\n\n  return yamlLines.join('\\n') + content.trim() + '\\n';\n}\n\n/**\n * Format a YAML line\n */\nfunction formatYamlLine(key: string, value: unknown): string {\n  if (Array.isArray(value)) {\n    if (value.length === 0) return '';\n    return `${key}:\\n${value.map(v => `  - ${v}`).join('\\n')}`;\n  }\n  if (typeof value === 'string' && (value.includes(':') || value.includes('#'))) {\n    return `${key}: \"${value}\"`;\n  }\n  return `${key}: ${value}`;\n}\n"],"names":[],"mappings":"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"}