{"version":3,"file":"graph-generator.js","sources":["../../src/generators/graph-generator.ts"],"sourcesContent":["/**\n * Knowledge Graph Generator\n *\n * Scans documentation and generates a knowledge graph from markdown files.\n */\n\nimport { readFileSync, statSync } from 'fs';\nimport { join, basename, relative, extname } from 'path';\nimport fg from 'fast-glob';\nimport matter from 'gray-matter';\nimport type {\n  KnowledgeNode,\n  NodeType,\n  NodeStatus,\n  NodeLink,\n  NodeFrontmatter,\n  GeneratorOptions,\n  GeneratedDocument,\n} from '../core/types.js';\nimport { KnowledgeGraphManager } from '../core/graph.js';\nimport { KnowledgeGraphDatabase } from '../core/database.js';\n\n/**\n * Link extraction patterns\n */\nconst WIKILINK_PATTERN = /\\[\\[([^\\]|]+)(?:\\|([^\\]]+))?\\]\\]/g;\nconst MARKDOWN_LINK_PATTERN = /\\[([^\\]]+)\\]\\(([^)]+)\\)/g;\n\n/**\n * Generate knowledge graph from docs directory\n */\nexport async function generateGraph(options: GeneratorOptions): Promise<{\n  graph: KnowledgeGraphManager;\n  stats: {\n    filesScanned: number;\n    nodesCreated: number;\n    edgesCreated: number;\n    errors: string[];\n  };\n}> {\n  const { projectRoot, outputPath } = options;\n\n  const stats = {\n    filesScanned: 0,\n    nodesCreated: 0,\n    edgesCreated: 0,\n    errors: [] as string[],\n  };\n\n  // Create graph manager\n  const graph = new KnowledgeGraphManager(\n    basename(projectRoot),\n    projectRoot\n  );\n\n  // Find all markdown files\n  const files = await fg('**/*.md', {\n    cwd: outputPath,\n    ignore: ['node_modules/**', '.git/**', '_templates/**'],\n    absolute: true,\n  });\n\n  stats.filesScanned = files.length;\n\n  // First pass: Create all nodes\n  const nodeMap = new Map<string, KnowledgeNode>();\n\n  for (const filePath of files) {\n    try {\n      const node = await parseMarkdownFile(filePath, outputPath);\n      nodeMap.set(node.id, node);\n      stats.nodesCreated++;\n    } catch (error) {\n      stats.errors.push(`Failed to parse ${filePath}: ${error}`);\n    }\n  }\n\n  // Second pass: Resolve links and add to graph\n  for (const node of nodeMap.values()) {\n    // Resolve outgoing links\n    const resolvedLinks: NodeLink[] = [];\n\n    for (const link of node.outgoingLinks) {\n      // Try to resolve the link target\n      const targetId = resolveLink(link.target, node.path, nodeMap);\n\n      if (targetId) {\n        resolvedLinks.push({\n          ...link,\n          target: targetId,\n        });\n\n        // Create backlink in target node\n        const targetNode = nodeMap.get(targetId);\n        if (targetNode) {\n          targetNode.incomingLinks.push({\n            target: node.id,\n            type: 'backlink',\n            text: node.title,\n          });\n        }\n\n        stats.edgesCreated++;\n      }\n    }\n\n    node.outgoingLinks = resolvedLinks;\n    graph.addNode(node);\n  }\n\n  return { graph, stats };\n}\n\n/**\n * Generate graph and save to database\n */\nexport async function generateAndSave(\n  options: GeneratorOptions,\n  dbPath: string\n): Promise<{\n  success: boolean;\n  stats: {\n    filesScanned: number;\n    nodesCreated: number;\n    edgesCreated: number;\n    errors: string[];\n  };\n}> {\n  const { graph, stats } = await generateGraph(options);\n\n  // Save to database\n  const db = new KnowledgeGraphDatabase(dbPath);\n\n  try {\n    const nodes = graph.getAllNodes();\n    const edges = graph.getAllEdges();\n\n    for (const node of nodes) {\n      db.upsertNode(node);\n    }\n\n    for (const edge of edges) {\n      db.addEdge(edge);\n    }\n\n    db.setMetadata('lastGenerated', new Date().toISOString());\n    db.setMetadata('nodeCount', String(stats.nodesCreated));\n    db.setMetadata('edgeCount', String(stats.edgesCreated));\n\n    return { success: true, stats };\n  } catch (error) {\n    stats.errors.push(`Database error: ${error}`);\n    return { success: false, stats };\n  } finally {\n    db.close();\n  }\n}\n\n/**\n * Parse a markdown file into a knowledge node\n */\nasync function parseMarkdownFile(\n  filePath: string,\n  docsRoot: string\n): Promise<KnowledgeNode> {\n  const content = readFileSync(filePath, 'utf-8');\n  const stat = statSync(filePath);\n  const { data, content: body } = matter(content);\n\n  // Extract filename and path\n  const filename = basename(filePath, '.md');\n  const relativePath = relative(docsRoot, filePath);\n\n  // Generate ID from relative path\n  const id = relativePath\n    .replace(/\\.md$/, '')\n    .replace(/\\\\/g, '/')\n    .replace(/[^a-z0-9/]+/gi, '-')\n    .toLowerCase();\n\n  // Extract links from content\n  const outgoingLinks = extractLinks(body);\n\n  // Determine node type from frontmatter or path\n  const type = inferNodeType(data.type, relativePath);\n  const status = (data.status as NodeStatus) || 'active';\n\n  // Build frontmatter\n  const frontmatter: NodeFrontmatter = {\n    title: data.title || formatTitle(filename),\n    type,\n    status,\n    tags: Array.isArray(data.tags) ? data.tags : [],\n    category: data.category,\n    description: data.description,\n    created: data.created || stat.birthtime.toISOString().split('T')[0],\n    updated: data.updated || stat.mtime.toISOString().split('T')[0],\n    aliases: data.aliases,\n    related: data.related,\n    ...data,\n  };\n\n  // Calculate word count\n  const wordCount = body\n    .replace(/[#*`\\[\\]()]/g, '')\n    .split(/\\s+/)\n    .filter(Boolean).length;\n\n  return {\n    id,\n    path: relativePath,\n    filename,\n    title: frontmatter.title || formatTitle(filename),\n    type,\n    status,\n    content: body,\n    frontmatter,\n    tags: frontmatter.tags || [],\n    outgoingLinks,\n    incomingLinks: [], // Will be filled in second pass\n    wordCount,\n    lastModified: stat.mtime,\n  };\n}\n\n/**\n * Extract links from markdown content\n */\nfunction extractLinks(content: string): NodeLink[] {\n  const links: NodeLink[] = [];\n  const seen = new Set<string>();\n\n  // Extract wikilinks\n  let match: RegExpExecArray | null;\n  while ((match = WIKILINK_PATTERN.exec(content)) !== null) {\n    const target = match[1].trim();\n    const text = match[2]?.trim();\n\n    if (!seen.has(target)) {\n      seen.add(target);\n      links.push({\n        target,\n        type: 'wikilink',\n        text,\n      });\n    }\n  }\n\n  // Extract markdown links (only internal ones)\n  while ((match = MARKDOWN_LINK_PATTERN.exec(content)) !== null) {\n    const text = match[1].trim();\n    const target = match[2].trim();\n\n    // Skip external URLs\n    if (target.startsWith('http://') || target.startsWith('https://')) {\n      continue;\n    }\n\n    if (!seen.has(target)) {\n      seen.add(target);\n      links.push({\n        target,\n        type: 'markdown',\n        text,\n      });\n    }\n  }\n\n  return links;\n}\n\n/**\n * Resolve a link target to a node ID\n */\nfunction resolveLink(\n  target: string,\n  currentPath: string,\n  nodeMap: Map<string, KnowledgeNode>\n): string | null {\n  // Clean target\n  const cleanTarget = target\n    .replace(/\\.md$/, '')\n    .replace(/^\\.\\//, '')\n    .toLowerCase();\n\n  // Try direct match\n  for (const [id, node] of nodeMap) {\n    // Match by ID\n    if (id === cleanTarget) {\n      return id;\n    }\n\n    // Match by filename\n    if (node.filename.toLowerCase() === cleanTarget) {\n      return id;\n    }\n\n    // Match by title\n    if (node.title.toLowerCase() === cleanTarget) {\n      return id;\n    }\n\n    // Match by alias\n    if (node.frontmatter.aliases?.some(\n      a => a.toLowerCase() === cleanTarget\n    )) {\n      return id;\n    }\n  }\n\n  // Try relative path resolution\n  const currentDir = currentPath.replace(/[^/]+$/, '');\n  const relativePath = join(currentDir, cleanTarget)\n    .replace(/\\\\/g, '/')\n    .replace(/^\\//, '');\n\n  for (const [id, node] of nodeMap) {\n    if (id === relativePath || node.path.replace(/\\.md$/, '') === relativePath) {\n      return id;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Infer node type from frontmatter or path\n */\nfunction inferNodeType(declaredType: unknown, path: string): NodeType {\n  // Use declared type if valid\n  const validTypes: NodeType[] = [\n    'concept', 'technical', 'feature', 'primitive',\n    'service', 'guide', 'standard', 'integration',\n  ];\n\n  if (typeof declaredType === 'string' && validTypes.includes(declaredType as NodeType)) {\n    return declaredType as NodeType;\n  }\n\n  // Infer from path\n  const pathLower = path.toLowerCase();\n\n  if (pathLower.includes('concept')) return 'concept';\n  if (pathLower.includes('component') || pathLower.includes('technical')) return 'technical';\n  if (pathLower.includes('feature')) return 'feature';\n  if (pathLower.includes('primitive') || pathLower.includes('integration')) return 'primitive';\n  if (pathLower.includes('service') || pathLower.includes('api')) return 'service';\n  if (pathLower.includes('guide') || pathLower.includes('tutorial')) return 'guide';\n  if (pathLower.includes('standard')) return 'standard';\n  if (pathLower.includes('reference')) return 'technical';\n\n  return 'concept'; // Default\n}\n\n/**\n * Format filename as title\n */\nfunction formatTitle(filename: string): string {\n  return filename\n    .replace(/-/g, ' ')\n    .replace(/_/g, ' ')\n    .replace(/\\b\\w/g, c => c.toUpperCase());\n}\n\n/**\n * Generate graph from existing database (incremental update)\n */\nexport async function updateGraph(\n  dbPath: string,\n  docsRoot: string\n): Promise<{\n  added: number;\n  updated: number;\n  removed: number;\n  errors: string[];\n}> {\n  const result = {\n    added: 0,\n    updated: 0,\n    removed: 0,\n    errors: [] as string[],\n  };\n\n  const db = new KnowledgeGraphDatabase(dbPath);\n\n  try {\n    // Get existing nodes\n    const existingNodes = db.getAllNodes();\n    const existingPaths = new Set(existingNodes.map(n => n.path));\n\n    // Find current files\n    const currentFiles = await fg('**/*.md', {\n      cwd: docsRoot,\n      ignore: ['node_modules/**', '.git/**', '_templates/**'],\n    });\n    const currentPaths = new Set(currentFiles);\n\n    // Find removed files\n    for (const node of existingNodes) {\n      if (!currentPaths.has(node.path)) {\n        db.deleteNode(node.id);\n        result.removed++;\n      }\n    }\n\n    // Process current files\n    for (const filePath of currentFiles) {\n      const fullPath = join(docsRoot, filePath);\n\n      try {\n        const node = await parseMarkdownFile(fullPath, docsRoot);\n\n        if (existingPaths.has(filePath)) {\n          // Check if file was modified\n          const existing = existingNodes.find(n => n.path === filePath);\n          if (existing && node.lastModified > existing.lastModified) {\n            db.deleteNodeEdges(node.id);\n            db.upsertNode(node);\n            result.updated++;\n          }\n        } else {\n          db.upsertNode(node);\n          result.added++;\n        }\n      } catch (error) {\n        result.errors.push(`Failed to process ${filePath}: ${error}`);\n      }\n    }\n\n    db.setMetadata('lastUpdated', new Date().toISOString());\n  } finally {\n    db.close();\n  }\n\n  return result;\n}\n"],"names":[],"mappings":";;;;;;AAyBA,MAAM,mBAAmB;AACzB,MAAM,wBAAwB;AAK9B,eAAsB,cAAc,SAQjC;AACD,QAAM,EAAE,aAAa,WAAA,IAAe;AAEpC,QAAM,QAAQ;AAAA,IACZ,cAAc;AAAA,IACd,cAAc;AAAA,IACd,cAAc;AAAA,IACd,QAAQ,CAAA;AAAA,EAAC;AAIX,QAAM,QAAQ,IAAI;AAAA,IAChB,SAAS,WAAW;AAAA,IACpB;AAAA,EAAA;AAIF,QAAM,QAAQ,MAAM,GAAG,WAAW;AAAA,IAChC,KAAK;AAAA,IACL,QAAQ,CAAC,mBAAmB,WAAW,eAAe;AAAA,IACtD,UAAU;AAAA,EAAA,CACX;AAED,QAAM,eAAe,MAAM;AAG3B,QAAM,8BAAc,IAAA;AAEpB,aAAW,YAAY,OAAO;AAC5B,QAAI;AACF,YAAM,OAAO,MAAM,kBAAkB,UAAU,UAAU;AACzD,cAAQ,IAAI,KAAK,IAAI,IAAI;AACzB,YAAM;AAAA,IACR,SAAS,OAAO;AACd,YAAM,OAAO,KAAK,mBAAmB,QAAQ,KAAK,KAAK,EAAE;AAAA,IAC3D;AAAA,EACF;AAGA,aAAW,QAAQ,QAAQ,UAAU;AAEnC,UAAM,gBAA4B,CAAA;AAElC,eAAW,QAAQ,KAAK,eAAe;AAErC,YAAM,WAAW,YAAY,KAAK,QAAQ,KAAK,MAAM,OAAO;AAE5D,UAAI,UAAU;AACZ,sBAAc,KAAK;AAAA,UACjB,GAAG;AAAA,UACH,QAAQ;AAAA,QAAA,CACT;AAGD,cAAM,aAAa,QAAQ,IAAI,QAAQ;AACvC,YAAI,YAAY;AACd,qBAAW,cAAc,KAAK;AAAA,YAC5B,QAAQ,KAAK;AAAA,YACb,MAAM;AAAA,YACN,MAAM,KAAK;AAAA,UAAA,CACZ;AAAA,QACH;AAEA,cAAM;AAAA,MACR;AAAA,IACF;AAEA,SAAK,gBAAgB;AACrB,UAAM,QAAQ,IAAI;AAAA,EACpB;AAEA,SAAO,EAAE,OAAO,MAAA;AAClB;AAKA,eAAsB,gBACpB,SACA,QASC;AACD,QAAM,EAAE,OAAO,MAAA,IAAU,MAAM,cAAc,OAAO;AAGpD,QAAM,KAAK,IAAI,uBAAuB,MAAM;AAE5C,MAAI;AACF,UAAM,QAAQ,MAAM,YAAA;AACpB,UAAM,QAAQ,MAAM,YAAA;AAEpB,eAAW,QAAQ,OAAO;AACxB,SAAG,WAAW,IAAI;AAAA,IACpB;AAEA,eAAW,QAAQ,OAAO;AACxB,SAAG,QAAQ,IAAI;AAAA,IACjB;AAEA,OAAG,YAAY,kBAAiB,oBAAI,KAAA,GAAO,aAAa;AACxD,OAAG,YAAY,aAAa,OAAO,MAAM,YAAY,CAAC;AACtD,OAAG,YAAY,aAAa,OAAO,MAAM,YAAY,CAAC;AAEtD,WAAO,EAAE,SAAS,MAAM,MAAA;AAAA,EAC1B,SAAS,OAAO;AACd,UAAM,OAAO,KAAK,mBAAmB,KAAK,EAAE;AAC5C,WAAO,EAAE,SAAS,OAAO,MAAA;AAAA,EAC3B,UAAA;AACE,OAAG,MAAA;AAAA,EACL;AACF;AAKA,eAAe,kBACb,UACA,UACwB;AACxB,QAAM,UAAU,aAAa,UAAU,OAAO;AAC9C,QAAM,OAAO,SAAS,QAAQ;AAC9B,QAAM,EAAE,MAAM,SAAS,KAAA,IAAS,OAAO,OAAO;AAG9C,QAAM,WAAW,SAAS,UAAU,KAAK;AACzC,QAAM,eAAe,SAAS,UAAU,QAAQ;AAGhD,QAAM,KAAK,aACR,QAAQ,SAAS,EAAE,EACnB,QAAQ,OAAO,GAAG,EAClB,QAAQ,iBAAiB,GAAG,EAC5B,YAAA;AAGH,QAAM,gBAAgB,aAAa,IAAI;AAGvC,QAAM,OAAO,cAAc,KAAK,MAAM,YAAY;AAClD,QAAM,SAAU,KAAK,UAAyB;AAG9C,QAAM,cAA+B;AAAA,IACnC,OAAO,KAAK,SAAS,YAAY,QAAQ;AAAA,IACzC;AAAA,IACA;AAAA,IACA,MAAM,MAAM,QAAQ,KAAK,IAAI,IAAI,KAAK,OAAO,CAAA;AAAA,IAC7C,UAAU,KAAK;AAAA,IACf,aAAa,KAAK;AAAA,IAClB,SAAS,KAAK,WAAW,KAAK,UAAU,cAAc,MAAM,GAAG,EAAE,CAAC;AAAA,IAClE,SAAS,KAAK,WAAW,KAAK,MAAM,cAAc,MAAM,GAAG,EAAE,CAAC;AAAA,IAC9D,SAAS,KAAK;AAAA,IACd,SAAS,KAAK;AAAA,IACd,GAAG;AAAA,EAAA;AAIL,QAAM,YAAY,KACf,QAAQ,gBAAgB,EAAE,EAC1B,MAAM,KAAK,EACX,OAAO,OAAO,EAAE;AAEnB,SAAO;AAAA,IACL;AAAA,IACA,MAAM;AAAA,IACN;AAAA,IACA,OAAO,YAAY,SAAS,YAAY,QAAQ;AAAA,IAChD;AAAA,IACA;AAAA,IACA,SAAS;AAAA,IACT;AAAA,IACA,MAAM,YAAY,QAAQ,CAAA;AAAA,IAC1B;AAAA,IACA,eAAe,CAAA;AAAA;AAAA,IACf;AAAA,IACA,cAAc,KAAK;AAAA,EAAA;AAEvB;AAKA,SAAS,aAAa,SAA6B;AACjD,QAAM,QAAoB,CAAA;AAC1B,QAAM,2BAAW,IAAA;AAGjB,MAAI;AACJ,UAAQ,QAAQ,iBAAiB,KAAK,OAAO,OAAO,MAAM;AACxD,UAAM,SAAS,MAAM,CAAC,EAAE,KAAA;AACxB,UAAM,OAAO,MAAM,CAAC,GAAG,KAAA;AAEvB,QAAI,CAAC,KAAK,IAAI,MAAM,GAAG;AACrB,WAAK,IAAI,MAAM;AACf,YAAM,KAAK;AAAA,QACT;AAAA,QACA,MAAM;AAAA,QACN;AAAA,MAAA,CACD;AAAA,IACH;AAAA,EACF;AAGA,UAAQ,QAAQ,sBAAsB,KAAK,OAAO,OAAO,MAAM;AAC7D,UAAM,OAAO,MAAM,CAAC,EAAE,KAAA;AACtB,UAAM,SAAS,MAAM,CAAC,EAAE,KAAA;AAGxB,QAAI,OAAO,WAAW,SAAS,KAAK,OAAO,WAAW,UAAU,GAAG;AACjE;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,IAAI,MAAM,GAAG;AACrB,WAAK,IAAI,MAAM;AACf,YAAM,KAAK;AAAA,QACT;AAAA,QACA,MAAM;AAAA,QACN;AAAA,MAAA,CACD;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AACT;AAKA,SAAS,YACP,QACA,aACA,SACe;AAEf,QAAM,cAAc,OACjB,QAAQ,SAAS,EAAE,EACnB,QAAQ,SAAS,EAAE,EACnB,YAAA;AAGH,aAAW,CAAC,IAAI,IAAI,KAAK,SAAS;AAEhC,QAAI,OAAO,aAAa;AACtB,aAAO;AAAA,IACT;AAGA,QAAI,KAAK,SAAS,YAAA,MAAkB,aAAa;AAC/C,aAAO;AAAA,IACT;AAGA,QAAI,KAAK,MAAM,YAAA,MAAkB,aAAa;AAC5C,aAAO;AAAA,IACT;AAGA,QAAI,KAAK,YAAY,SAAS;AAAA,MAC5B,CAAA,MAAK,EAAE,kBAAkB;AAAA,IAAA,GACxB;AACD,aAAO;AAAA,IACT;AAAA,EACF;AAGA,QAAM,aAAa,YAAY,QAAQ,UAAU,EAAE;AACnD,QAAM,eAAe,KAAK,YAAY,WAAW,EAC9C,QAAQ,OAAO,GAAG,EAClB,QAAQ,OAAO,EAAE;AAEpB,aAAW,CAAC,IAAI,IAAI,KAAK,SAAS;AAChC,QAAI,OAAO,gBAAgB,KAAK,KAAK,QAAQ,SAAS,EAAE,MAAM,cAAc;AAC1E,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;AAKA,SAAS,cAAc,cAAuB,MAAwB;AAEpE,QAAM,aAAyB;AAAA,IAC7B;AAAA,IAAW;AAAA,IAAa;AAAA,IAAW;AAAA,IACnC;AAAA,IAAW;AAAA,IAAS;AAAA,IAAY;AAAA,EAAA;AAGlC,MAAI,OAAO,iBAAiB,YAAY,WAAW,SAAS,YAAwB,GAAG;AACrF,WAAO;AAAA,EACT;AAGA,QAAM,YAAY,KAAK,YAAA;AAEvB,MAAI,UAAU,SAAS,SAAS,EAAG,QAAO;AAC1C,MAAI,UAAU,SAAS,WAAW,KAAK,UAAU,SAAS,WAAW,EAAG,QAAO;AAC/E,MAAI,UAAU,SAAS,SAAS,EAAG,QAAO;AAC1C,MAAI,UAAU,SAAS,WAAW,KAAK,UAAU,SAAS,aAAa,EAAG,QAAO;AACjF,MAAI,UAAU,SAAS,SAAS,KAAK,UAAU,SAAS,KAAK,EAAG,QAAO;AACvE,MAAI,UAAU,SAAS,OAAO,KAAK,UAAU,SAAS,UAAU,EAAG,QAAO;AAC1E,MAAI,UAAU,SAAS,UAAU,EAAG,QAAO;AAC3C,MAAI,UAAU,SAAS,WAAW,EAAG,QAAO;AAE5C,SAAO;AACT;AAKA,SAAS,YAAY,UAA0B;AAC7C,SAAO,SACJ,QAAQ,MAAM,GAAG,EACjB,QAAQ,MAAM,GAAG,EACjB,QAAQ,SAAS,CAAA,MAAK,EAAE,aAAa;AAC1C;AAKA,eAAsB,YACpB,QACA,UAMC;AACD,QAAM,SAAS;AAAA,IACb,OAAO;AAAA,IACP,SAAS;AAAA,IACT,SAAS;AAAA,IACT,QAAQ,CAAA;AAAA,EAAC;AAGX,QAAM,KAAK,IAAI,uBAAuB,MAAM;AAE5C,MAAI;AAEF,UAAM,gBAAgB,GAAG,YAAA;AACzB,UAAM,gBAAgB,IAAI,IAAI,cAAc,IAAI,CAAA,MAAK,EAAE,IAAI,CAAC;AAG5D,UAAM,eAAe,MAAM,GAAG,WAAW;AAAA,MACvC,KAAK;AAAA,MACL,QAAQ,CAAC,mBAAmB,WAAW,eAAe;AAAA,IAAA,CACvD;AACD,UAAM,eAAe,IAAI,IAAI,YAAY;AAGzC,eAAW,QAAQ,eAAe;AAChC,UAAI,CAAC,aAAa,IAAI,KAAK,IAAI,GAAG;AAChC,WAAG,WAAW,KAAK,EAAE;AACrB,eAAO;AAAA,MACT;AAAA,IACF;AAGA,eAAW,YAAY,cAAc;AACnC,YAAM,WAAW,KAAK,UAAU,QAAQ;AAExC,UAAI;AACF,cAAM,OAAO,MAAM,kBAAkB,UAAU,QAAQ;AAEvD,YAAI,cAAc,IAAI,QAAQ,GAAG;AAE/B,gBAAM,WAAW,cAAc,KAAK,CAAA,MAAK,EAAE,SAAS,QAAQ;AAC5D,cAAI,YAAY,KAAK,eAAe,SAAS,cAAc;AACzD,eAAG,gBAAgB,KAAK,EAAE;AAC1B,eAAG,WAAW,IAAI;AAClB,mBAAO;AAAA,UACT;AAAA,QACF,OAAO;AACL,aAAG,WAAW,IAAI;AAClB,iBAAO;AAAA,QACT;AAAA,MACF,SAAS,OAAO;AACd,eAAO,OAAO,KAAK,qBAAqB,QAAQ,KAAK,KAAK,EAAE;AAAA,MAC9D;AAAA,IACF;AAEA,OAAG,YAAY,gBAAe,oBAAI,KAAA,GAAO,aAAa;AAAA,EACxD,UAAA;AACE,OAAG,MAAA;AAAA,EACL;AAEA,SAAO;AACT;"}