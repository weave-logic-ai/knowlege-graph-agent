{"version":3,"file":"auto-commit.js","sources":["../../src/integrations/auto-commit.ts"],"sourcesContent":["/**\n * Auto-Commit Integration\n *\n * Provides automatic commit functionality with intelligent message generation\n * based on knowledge graph changes and file modifications.\n *\n * @module integrations/auto-commit\n */\n\nimport { GitClient, GitStatusSummary, GitDiffSummary, createGitClient } from './git.js';\nimport { createLogger, Logger, KnowledgeGraphError, ErrorCategory, ErrorSeverity } from '../utils/index.js';\n\n/**\n * Auto-commit configuration\n */\nexport interface AutoCommitConfig {\n  /** Git client instance (created if not provided) */\n  gitClient?: GitClient;\n  /** Logger instance */\n  logger?: Logger;\n  /** Working directory */\n  workingDirectory?: string;\n  /** Prefix for auto-generated commit messages */\n  messagePrefix?: string;\n  /** Whether to include file list in commit message */\n  includeFileList?: boolean;\n  /** Maximum number of files to list in commit message */\n  maxFilesInMessage?: number;\n  /** Custom commit message template */\n  messageTemplate?: string;\n  /** Whether to stage all changes before commit */\n  stageAll?: boolean;\n  /** Files or patterns to always exclude */\n  excludePatterns?: string[];\n}\n\n/**\n * Change type categories\n */\nexport enum ChangeType {\n  ADD = 'add',\n  UPDATE = 'update',\n  DELETE = 'delete',\n  RENAME = 'rename',\n  REFACTOR = 'refactor',\n  FIX = 'fix',\n  DOCS = 'docs',\n  CONFIG = 'config',\n  STYLE = 'style',\n  TEST = 'test',\n  BUILD = 'build',\n  CHORE = 'chore',\n}\n\n/**\n * Analyzed change information\n */\nexport interface ChangeAnalysis {\n  /** Primary change type */\n  type: ChangeType;\n  /** Affected scope (e.g., component name) */\n  scope?: string;\n  /** Brief description of changes */\n  description: string;\n  /** Whether this is a breaking change */\n  breaking: boolean;\n  /** Files involved in this change */\n  files: string[];\n  /** Additional context */\n  context?: Record<string, unknown>;\n}\n\n/**\n * Commit decision result\n */\nexport interface CommitDecision {\n  /** Whether to proceed with commit */\n  shouldCommit: boolean;\n  /** Reason for the decision */\n  reason: string;\n  /** Suggested commit message if should commit */\n  suggestedMessage?: string;\n  /** Analysis of changes */\n  analysis?: ChangeAnalysis;\n}\n\n/**\n * Auto-commit result\n */\nexport interface AutoCommitResult {\n  /** Whether the commit was successful */\n  success: boolean;\n  /** Commit hash if successful */\n  hash?: string;\n  /** Generated commit message */\n  message?: string;\n  /** Error message if failed */\n  error?: string;\n  /** Change analysis */\n  analysis?: ChangeAnalysis;\n}\n\n/**\n * Auto-commit error\n */\nexport class AutoCommitError extends KnowledgeGraphError {\n  constructor(message: string) {\n    super(message, {\n      category: ErrorCategory.RESOURCE,\n      severity: ErrorSeverity.ERROR,\n      retryable: false,\n      code: 'AUTO_COMMIT_ERROR',\n    });\n    this.name = 'AutoCommitError';\n  }\n}\n\n/**\n * File extension to change type mapping\n */\nconst FILE_TYPE_MAPPINGS: Record<string, ChangeType> = {\n  // Documentation\n  '.md': ChangeType.DOCS,\n  '.mdx': ChangeType.DOCS,\n  '.txt': ChangeType.DOCS,\n  '.rst': ChangeType.DOCS,\n\n  // Configuration\n  '.json': ChangeType.CONFIG,\n  '.yaml': ChangeType.CONFIG,\n  '.yml': ChangeType.CONFIG,\n  '.toml': ChangeType.CONFIG,\n  '.ini': ChangeType.CONFIG,\n  '.env': ChangeType.CONFIG,\n  '.config': ChangeType.CONFIG,\n\n  // Tests\n  '.test.ts': ChangeType.TEST,\n  '.test.js': ChangeType.TEST,\n  '.spec.ts': ChangeType.TEST,\n  '.spec.js': ChangeType.TEST,\n\n  // Build\n  '.dockerfile': ChangeType.BUILD,\n  '.dockerignore': ChangeType.BUILD,\n\n  // Style\n  '.css': ChangeType.STYLE,\n  '.scss': ChangeType.STYLE,\n  '.sass': ChangeType.STYLE,\n  '.less': ChangeType.STYLE,\n};\n\n/**\n * Directory to scope mapping\n */\nconst DIRECTORY_SCOPE_MAPPINGS: Record<string, string> = {\n  'src/cli': 'cli',\n  'src/core': 'core',\n  'src/utils': 'utils',\n  'src/integrations': 'integrations',\n  'src/templates': 'templates',\n  'tests': 'test',\n  'docs': 'docs',\n  'scripts': 'scripts',\n};\n\n/**\n * AutoCommit Class\n *\n * Provides intelligent auto-commit functionality with smart message generation.\n */\nexport class AutoCommit {\n  private git: GitClient;\n  private logger: Logger;\n  private config: Required<AutoCommitConfig>;\n\n  constructor(config: AutoCommitConfig = {}) {\n    this.config = {\n      gitClient: config.gitClient || createGitClient({ workingDirectory: config.workingDirectory }),\n      logger: config.logger || createLogger('auto-commit'),\n      workingDirectory: config.workingDirectory || process.cwd(),\n      messagePrefix: config.messagePrefix || '',\n      includeFileList: config.includeFileList ?? true,\n      maxFilesInMessage: config.maxFilesInMessage ?? 5,\n      messageTemplate: config.messageTemplate || '{type}{scope}: {description}',\n      stageAll: config.stageAll ?? false,\n      excludePatterns: config.excludePatterns || ['.env', '.env.local', '*.log', 'node_modules'],\n    };\n\n    this.git = this.config.gitClient;\n    this.logger = this.config.logger;\n  }\n\n  /**\n   * Analyze changes and determine the appropriate change type\n   */\n  async analyzeChanges(status?: GitStatusSummary): Promise<ChangeAnalysis> {\n    const currentStatus = status || await this.git.getStatus();\n    const files = currentStatus.files.map(f => f.path);\n\n    if (files.length === 0) {\n      return {\n        type: ChangeType.CHORE,\n        description: 'no changes detected',\n        breaking: false,\n        files: [],\n      };\n    }\n\n    // Analyze file types and determine primary change type\n    const typeScores: Record<ChangeType, number> = {} as Record<ChangeType, number>;\n    const scopes: string[] = [];\n\n    for (const file of files) {\n      const fileType = this.getFileChangeType(file);\n      typeScores[fileType] = (typeScores[fileType] || 0) + 1;\n\n      const scope = this.getFileScope(file);\n      if (scope && !scopes.includes(scope)) {\n        scopes.push(scope);\n      }\n    }\n\n    // Determine primary type by highest score\n    let primaryType = ChangeType.UPDATE;\n    let maxScore = 0;\n\n    for (const [type, score] of Object.entries(typeScores)) {\n      if (score > maxScore) {\n        maxScore = score;\n        primaryType = type as ChangeType;\n      }\n    }\n\n    // Check for additions/deletions\n    const addedFiles = currentStatus.files.filter(f => f.indexStatus === 'A' || f.workingTreeStatus === '?');\n    const deletedFiles = currentStatus.files.filter(f => f.indexStatus === 'D' || f.workingTreeStatus === 'D');\n\n    if (addedFiles.length > deletedFiles.length && addedFiles.length > currentStatus.modified) {\n      primaryType = ChangeType.ADD;\n    } else if (deletedFiles.length > addedFiles.length && deletedFiles.length > currentStatus.modified) {\n      primaryType = ChangeType.DELETE;\n    }\n\n    // Generate description based on changes\n    const description = this.generateDescription(files, primaryType, currentStatus);\n\n    // Determine scope\n    const scope = scopes.length === 1 ? scopes[0] : (scopes.length > 1 ? scopes.slice(0, 2).join(',') : undefined);\n\n    return {\n      type: primaryType,\n      scope,\n      description,\n      breaking: false,\n      files,\n      context: {\n        staged: currentStatus.staged,\n        modified: currentStatus.modified,\n        untracked: currentStatus.untracked,\n        deleted: currentStatus.deleted,\n      },\n    };\n  }\n\n  /**\n   * Generate a commit message based on analysis\n   */\n  generateCommitMessage(analysis: ChangeAnalysis): string {\n    const { type, scope, description, breaking, files } = analysis;\n\n    // Build the main message\n    let message = this.config.messageTemplate\n      .replace('{type}', type)\n      .replace('{scope}', scope ? `(${scope})` : '')\n      .replace('{description}', description);\n\n    // Add prefix if configured\n    if (this.config.messagePrefix) {\n      message = `${this.config.messagePrefix} ${message}`;\n    }\n\n    // Add breaking change indicator\n    if (breaking) {\n      message = message.replace(':', '!:');\n    }\n\n    // Add file list if configured\n    if (this.config.includeFileList && files.length > 0) {\n      const fileList = files.slice(0, this.config.maxFilesInMessage);\n      const remaining = files.length - fileList.length;\n\n      message += '\\n\\nFiles:\\n';\n      message += fileList.map(f => `- ${f}`).join('\\n');\n\n      if (remaining > 0) {\n        message += `\\n- ... and ${remaining} more files`;\n      }\n    }\n\n    return message;\n  }\n\n  /**\n   * Determine if changes should be committed\n   */\n  async shouldCommit(options: {\n    minFiles?: number;\n    minChanges?: number;\n    excludeTypes?: ChangeType[];\n  } = {}): Promise<CommitDecision> {\n    const minFiles = options.minFiles ?? 1;\n    const minChanges = options.minChanges ?? 1;\n    const excludeTypes = options.excludeTypes ?? [];\n\n    try {\n      const status = await this.git.getStatus();\n\n      // Check if there are any changes\n      if (status.isClean) {\n        return {\n          shouldCommit: false,\n          reason: 'No changes to commit',\n        };\n      }\n\n      // Check minimum file threshold\n      if (status.files.length < minFiles) {\n        return {\n          shouldCommit: false,\n          reason: `Not enough files changed (${status.files.length} < ${minFiles})`,\n        };\n      }\n\n      // Analyze changes\n      const analysis = await this.analyzeChanges(status);\n\n      // Check excluded types\n      if (excludeTypes.includes(analysis.type)) {\n        return {\n          shouldCommit: false,\n          reason: `Change type \"${analysis.type}\" is excluded`,\n          analysis,\n        };\n      }\n\n      // Check for excluded patterns\n      const filteredFiles = this.filterExcludedFiles(status.files.map(f => f.path));\n      if (filteredFiles.length === 0) {\n        return {\n          shouldCommit: false,\n          reason: 'All changes match exclude patterns',\n          analysis,\n        };\n      }\n\n      // Get diff to check change volume\n      const diff = await this.git.getDiff();\n      const totalChanges = diff.insertions + diff.deletions;\n\n      if (totalChanges < minChanges) {\n        return {\n          shouldCommit: false,\n          reason: `Not enough changes (${totalChanges} < ${minChanges})`,\n          analysis,\n        };\n      }\n\n      // Generate suggested message\n      const suggestedMessage = this.generateCommitMessage(analysis);\n\n      return {\n        shouldCommit: true,\n        reason: `${status.files.length} files changed with ${totalChanges} line changes`,\n        suggestedMessage,\n        analysis,\n      };\n    } catch (error) {\n      return {\n        shouldCommit: false,\n        reason: `Error analyzing changes: ${error instanceof Error ? error.message : String(error)}`,\n      };\n    }\n  }\n\n  /**\n   * Perform an auto-commit\n   */\n  async commit(options: {\n    message?: string;\n    stageAll?: boolean;\n    files?: string[];\n    dryRun?: boolean;\n  } = {}): Promise<AutoCommitResult> {\n    try {\n      const stageAll = options.stageAll ?? this.config.stageAll;\n\n      // Stage files if requested\n      if (stageAll) {\n        await this.git.add('.');\n      } else if (options.files && options.files.length > 0) {\n        await this.git.add(options.files);\n      }\n\n      // Get current status and analyze\n      const status = await this.git.getStatus();\n      const analysis = await this.analyzeChanges(status);\n\n      // Generate or use provided message\n      const message = options.message || this.generateCommitMessage(analysis);\n\n      // Check if it's a dry run\n      if (options.dryRun) {\n        this.logger.info('Dry run - would commit with message:', { message });\n        return {\n          success: true,\n          message,\n          analysis,\n        };\n      }\n\n      // Perform the commit\n      const result = await this.git.commit({ message });\n\n      if (result.success) {\n        this.logger.info('Auto-commit successful', {\n          hash: result.hash,\n          message,\n        });\n\n        return {\n          success: true,\n          hash: result.hash,\n          message,\n          analysis,\n        };\n      }\n\n      return {\n        success: false,\n        error: result.error,\n        message,\n        analysis,\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Auto-commit failed', new Error(errorMessage));\n\n      return {\n        success: false,\n        error: errorMessage,\n      };\n    }\n  }\n\n  /**\n   * Smart commit with knowledge graph awareness\n   */\n  async smartCommit(options: {\n    knowledgeGraphChanges?: {\n      nodesAdded?: number;\n      nodesUpdated?: number;\n      nodesDeleted?: number;\n      linksChanged?: number;\n    };\n    additionalContext?: Record<string, unknown>;\n    dryRun?: boolean;\n  } = {}): Promise<AutoCommitResult> {\n    const decision = await this.shouldCommit();\n\n    if (!decision.shouldCommit) {\n      return {\n        success: false,\n        error: decision.reason,\n      };\n    }\n\n    let message = decision.suggestedMessage || '';\n\n    // Enhance message with knowledge graph context if provided\n    if (options.knowledgeGraphChanges) {\n      const { nodesAdded, nodesUpdated, nodesDeleted, linksChanged } = options.knowledgeGraphChanges;\n      const kgChanges: string[] = [];\n\n      if (nodesAdded) kgChanges.push(`${nodesAdded} nodes added`);\n      if (nodesUpdated) kgChanges.push(`${nodesUpdated} nodes updated`);\n      if (nodesDeleted) kgChanges.push(`${nodesDeleted} nodes deleted`);\n      if (linksChanged) kgChanges.push(`${linksChanged} links changed`);\n\n      if (kgChanges.length > 0) {\n        message += `\\n\\nKnowledge Graph:\\n- ${kgChanges.join('\\n- ')}`;\n      }\n    }\n\n    // Add additional context\n    if (options.additionalContext) {\n      message += `\\n\\nContext:\\n${JSON.stringify(options.additionalContext, null, 2)}`;\n    }\n\n    return this.commit({\n      message,\n      stageAll: true,\n      dryRun: options.dryRun,\n    });\n  }\n\n  /**\n   * Get file change type based on path and extension\n   */\n  private getFileChangeType(filePath: string): ChangeType {\n    const lowerPath = filePath.toLowerCase();\n\n    // Check for test files first (more specific patterns)\n    if (lowerPath.includes('.test.') || lowerPath.includes('.spec.') || lowerPath.includes('/tests/')) {\n      return ChangeType.TEST;\n    }\n\n    // Check for build files\n    if (lowerPath.includes('dockerfile') || lowerPath.includes('makefile') || lowerPath.includes('.github/workflows')) {\n      return ChangeType.BUILD;\n    }\n\n    // Check extension mappings\n    for (const [ext, type] of Object.entries(FILE_TYPE_MAPPINGS)) {\n      if (lowerPath.endsWith(ext)) {\n        return type;\n      }\n    }\n\n    // Check for config files by name\n    if (lowerPath.includes('config') || lowerPath.includes('settings')) {\n      return ChangeType.CONFIG;\n    }\n\n    // Default to update for code changes\n    return ChangeType.UPDATE;\n  }\n\n  /**\n   * Get scope from file path\n   */\n  private getFileScope(filePath: string): string | undefined {\n    for (const [dir, scope] of Object.entries(DIRECTORY_SCOPE_MAPPINGS)) {\n      if (filePath.startsWith(dir) || filePath.includes(`/${dir}/`)) {\n        return scope;\n      }\n    }\n\n    // Extract from path structure\n    const parts = filePath.split('/');\n    if (parts.length > 2 && parts[0] === 'src') {\n      return parts[1];\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Generate description based on files and type\n   */\n  private generateDescription(files: string[], type: ChangeType, status: GitStatusSummary): string {\n    // Single file - use file name\n    if (files.length === 1) {\n      const fileName = files[0].split('/').pop() || files[0];\n      return `${this.getTypeVerb(type)} ${fileName}`;\n    }\n\n    // Multiple files - summarize\n    const extensions = new Set(files.map(f => {\n      const ext = f.split('.').pop();\n      return ext ? `.${ext}` : '';\n    }));\n\n    if (extensions.size === 1 && extensions.has('.md')) {\n      return `${this.getTypeVerb(type)} documentation`;\n    }\n\n    if (extensions.size === 1 && (extensions.has('.ts') || extensions.has('.js'))) {\n      return `${this.getTypeVerb(type)} source files`;\n    }\n\n    return `${this.getTypeVerb(type)} ${files.length} files`;\n  }\n\n  /**\n   * Get verb for change type\n   */\n  private getTypeVerb(type: ChangeType): string {\n    switch (type) {\n      case ChangeType.ADD:\n        return 'add';\n      case ChangeType.DELETE:\n        return 'remove';\n      case ChangeType.UPDATE:\n        return 'update';\n      case ChangeType.REFACTOR:\n        return 'refactor';\n      case ChangeType.FIX:\n        return 'fix';\n      case ChangeType.DOCS:\n        return 'document';\n      case ChangeType.CONFIG:\n        return 'configure';\n      case ChangeType.STYLE:\n        return 'style';\n      case ChangeType.TEST:\n        return 'test';\n      case ChangeType.BUILD:\n        return 'build';\n      case ChangeType.CHORE:\n        return 'chore';\n      default:\n        return 'update';\n    }\n  }\n\n  /**\n   * Filter out excluded files\n   */\n  private filterExcludedFiles(files: string[]): string[] {\n    return files.filter(file => {\n      for (const pattern of this.config.excludePatterns) {\n        // Simple pattern matching\n        if (pattern.includes('*')) {\n          const regex = new RegExp(pattern.replace(/\\*/g, '.*'));\n          if (regex.test(file)) return false;\n        } else if (file.includes(pattern)) {\n          return false;\n        }\n      }\n      return true;\n    });\n  }\n}\n\n/**\n * Create an AutoCommit instance\n */\nexport function createAutoCommit(config: AutoCommitConfig = {}): AutoCommit {\n  return new AutoCommit(config);\n}\n"],"names":["scope"],"mappings":"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"}