{"version":3,"file":"upsert.js","sources":["../../../../src/mcp-server/tools/vector/upsert.ts"],"sourcesContent":["/**\n * Vector Upsert Tool\n *\n * MCP tool for inserting or updating vectors in the knowledge graph.\n * Supports single vector operations with metadata.\n *\n * @module mcp-server/tools/vector/upsert\n */\n\nimport type { Tool } from '@modelcontextprotocol/sdk/types.js';\nimport type { ToolHandler, ToolResult } from '../../types/index.js';\nimport type { EnhancedVectorStore } from '../../../vector/services/vector-store.js';\n\n/**\n * Vector upsert tool definition\n *\n * Provides the ability to insert or update vectors in the knowledge graph.\n * If a vector with the given ID exists, it will be updated; otherwise,\n * a new vector will be created.\n */\nexport const vectorUpsertTool: Tool = {\n  name: 'kg_vector_upsert',\n  description:\n    'Insert or update a vector in the knowledge graph. If a vector with the given ID exists, it will be replaced; otherwise, a new vector will be created.',\n  inputSchema: {\n    type: 'object' as const,\n    properties: {\n      id: {\n        type: 'string',\n        description: 'Unique identifier for the vector. Used for retrieval and updates.',\n      },\n      vector: {\n        type: 'array',\n        items: { type: 'number' },\n        description:\n          'The embedding vector as an array of numbers. Must match the configured dimensions.',\n      },\n      metadata: {\n        type: 'object',\n        description:\n          'Optional metadata to associate with the vector. Can include title, content, type, tags, etc.',\n        properties: {\n          title: { type: 'string', description: 'Title of the source document' },\n          content: { type: 'string', description: 'Text content snippet' },\n          type: {\n            type: 'string',\n            description: 'Node type',\n            enum: [\n              'concept',\n              'technical',\n              'feature',\n              'primitive',\n              'service',\n              'guide',\n              'standard',\n              'integration',\n            ],\n          },\n          path: { type: 'string', description: 'Source file path' },\n          tags: {\n            type: 'array',\n            items: { type: 'string' },\n            description: 'Associated tags',\n          },\n          sourceId: { type: 'string', description: 'Reference to source node' },\n        },\n        additionalProperties: true,\n      },\n      namespace: {\n        type: 'string',\n        description: 'Optional namespace for organizing vectors (default: \"default\")',\n      },\n    },\n    required: ['id', 'vector'],\n  },\n};\n\n/**\n * Parameters for vector upsert\n */\ninterface VectorUpsertParams {\n  /** Unique vector identifier */\n  id: string;\n  /** Embedding vector */\n  vector: number[];\n  /** Optional metadata */\n  metadata?: Record<string, unknown>;\n  /** Optional namespace */\n  namespace?: string;\n}\n\n/**\n * Validate vector dimensions\n *\n * Checks if the provided vector matches the expected dimensions.\n *\n * @param vector - Vector to validate\n * @param expectedDimensions - Expected number of dimensions\n * @returns Validation result with error message if invalid\n * @internal\n */\nfunction validateVector(\n  vector: unknown,\n  expectedDimensions: number\n): { valid: boolean; error?: string } {\n  if (!Array.isArray(vector)) {\n    return { valid: false, error: 'Vector must be an array' };\n  }\n\n  if (vector.length === 0) {\n    return { valid: false, error: 'Vector cannot be empty' };\n  }\n\n  if (vector.length !== expectedDimensions) {\n    return {\n      valid: false,\n      error: `Vector dimension mismatch: expected ${expectedDimensions}, got ${vector.length}`,\n    };\n  }\n\n  for (let i = 0; i < vector.length; i++) {\n    if (typeof vector[i] !== 'number' || !isFinite(vector[i])) {\n      return {\n        valid: false,\n        error: `Invalid vector element at index ${i}: must be a finite number`,\n      };\n    }\n  }\n\n  return { valid: true };\n}\n\n/**\n * Validate vector ID\n *\n * Ensures the ID is a valid, non-empty string.\n *\n * @param id - ID to validate\n * @returns Validation result with error message if invalid\n * @internal\n */\nfunction validateId(id: unknown): { valid: boolean; error?: string } {\n  if (typeof id !== 'string') {\n    return { valid: false, error: 'ID must be a string' };\n  }\n\n  if (id.trim().length === 0) {\n    return { valid: false, error: 'ID cannot be empty' };\n  }\n\n  if (id.length > 256) {\n    return { valid: false, error: 'ID must be at most 256 characters' };\n  }\n\n  // Check for valid characters (alphanumeric, dash, underscore, colon)\n  if (!/^[\\w\\-:./]+$/.test(id)) {\n    return {\n      valid: false,\n      error: 'ID can only contain alphanumeric characters, dashes, underscores, colons, dots, and slashes',\n    };\n  }\n\n  return { valid: true };\n}\n\n/**\n * Create vector upsert handler\n *\n * Creates a handler function that inserts or updates vectors in the\n * knowledge graph vector store.\n *\n * @param vectorStore - Vector store instance for storage operations\n * @returns Tool handler function\n *\n * @example\n * ```typescript\n * const handler = createVectorUpsertHandler(vectorStore);\n * const result = await handler({\n *   id: 'doc-123',\n *   vector: [0.1, 0.2, ...], // 1536 dimensions\n *   metadata: {\n *     title: 'Neural Networks',\n *     type: 'concept',\n *     tags: ['AI', 'ML'],\n *   },\n * });\n * ```\n */\nexport function createVectorUpsertHandler(\n  vectorStore?: EnhancedVectorStore\n): ToolHandler {\n  return async (params: Record<string, unknown>): Promise<ToolResult> => {\n    const startTime = Date.now();\n    const typedParams = params as unknown as VectorUpsertParams;\n    const { id, vector, metadata = {}, namespace } = typedParams;\n\n    try {\n      // Validate ID\n      const idValidation = validateId(id);\n      if (!idValidation.valid) {\n        return {\n          success: false,\n          error: idValidation.error,\n          metadata: { executionTime: Date.now() - startTime },\n        };\n      }\n\n      // Check vector store availability\n      if (!vectorStore) {\n        return {\n          success: false,\n          error: 'Vector store not initialized. Configure vector storage first.',\n          metadata: { executionTime: Date.now() - startTime },\n        };\n      }\n\n      // Ensure vector store is ready\n      if (!vectorStore.isReady()) {\n        await vectorStore.initialize();\n      }\n\n      // Get expected dimensions\n      const config = vectorStore.getConfig();\n      const expectedDimensions = config.index.dimensions;\n\n      // Validate vector\n      const vectorValidation = validateVector(vector, expectedDimensions);\n      if (!vectorValidation.valid) {\n        return {\n          success: false,\n          error: vectorValidation.error,\n          metadata: { executionTime: Date.now() - startTime },\n        };\n      }\n\n      // Check if vector exists (for upsert behavior)\n      const existing = await vectorStore.get(id);\n      const isUpdate = existing !== null;\n\n      // If updating, delete the old vector first\n      if (isUpdate) {\n        await vectorStore.delete(id);\n      }\n\n      // Build metadata with namespace\n      const fullMetadata: Record<string, unknown> = {\n        ...metadata,\n        updatedAt: new Date().toISOString(),\n      };\n\n      if (namespace) {\n        fullMetadata.namespace = namespace;\n      }\n\n      // Insert the vector\n      await vectorStore.insert({\n        id,\n        vector: vector as number[],\n        metadata: fullMetadata,\n      });\n\n      // Get updated stats\n      const stats = vectorStore.getStats();\n\n      return {\n        success: true,\n        data: {\n          id,\n          operation: isUpdate ? 'updated' : 'inserted',\n          dimensions: vector.length,\n          hasMetadata: Object.keys(metadata).length > 0,\n          namespace: namespace || 'default',\n        },\n        metadata: {\n          executionTime: Date.now() - startTime,\n          totalVectors: stats.totalVectors,\n          wasUpdate: isUpdate,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: { executionTime: Date.now() - startTime },\n      };\n    }\n  };\n}\n"],"names":[],"mappings":"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"}