{"version":3,"file":"npm-client.js","sources":["../../../../src/plugins/analyzers/dependency-health/npm-client.ts"],"sourcesContent":["/**\n * npm Registry API Client\n *\n * Client for fetching package metadata from the npm registry.\n * Provides methods to get package info, download stats, and quality metrics.\n *\n * @module plugins/analyzers/dependency-health/npm-client\n */\n\nimport { createLogger } from '../../../utils/logger.js';\nimport type {\n  NpmPackageMetadata,\n  NpmQualityMetrics,\n  NpmDownloadStats,\n  DependencyHealthConfig,\n} from './types.js';\n\nconst logger = createLogger('npm-client');\n\n/**\n * npm registry response type\n */\ninterface NpmRegistryResponse {\n  name: string;\n  'dist-tags'?: { latest?: string };\n  versions?: Record<string, {\n    deprecated?: string;\n    types?: string;\n    typings?: string;\n  }>;\n  description?: string;\n  keywords?: string[];\n  author?: string | { name: string; email?: string; url?: string };\n  license?: string;\n  repository?: { type: string; url: string };\n  homepage?: string;\n  bugs?: { url: string };\n  time?: Record<string, string>;\n}\n\n/**\n * npm downloads API response\n */\ninterface NpmDownloadsResponse {\n  downloads?: number;\n}\n\n/**\n * Simple in-memory cache for registry responses\n */\ninterface CacheEntry<T> {\n  data: T;\n  timestamp: number;\n}\n\n/**\n * npm Registry API Client\n */\nexport class NpmClient {\n  private registryUrl: string;\n  private timeout: number;\n  private cacheTtl: number;\n  private cache: Map<string, CacheEntry<unknown>> = new Map();\n\n  constructor(config: Partial<DependencyHealthConfig> = {}) {\n    this.registryUrl = config.registryUrl ?? 'https://registry.npmjs.org';\n    this.timeout = config.timeout ?? 30000;\n    this.cacheTtl = config.cacheTtl ?? 3600000;\n  }\n\n  /**\n   * Get cached value or fetch new data\n   */\n  private async getCached<T>(\n    key: string,\n    fetcher: () => Promise<T>\n  ): Promise<T> {\n    const cached = this.cache.get(key) as CacheEntry<T> | undefined;\n\n    if (cached && Date.now() - cached.timestamp < this.cacheTtl) {\n      return cached.data;\n    }\n\n    const data = await fetcher();\n    this.cache.set(key, { data, timestamp: Date.now() });\n    return data;\n  }\n\n  /**\n   * Fetch with timeout\n   */\n  private async fetchWithTimeout(url: string): Promise<Response> {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    try {\n      const response = await fetch(url, {\n        signal: controller.signal,\n        headers: {\n          'Accept': 'application/json',\n          'User-Agent': 'knowledge-graph-agent/1.0',\n        },\n      });\n      return response;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  /**\n   * Get package metadata from npm registry\n   */\n  async getPackageMetadata(packageName: string): Promise<NpmPackageMetadata | null> {\n    const cacheKey = `metadata:${packageName}`;\n\n    try {\n      return await this.getCached(cacheKey, async () => {\n        const encodedName = encodeURIComponent(packageName).replace('%40', '@');\n        const url = `${this.registryUrl}/${encodedName}`;\n\n        logger.debug('Fetching package metadata', { package: packageName, url });\n\n        const response = await this.fetchWithTimeout(url);\n\n        if (!response.ok) {\n          if (response.status === 404) {\n            logger.warn('Package not found in registry', { package: packageName });\n            return null;\n          }\n          throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        const data = await response.json() as NpmRegistryResponse;\n        const latestVersion = data['dist-tags']?.latest ?? '';\n        const versionData = latestVersion ? data.versions?.[latestVersion] ?? {} : {};\n\n        return {\n          name: data.name,\n          version: latestVersion,\n          description: data.description,\n          keywords: data.keywords,\n          author: typeof data.author === 'string'\n            ? { name: data.author }\n            : data.author,\n          license: data.license,\n          repository: data.repository,\n          homepage: data.homepage,\n          bugs: data.bugs,\n          lastPublish: latestVersion ? data.time?.[latestVersion] : undefined,\n          deprecated: versionData.deprecated,\n          hasTypes: !!(versionData.types || versionData.typings),\n        };\n      });\n    } catch (error) {\n      logger.error('Failed to fetch package metadata', error instanceof Error ? error : undefined, {\n        package: packageName,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Get download statistics from npm\n   */\n  async getDownloadStats(packageName: string): Promise<NpmDownloadStats | null> {\n    const cacheKey = `downloads:${packageName}`;\n\n    try {\n      return await this.getCached(cacheKey, async () => {\n        const encodedName = encodeURIComponent(packageName).replace('%40', '@');\n\n        // Fetch last-week downloads\n        const weekUrl = `https://api.npmjs.org/downloads/point/last-week/${encodedName}`;\n        const monthUrl = `https://api.npmjs.org/downloads/point/last-month/${encodedName}`;\n        const dayUrl = `https://api.npmjs.org/downloads/point/last-day/${encodedName}`;\n\n        const [weekResponse, monthResponse, dayResponse] = await Promise.all([\n          this.fetchWithTimeout(weekUrl).catch(() => null),\n          this.fetchWithTimeout(monthUrl).catch(() => null),\n          this.fetchWithTimeout(dayUrl).catch(() => null),\n        ]);\n\n        const weekData = weekResponse?.ok ? await weekResponse.json() as NpmDownloadsResponse : null;\n        const monthData = monthResponse?.ok ? await monthResponse.json() as NpmDownloadsResponse : null;\n        const dayData = dayResponse?.ok ? await dayResponse.json() as NpmDownloadsResponse : null;\n\n        if (!weekData && !monthData && !dayData) {\n          return null;\n        }\n\n        return {\n          daily: dayData?.downloads ?? 0,\n          weekly: weekData?.downloads ?? 0,\n          monthly: monthData?.downloads ?? 0,\n        };\n      });\n    } catch (error) {\n      logger.error('Failed to fetch download stats', error instanceof Error ? error : undefined, {\n        package: packageName,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Get quality metrics (simulated based on available data)\n   * In production, this could use npms.io API or similar service\n   */\n  async getQualityMetrics(packageName: string): Promise<NpmQualityMetrics | null> {\n    const cacheKey = `quality:${packageName}`;\n\n    try {\n      return await this.getCached(cacheKey, async () => {\n        // Try to get metadata and downloads to calculate approximate scores\n        const [metadata, downloads] = await Promise.all([\n          this.getPackageMetadata(packageName),\n          this.getDownloadStats(packageName),\n        ]);\n\n        if (!metadata) {\n          return null;\n        }\n\n        // Calculate approximate scores based on available data\n        let popularity = 0;\n        if (downloads) {\n          // Normalize monthly downloads (100k+ = 1.0, 0 = 0)\n          popularity = Math.min(downloads.monthly / 100000, 1);\n        }\n\n        // Maintenance score based on available indicators\n        let maintenance = 0.5; // Default middle score\n        if (metadata.lastPublish) {\n          const daysSincePublish = (Date.now() - new Date(metadata.lastPublish).getTime()) / (1000 * 60 * 60 * 24);\n          // Score drops after 30 days, bottoms out at 365 days\n          maintenance = Math.max(0.2, 1 - (daysSincePublish / 365));\n        }\n\n        // Quality score based on completeness\n        let quality = 0.3; // Base score\n        if (metadata.description) quality += 0.1;\n        if (metadata.repository) quality += 0.1;\n        if (metadata.homepage) quality += 0.1;\n        if (metadata.license) quality += 0.1;\n        if (metadata.hasTypes) quality += 0.15;\n        if (metadata.keywords && metadata.keywords.length > 0) quality += 0.05;\n        if (!metadata.deprecated) quality += 0.1;\n        quality = Math.min(quality, 1);\n\n        // Final score as weighted average\n        const final = (quality * 0.35 + popularity * 0.35 + maintenance * 0.3);\n\n        return {\n          quality,\n          popularity,\n          maintenance,\n          final,\n        };\n      });\n    } catch (error) {\n      logger.error('Failed to calculate quality metrics', error instanceof Error ? error : undefined, {\n        package: packageName,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Get all available information for a package\n   */\n  async getFullPackageInfo(packageName: string): Promise<{\n    metadata: NpmPackageMetadata | null;\n    downloads: NpmDownloadStats | null;\n    quality: NpmQualityMetrics | null;\n  }> {\n    const [metadata, downloads, quality] = await Promise.all([\n      this.getPackageMetadata(packageName),\n      this.getDownloadStats(packageName),\n      this.getQualityMetrics(packageName),\n    ]);\n\n    // Attach downloads and quality to metadata if available\n    if (metadata) {\n      metadata.downloads = downloads ?? undefined;\n      metadata.quality = quality ?? undefined;\n    }\n\n    return { metadata, downloads, quality };\n  }\n\n  /**\n   * Batch fetch metadata for multiple packages\n   */\n  async batchGetMetadata(\n    packageNames: string[],\n    concurrency: number = 5\n  ): Promise<Map<string, NpmPackageMetadata | null>> {\n    const results = new Map<string, NpmPackageMetadata | null>();\n    const chunks: string[][] = [];\n\n    // Split into chunks for concurrent processing\n    for (let i = 0; i < packageNames.length; i += concurrency) {\n      chunks.push(packageNames.slice(i, i + concurrency));\n    }\n\n    for (const chunk of chunks) {\n      const promises = chunk.map(async (name) => {\n        const metadata = await this.getPackageMetadata(name);\n        results.set(name, metadata);\n      });\n      await Promise.all(promises);\n    }\n\n    return results;\n  }\n\n  /**\n   * Clear the cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): { size: number; entries: string[] } {\n    return {\n      size: this.cache.size,\n      entries: Array.from(this.cache.keys()),\n    };\n  }\n}\n\n/**\n * Create a new npm client instance\n */\nexport function createNpmClient(config?: Partial<DependencyHealthConfig>): NpmClient {\n  return new NpmClient(config);\n}\n"],"names":[],"mappings":";AAiBA,MAAM,SAAS,aAAa,YAAY;AAyCjC,MAAM,UAAU;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA,4BAA8C,IAAA;AAAA,EAEtD,YAAY,SAA0C,IAAI;AACxD,SAAK,cAAc,OAAO,eAAe;AACzC,SAAK,UAAU,OAAO,WAAW;AACjC,SAAK,WAAW,OAAO,YAAY;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,UACZ,KACA,SACY;AACZ,UAAM,SAAS,KAAK,MAAM,IAAI,GAAG;AAEjC,QAAI,UAAU,KAAK,IAAA,IAAQ,OAAO,YAAY,KAAK,UAAU;AAC3D,aAAO,OAAO;AAAA,IAChB;AAEA,UAAM,OAAO,MAAM,QAAA;AACnB,SAAK,MAAM,IAAI,KAAK,EAAE,MAAM,WAAW,KAAK,IAAA,GAAO;AACnD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBAAiB,KAAgC;AAC7D,UAAM,aAAa,IAAI,gBAAA;AACvB,UAAM,YAAY,WAAW,MAAM,WAAW,MAAA,GAAS,KAAK,OAAO;AAEnE,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,KAAK;AAAA,QAChC,QAAQ,WAAW;AAAA,QACnB,SAAS;AAAA,UACP,UAAU;AAAA,UACV,cAAc;AAAA,QAAA;AAAA,MAChB,CACD;AACD,aAAO;AAAA,IACT,UAAA;AACE,mBAAa,SAAS;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAmB,aAAyD;AAChF,UAAM,WAAW,YAAY,WAAW;AAExC,QAAI;AACF,aAAO,MAAM,KAAK,UAAU,UAAU,YAAY;AAChD,cAAM,cAAc,mBAAmB,WAAW,EAAE,QAAQ,OAAO,GAAG;AACtE,cAAM,MAAM,GAAG,KAAK,WAAW,IAAI,WAAW;AAE9C,eAAO,MAAM,6BAA6B,EAAE,SAAS,aAAa,KAAK;AAEvE,cAAM,WAAW,MAAM,KAAK,iBAAiB,GAAG;AAEhD,YAAI,CAAC,SAAS,IAAI;AAChB,cAAI,SAAS,WAAW,KAAK;AAC3B,mBAAO,KAAK,iCAAiC,EAAE,SAAS,aAAa;AACrE,mBAAO;AAAA,UACT;AACA,gBAAM,IAAI,MAAM,QAAQ,SAAS,MAAM,KAAK,SAAS,UAAU,EAAE;AAAA,QACnE;AAEA,cAAM,OAAO,MAAM,SAAS,KAAA;AAC5B,cAAM,gBAAgB,KAAK,WAAW,GAAG,UAAU;AACnD,cAAM,cAAc,gBAAgB,KAAK,WAAW,aAAa,KAAK,CAAA,IAAK,CAAA;AAE3E,eAAO;AAAA,UACL,MAAM,KAAK;AAAA,UACX,SAAS;AAAA,UACT,aAAa,KAAK;AAAA,UAClB,UAAU,KAAK;AAAA,UACf,QAAQ,OAAO,KAAK,WAAW,WAC3B,EAAE,MAAM,KAAK,WACb,KAAK;AAAA,UACT,SAAS,KAAK;AAAA,UACd,YAAY,KAAK;AAAA,UACjB,UAAU,KAAK;AAAA,UACf,MAAM,KAAK;AAAA,UACX,aAAa,gBAAgB,KAAK,OAAO,aAAa,IAAI;AAAA,UAC1D,YAAY,YAAY;AAAA,UACxB,UAAU,CAAC,EAAE,YAAY,SAAS,YAAY;AAAA,QAAA;AAAA,MAElD,CAAC;AAAA,IACH,SAAS,OAAO;AACd,aAAO,MAAM,oCAAoC,iBAAiB,QAAQ,QAAQ,QAAW;AAAA,QAC3F,SAAS;AAAA,MAAA,CACV;AACD,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,aAAuD;AAC5E,UAAM,WAAW,aAAa,WAAW;AAEzC,QAAI;AACF,aAAO,MAAM,KAAK,UAAU,UAAU,YAAY;AAChD,cAAM,cAAc,mBAAmB,WAAW,EAAE,QAAQ,OAAO,GAAG;AAGtE,cAAM,UAAU,mDAAmD,WAAW;AAC9E,cAAM,WAAW,oDAAoD,WAAW;AAChF,cAAM,SAAS,kDAAkD,WAAW;AAE5E,cAAM,CAAC,cAAc,eAAe,WAAW,IAAI,MAAM,QAAQ,IAAI;AAAA,UACnE,KAAK,iBAAiB,OAAO,EAAE,MAAM,MAAM,IAAI;AAAA,UAC/C,KAAK,iBAAiB,QAAQ,EAAE,MAAM,MAAM,IAAI;AAAA,UAChD,KAAK,iBAAiB,MAAM,EAAE,MAAM,MAAM,IAAI;AAAA,QAAA,CAC/C;AAED,cAAM,WAAW,cAAc,KAAK,MAAM,aAAa,SAAiC;AACxF,cAAM,YAAY,eAAe,KAAK,MAAM,cAAc,SAAiC;AAC3F,cAAM,UAAU,aAAa,KAAK,MAAM,YAAY,SAAiC;AAErF,YAAI,CAAC,YAAY,CAAC,aAAa,CAAC,SAAS;AACvC,iBAAO;AAAA,QACT;AAEA,eAAO;AAAA,UACL,OAAO,SAAS,aAAa;AAAA,UAC7B,QAAQ,UAAU,aAAa;AAAA,UAC/B,SAAS,WAAW,aAAa;AAAA,QAAA;AAAA,MAErC,CAAC;AAAA,IACH,SAAS,OAAO;AACd,aAAO,MAAM,kCAAkC,iBAAiB,QAAQ,QAAQ,QAAW;AAAA,QACzF,SAAS;AAAA,MAAA,CACV;AACD,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,kBAAkB,aAAwD;AAC9E,UAAM,WAAW,WAAW,WAAW;AAEvC,QAAI;AACF,aAAO,MAAM,KAAK,UAAU,UAAU,YAAY;AAEhD,cAAM,CAAC,UAAU,SAAS,IAAI,MAAM,QAAQ,IAAI;AAAA,UAC9C,KAAK,mBAAmB,WAAW;AAAA,UACnC,KAAK,iBAAiB,WAAW;AAAA,QAAA,CAClC;AAED,YAAI,CAAC,UAAU;AACb,iBAAO;AAAA,QACT;AAGA,YAAI,aAAa;AACjB,YAAI,WAAW;AAEb,uBAAa,KAAK,IAAI,UAAU,UAAU,KAAQ,CAAC;AAAA,QACrD;AAGA,YAAI,cAAc;AAClB,YAAI,SAAS,aAAa;AACxB,gBAAM,oBAAoB,KAAK,IAAA,IAAQ,IAAI,KAAK,SAAS,WAAW,EAAE,QAAA,MAAc,MAAO,KAAK,KAAK;AAErG,wBAAc,KAAK,IAAI,KAAK,IAAK,mBAAmB,GAAI;AAAA,QAC1D;AAGA,YAAI,UAAU;AACd,YAAI,SAAS,YAAa,YAAW;AACrC,YAAI,SAAS,WAAY,YAAW;AACpC,YAAI,SAAS,SAAU,YAAW;AAClC,YAAI,SAAS,QAAS,YAAW;AACjC,YAAI,SAAS,SAAU,YAAW;AAClC,YAAI,SAAS,YAAY,SAAS,SAAS,SAAS,EAAG,YAAW;AAClE,YAAI,CAAC,SAAS,WAAY,YAAW;AACrC,kBAAU,KAAK,IAAI,SAAS,CAAC;AAG7B,cAAM,QAAS,UAAU,OAAO,aAAa,OAAO,cAAc;AAElE,eAAO;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QAAA;AAAA,MAEJ,CAAC;AAAA,IACH,SAAS,OAAO;AACd,aAAO,MAAM,uCAAuC,iBAAiB,QAAQ,QAAQ,QAAW;AAAA,QAC9F,SAAS;AAAA,MAAA,CACV;AACD,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAmB,aAItB;AACD,UAAM,CAAC,UAAU,WAAW,OAAO,IAAI,MAAM,QAAQ,IAAI;AAAA,MACvD,KAAK,mBAAmB,WAAW;AAAA,MACnC,KAAK,iBAAiB,WAAW;AAAA,MACjC,KAAK,kBAAkB,WAAW;AAAA,IAAA,CACnC;AAGD,QAAI,UAAU;AACZ,eAAS,YAAY,aAAa;AAClC,eAAS,UAAU,WAAW;AAAA,IAChC;AAEA,WAAO,EAAE,UAAU,WAAW,QAAA;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBACJ,cACA,cAAsB,GAC2B;AACjD,UAAM,8BAAc,IAAA;AACpB,UAAM,SAAqB,CAAA;AAG3B,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK,aAAa;AACzD,aAAO,KAAK,aAAa,MAAM,GAAG,IAAI,WAAW,CAAC;AAAA,IACpD;AAEA,eAAW,SAAS,QAAQ;AAC1B,YAAM,WAAW,MAAM,IAAI,OAAO,SAAS;AACzC,cAAM,WAAW,MAAM,KAAK,mBAAmB,IAAI;AACnD,gBAAQ,IAAI,MAAM,QAAQ;AAAA,MAC5B,CAAC;AACD,YAAM,QAAQ,IAAI,QAAQ;AAAA,IAC5B;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,aAAmB;AACjB,SAAK,MAAM,MAAA;AAAA,EACb;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAqD;AACnD,WAAO;AAAA,MACL,MAAM,KAAK,MAAM;AAAA,MACjB,SAAS,MAAM,KAAK,KAAK,MAAM,MAAM;AAAA,IAAA;AAAA,EAEzC;AACF;AAKO,SAAS,gBAAgB,QAAqD;AACnF,SAAO,IAAI,UAAU,MAAM;AAC7B;"}