{"version":3,"file":"manager.js","sources":["../../src/plugins/manager.ts"],"sourcesContent":["/**\n * Plugin Manager - Plugin lifecycle and coordination\n *\n * Provides centralized management for plugins including:\n * - Plugin discovery, loading, and initialization\n * - Lifecycle management (install, enable, disable, uninstall)\n * - Hook invocation with dependency ordering\n * - Plugin isolation and error handling\n * - Plugin context provisioning\n *\n * @module plugins/manager\n */\n\nimport { EventEmitter } from 'events';\nimport { resolve, dirname } from 'path';\nimport { pathToFileURL } from 'url';\nimport { createLogger } from '../utils/index.js';\nimport type { KnowledgeGraphManager } from '../core/graph.js';\nimport type { KGConfiguration } from '../config/types.js';\nimport type { Logger } from '../utils/logger.js';\nimport type {\n  KGPlugin,\n  PluginType,\n  PluginHook,\n  PluginStatus,\n  PluginMetadata,\n  PluginContext,\n  PluginAPI,\n  PluginCommand,\n  PluginEventEmitter,\n  KGPluginManifest,\n  PluginLoader,\n  PluginRegistry,\n  PluginManager,\n  PluginManagerConfig,\n  PluginLoadOptions,\n  PluginLoadResult,\n  DiscoveredPlugin,\n  PluginRegistryEvents,\n  AnalyzerPlugin,\n  KnowledgeGraphDatabase,\n  ShadowCache,\n  PluginModuleExport,\n} from './types.js';\nimport { isAnalyzerPlugin, createDefaultPluginMetadata } from './types.js';\n\nconst logger = createLogger('plugin-manager');\n\n// ============================================================================\n// Plugin Event Emitter Implementation\n// ============================================================================\n\n/**\n * Plugin event emitter for inter-plugin communication\n */\nclass PluginEventEmitterImpl extends EventEmitter implements PluginEventEmitter {\n  constructor() {\n    super();\n    this.setMaxListeners(100);\n  }\n}\n\n// ============================================================================\n// Plugin Registry Implementation\n// ============================================================================\n\n/**\n * Registry for managing loaded plugins\n */\nexport class PluginRegistryImpl extends EventEmitter implements PluginRegistry {\n  private plugins: Map<string, KGPlugin> = new Map();\n  private manifests: Map<string, KGPluginManifest> = new Map();\n  private metadata: Map<string, PluginMetadata> = new Map();\n  private hookSubscribers: Map<PluginHook, Set<string>> = new Map();\n\n  constructor() {\n    super();\n    logger.debug('PluginRegistry initialized');\n  }\n\n  register(plugin: KGPlugin, manifest: KGPluginManifest): void {\n    if (this.plugins.has(plugin.name)) {\n      throw new Error(`Plugin ${plugin.name} already registered`);\n    }\n\n    this.plugins.set(plugin.name, plugin);\n    this.manifests.set(plugin.name, manifest);\n\n    const meta: PluginMetadata = {\n      name: plugin.name,\n      version: plugin.version,\n      type: plugin.type,\n      status: 'initialized',\n      hooks: manifest['kg-plugin'].hooks ?? [],\n      capabilities: manifest['kg-plugin'].capabilities?.map(c => c.name) ?? [],\n    };\n    this.metadata.set(plugin.name, meta);\n\n    // Register hook subscriptions\n    for (const hook of meta.hooks) {\n      if (!this.hookSubscribers.has(hook)) {\n        this.hookSubscribers.set(hook, new Set());\n      }\n      this.hookSubscribers.get(hook)!.add(plugin.name);\n    }\n\n    logger.info(`Plugin registered: ${plugin.name}@${plugin.version}`, {\n      type: plugin.type,\n      hooks: meta.hooks.length,\n    });\n\n    this.emit('registered', { plugin, metadata: meta });\n  }\n\n  unregister(name: string): boolean {\n    const plugin = this.plugins.get(name);\n    if (!plugin) return false;\n\n    // Remove hook subscriptions\n    for (const [hook, subscribers] of this.hookSubscribers) {\n      subscribers.delete(name);\n    }\n\n    this.plugins.delete(name);\n    this.manifests.delete(name);\n    this.metadata.delete(name);\n\n    logger.info(`Plugin unregistered: ${name}`);\n    this.emit('unregistered', { name });\n    return true;\n  }\n\n  get<T extends KGPlugin = KGPlugin>(name: string): T | undefined {\n    return this.plugins.get(name) as T | undefined;\n  }\n\n  getAll(): KGPlugin[] {\n    return Array.from(this.plugins.values());\n  }\n\n  getByType<T extends KGPlugin = KGPlugin>(type: PluginType): T[] {\n    return this.getAll().filter(p => p.type === type) as T[];\n  }\n\n  getAnalyzers(): AnalyzerPlugin[] {\n    return this.getAll().filter(isAnalyzerPlugin);\n  }\n\n  has(name: string): boolean {\n    return this.plugins.has(name);\n  }\n\n  getMetadata(name: string): PluginMetadata | undefined {\n    return this.metadata.get(name);\n  }\n\n  async enable(name: string): Promise<boolean> {\n    const meta = this.metadata.get(name);\n    if (!meta) return false;\n\n    if (meta.status === 'active') return true;\n\n    meta.status = 'active';\n    logger.info(`Plugin enabled: ${name}`);\n    this.emit('enabled', { name });\n    return true;\n  }\n\n  async disable(name: string): Promise<boolean> {\n    const meta = this.metadata.get(name);\n    if (!meta) return false;\n\n    if (meta.status === 'disabled') return true;\n\n    meta.status = 'disabled';\n    logger.info(`Plugin disabled: ${name}`);\n    this.emit('disabled', { name });\n    return true;\n  }\n\n  async executeHook<T = void>(\n    hook: PluginHook,\n    ...args: unknown[]\n  ): Promise<Map<string, T | Error>> {\n    const results = new Map<string, T | Error>();\n    const subscribers = this.getHookSubscribers(hook);\n    const startTime = Date.now();\n\n    // Get plugins sorted by priority\n    const sortedPlugins = subscribers\n      .map(name => ({\n        name,\n        plugin: this.plugins.get(name)!,\n        manifest: this.manifests.get(name)!,\n        meta: this.metadata.get(name)!,\n      }))\n      .filter(({ meta }) => meta.status === 'active')\n      .sort((a, b) => {\n        const priorityA = a.manifest['kg-plugin'].priority ?? 100;\n        const priorityB = b.manifest['kg-plugin'].priority ?? 100;\n        return priorityA - priorityB;\n      });\n\n    for (const { name, plugin, meta } of sortedPlugins) {\n      try {\n        const hookMethod = plugin[hook] as ((...hookArgs: unknown[]) => Promise<T>) | undefined;\n        if (typeof hookMethod === 'function') {\n          const result = await hookMethod.apply(plugin, args);\n          results.set(name, result);\n        }\n      } catch (error) {\n        const err = error instanceof Error ? error : new Error(String(error));\n        results.set(name, err);\n        meta.status = 'error';\n        meta.lastError = err.message;\n        logger.error(`Plugin ${name} hook ${hook} failed`, err);\n        this.emit('error', { name, error: err });\n      }\n    }\n\n    const duration = Date.now() - startTime;\n    this.emit('hookExecuted', { hook, plugins: subscribers, duration });\n    logger.debug(`Hook ${hook} executed`, { plugins: subscribers.length, duration });\n\n    return results;\n  }\n\n  getHookSubscribers(hook: PluginHook): string[] {\n    return Array.from(this.hookSubscribers.get(hook) ?? []);\n  }\n\n  getStats(): {\n    totalPlugins: number;\n    activePlugins: number;\n    disabledPlugins: number;\n    errorPlugins: number;\n    pluginsByType: Record<PluginType, number>;\n    hookSubscriptions: Record<PluginHook, number>;\n  } {\n    const allMeta = Array.from(this.metadata.values());\n\n    const pluginsByType: Record<PluginType, number> = {\n      analyzer: 0,\n      transformer: 0,\n      exporter: 0,\n      importer: 0,\n      integration: 0,\n      visualization: 0,\n      storage: 0,\n      agent: 0,\n      hook: 0,\n      generic: 0,\n    };\n\n    for (const meta of allMeta) {\n      pluginsByType[meta.type]++;\n    }\n\n    const hookSubscriptions: Record<PluginHook, number> = {\n      onGraphLoad: 0,\n      onGraphSave: 0,\n      onNodeAdd: 0,\n      onNodeUpdate: 0,\n      onNodeRemove: 0,\n      onEdgeAdd: 0,\n      onEdgeRemove: 0,\n      onAnalysisStart: 0,\n      onAnalysisComplete: 0,\n      onAgentTaskStart: 0,\n      onAgentTaskComplete: 0,\n      onFileChange: 0,\n      onShutdown: 0,\n    };\n\n    for (const [hook, subscribers] of this.hookSubscribers) {\n      hookSubscriptions[hook] = subscribers.size;\n    }\n\n    return {\n      totalPlugins: allMeta.length,\n      activePlugins: allMeta.filter(m => m.status === 'active').length,\n      disabledPlugins: allMeta.filter(m => m.status === 'disabled').length,\n      errorPlugins: allMeta.filter(m => m.status === 'error').length,\n      pluginsByType,\n      hookSubscriptions,\n    };\n  }\n\n  on<K extends keyof PluginRegistryEvents>(\n    event: K,\n    listener: (data: PluginRegistryEvents[K]) => void\n  ): this {\n    return super.on(event, listener as (...args: unknown[]) => void);\n  }\n\n  off<K extends keyof PluginRegistryEvents>(\n    event: K,\n    listener: (data: PluginRegistryEvents[K]) => void\n  ): this {\n    return super.off(event, listener as (...args: unknown[]) => void);\n  }\n\n  async clear(): Promise<void> {\n    const pluginNames = Array.from(this.plugins.keys());\n    for (const name of pluginNames) {\n      const plugin = this.plugins.get(name);\n      if (plugin?.destroy) {\n        try {\n          await plugin.destroy();\n        } catch (error) {\n          logger.error(`Error destroying plugin ${name}`, error instanceof Error ? error : undefined);\n        }\n      }\n      this.unregister(name);\n    }\n    logger.info('Plugin registry cleared');\n  }\n}\n\n// ============================================================================\n// Plugin Loader Implementation\n// ============================================================================\n\n/**\n * Loader for discovering and loading plugins\n */\nexport class PluginLoaderImpl implements PluginLoader {\n  private loadedPlugins: Map<string, KGPlugin> = new Map();\n  private loadedMetadata: Map<string, PluginMetadata> = new Map();\n  private searchPaths: string[] = [];\n\n  constructor(searchPaths: string[] = []) {\n    this.searchPaths = [...searchPaths];\n  }\n\n  async discover(): Promise<DiscoveredPlugin[]> {\n    const discovered: DiscoveredPlugin[] = [];\n    const { readdir, readFile, stat } = await import('fs/promises');\n\n    for (const basePath of this.searchPaths) {\n      try {\n        const entries = await readdir(basePath, { withFileTypes: true });\n\n        for (const entry of entries) {\n          if (!entry.isDirectory()) continue;\n\n          const pluginPath = resolve(basePath, entry.name);\n          const packageJsonPath = resolve(pluginPath, 'package.json');\n\n          try {\n            const packageStat = await stat(packageJsonPath);\n            if (!packageStat.isFile()) continue;\n\n            const content = await readFile(packageJsonPath, 'utf-8');\n            const manifest = JSON.parse(content) as KGPluginManifest;\n\n            const validation = this.validateManifest(manifest);\n\n            discovered.push({\n              manifest,\n              path: pluginPath,\n              isLocal: true,\n              valid: validation.valid,\n              errors: validation.errors.length > 0 ? validation.errors : undefined,\n            });\n          } catch {\n            // Skip directories without valid package.json\n          }\n        }\n      } catch {\n        logger.debug(`Search path not accessible: ${basePath}`);\n      }\n    }\n\n    logger.info(`Discovered ${discovered.length} plugins`, {\n      valid: discovered.filter(p => p.valid).length,\n      invalid: discovered.filter(p => !p.valid).length,\n    });\n\n    return discovered;\n  }\n\n  async load(name: string, options: PluginLoadOptions = {}): Promise<PluginLoadResult> {\n    const startTime = Date.now();\n\n    // Check if already loaded\n    if (!options.force && this.loadedPlugins.has(name)) {\n      const plugin = this.loadedPlugins.get(name)!;\n      return {\n        success: true,\n        plugin,\n        metadata: this.loadedMetadata.get(name),\n        loadTime: Date.now() - startTime,\n      };\n    }\n\n    // Try to find the plugin in search paths\n    for (const basePath of this.searchPaths) {\n      const pluginPath = resolve(basePath, name);\n      const result = await this.loadFromPath(pluginPath, options);\n      if (result.success) {\n        return result;\n      }\n    }\n\n    // Try to load as npm package\n    try {\n      const modulePath = await import.meta.resolve?.(name) ?? name;\n      return await this.loadModule(name, modulePath, options, startTime);\n    } catch (error) {\n      return {\n        success: false,\n        error: `Plugin ${name} not found`,\n        loadTime: Date.now() - startTime,\n      };\n    }\n  }\n\n  async loadFromPath(path: string, options: PluginLoadOptions = {}): Promise<PluginLoadResult> {\n    const startTime = Date.now();\n    const { readFile } = await import('fs/promises');\n\n    try {\n      // Read package.json\n      const packageJsonPath = resolve(path, 'package.json');\n      const content = await readFile(packageJsonPath, 'utf-8');\n      const manifest = JSON.parse(content) as KGPluginManifest;\n\n      // Validate if requested\n      if (options.validate !== false) {\n        const validation = this.validateManifest(manifest);\n        if (!validation.valid) {\n          return {\n            success: false,\n            error: `Invalid manifest: ${validation.errors.join(', ')}`,\n            loadTime: Date.now() - startTime,\n          };\n        }\n      }\n\n      // Load the plugin module\n      const mainPath = resolve(path, manifest['kg-plugin'].main);\n      const moduleUrl = pathToFileURL(mainPath).href;\n\n      return await this.loadModule(manifest.name, moduleUrl, options, startTime, manifest);\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        loadTime: Date.now() - startTime,\n      };\n    }\n  }\n\n  private async loadModule(\n    name: string,\n    modulePath: string,\n    options: PluginLoadOptions,\n    startTime: number,\n    manifest?: KGPluginManifest\n  ): Promise<PluginLoadResult> {\n    try {\n      const timeoutMs = options.timeout ?? 30000;\n      const loadPromise = import(modulePath);\n\n      const module = await Promise.race([\n        loadPromise,\n        new Promise<never>((_, reject) =>\n          setTimeout(() => reject(new Error('Plugin load timeout')), timeoutMs)\n        ),\n      ]);\n\n      const exported: PluginModuleExport = module.default ?? module;\n      let plugin: KGPlugin;\n\n      // Handle different export types\n      if (typeof exported === 'function') {\n        // Factory function or constructor\n        const result = (exported as () => KGPlugin | Promise<KGPlugin>)();\n        plugin = result instanceof Promise ? await result : result;\n      } else {\n        // Direct plugin instance\n        plugin = exported as KGPlugin;\n      }\n\n      const metadata = createDefaultPluginMetadata(\n        plugin.name,\n        plugin.version,\n        plugin.type\n      );\n      metadata.status = 'loading';\n      metadata.loadTime = Date.now() - startTime;\n\n      this.loadedPlugins.set(name, plugin);\n      this.loadedMetadata.set(name, metadata);\n\n      logger.info(`Plugin loaded: ${name}`, { loadTime: metadata.loadTime });\n\n      return {\n        success: true,\n        plugin,\n        metadata,\n        loadTime: metadata.loadTime,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        loadTime: Date.now() - startTime,\n      };\n    }\n  }\n\n  async unload(name: string): Promise<boolean> {\n    const plugin = this.loadedPlugins.get(name);\n    if (!plugin) return false;\n\n    try {\n      if (plugin.destroy) {\n        await plugin.destroy();\n      }\n    } catch (error) {\n      logger.error(`Error destroying plugin ${name}`, error instanceof Error ? error : undefined);\n    }\n\n    this.loadedPlugins.delete(name);\n    this.loadedMetadata.delete(name);\n    logger.info(`Plugin unloaded: ${name}`);\n    return true;\n  }\n\n  async reload(name: string): Promise<PluginLoadResult> {\n    await this.unload(name);\n    return this.load(name, { force: true });\n  }\n\n  get(name: string): KGPlugin | undefined {\n    return this.loadedPlugins.get(name);\n  }\n\n  isLoaded(name: string): boolean {\n    return this.loadedPlugins.has(name);\n  }\n\n  getAll(): KGPlugin[] {\n    return Array.from(this.loadedPlugins.values());\n  }\n\n  validateManifest(manifest: KGPluginManifest): {\n    valid: boolean;\n    errors: string[];\n    warnings: string[];\n  } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Required fields\n    if (!manifest.name) {\n      errors.push('Missing required field: name');\n    }\n    if (!manifest.version) {\n      errors.push('Missing required field: version');\n    }\n    if (!manifest['kg-plugin']) {\n      errors.push('Missing required field: kg-plugin');\n    } else {\n      if (!manifest['kg-plugin'].type) {\n        errors.push('Missing required field: kg-plugin.type');\n      }\n      if (!manifest['kg-plugin'].main) {\n        errors.push('Missing required field: kg-plugin.main');\n      }\n    }\n\n    // Warnings\n    if (!manifest.description) {\n      warnings.push('Missing recommended field: description');\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  }\n\n  setSearchPaths(paths: string[]): void {\n    this.searchPaths = [...paths];\n  }\n\n  getSearchPaths(): string[] {\n    return [...this.searchPaths];\n  }\n}\n\n// ============================================================================\n// Plugin Manager Implementation\n// ============================================================================\n\n/**\n * Main plugin manager for high-level plugin operations\n */\nexport class PluginManagerImpl extends EventEmitter implements PluginManager {\n  readonly loader: PluginLoader;\n  readonly registry: PluginRegistry;\n\n  private config: PluginManagerConfig;\n  private contexts: Map<string, PluginContext> = new Map();\n  private pluginConfigs: Map<string, Record<string, unknown>> = new Map();\n  private isShuttingDown = false;\n  private sharedEventEmitter: PluginEventEmitterImpl;\n  private commands: Map<string, PluginCommand> = new Map();\n  private abortController: AbortController | null = null;\n\n  // Dependencies injected during initialization\n  private database?: KnowledgeGraphDatabase;\n  private graph?: KnowledgeGraphManager;\n  private cache?: ShadowCache;\n  private appConfig?: KGConfiguration;\n  private projectRoot?: string;\n\n  constructor(config: PluginManagerConfig) {\n    super();\n    this.config = config;\n    this.loader = new PluginLoaderImpl(config.searchPaths);\n    this.registry = new PluginRegistryImpl();\n    this.sharedEventEmitter = new PluginEventEmitterImpl();\n\n    // Set up default plugin configs\n    if (config.defaultConfig) {\n      for (const [name, pluginConfig] of Object.entries(config.defaultConfig)) {\n        this.pluginConfigs.set(name, pluginConfig);\n      }\n    }\n\n    logger.info('PluginManager initialized', {\n      searchPaths: config.searchPaths.length,\n      autoLoad: config.autoLoad?.length ?? 0,\n    });\n  }\n\n  /**\n   * Set dependencies for plugin contexts\n   */\n  setDependencies(deps: {\n    database: KnowledgeGraphDatabase;\n    graph: KnowledgeGraphManager;\n    cache: ShadowCache;\n    config: KGConfiguration;\n    projectRoot: string;\n  }): void {\n    this.database = deps.database;\n    this.graph = deps.graph;\n    this.cache = deps.cache;\n    this.appConfig = deps.config;\n    this.projectRoot = deps.projectRoot;\n  }\n\n  async initialize(): Promise<void> {\n    logger.info('Initializing plugin manager...');\n    this.abortController = new AbortController();\n\n    // Discover plugins\n    const discovered = await this.loader.discover();\n    logger.info(`Found ${discovered.length} plugins`);\n\n    // Load auto-load plugins\n    const autoLoadPlugins = this.config.autoLoad ?? [];\n    const loadResults = await this.loadPlugins(autoLoadPlugins);\n\n    // Initialize loaded plugins\n    for (const [name, result] of loadResults) {\n      if (result.success && result.plugin) {\n        await this.initializePlugin(name, result.plugin);\n      }\n    }\n\n    logger.info('Plugin manager initialization complete', {\n      loaded: loadResults.size,\n      successful: Array.from(loadResults.values()).filter(r => r.success).length,\n    });\n  }\n\n  /**\n   * Load multiple plugins with concurrency control\n   */\n  private async loadPlugins(\n    pluginNames: string[]\n  ): Promise<Map<string, PluginLoadResult>> {\n    const results = new Map<string, PluginLoadResult>();\n    const maxConcurrency = this.config.maxConcurrency ?? 5;\n    const timeout = this.config.loadTimeout ?? 30000;\n\n    // Process in batches\n    for (let i = 0; i < pluginNames.length; i += maxConcurrency) {\n      const batch = pluginNames.slice(i, i + maxConcurrency);\n      const batchPromises = batch.map(async name => {\n        const result = await this.loader.load(name, { timeout });\n        return { name, result };\n      });\n\n      const batchResults = await Promise.allSettled(batchPromises);\n\n      for (const settledResult of batchResults) {\n        if (settledResult.status === 'fulfilled') {\n          const { name, result } = settledResult.value;\n          results.set(name, result);\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Initialize a single plugin with context\n   */\n  private async initializePlugin(name: string, plugin: KGPlugin): Promise<void> {\n    const startTime = Date.now();\n\n    try {\n      // Get or create plugin context\n      const context = this.getPluginContext(name);\n\n      // Initialize the plugin\n      await plugin.initialize(context);\n\n      // Get manifest (create minimal one if not available)\n      const manifest: KGPluginManifest = {\n        name: plugin.name,\n        version: plugin.version,\n        'kg-plugin': {\n          type: plugin.type,\n          main: 'index.js',\n          hooks: this.detectPluginHooks(plugin),\n        },\n      };\n\n      // Register in registry\n      this.registry.register(plugin, manifest);\n      await this.registry.enable(name);\n\n      const meta = this.registry.getMetadata(name);\n      if (meta) {\n        meta.initTime = Date.now() - startTime;\n      }\n\n      logger.info(`Plugin initialized: ${name}`, { initTime: Date.now() - startTime });\n    } catch (error) {\n      logger.error(`Failed to initialize plugin ${name}`, error instanceof Error ? error : undefined);\n      throw error;\n    }\n  }\n\n  /**\n   * Detect which hooks a plugin implements\n   */\n  private detectPluginHooks(plugin: KGPlugin): PluginHook[] {\n    const allHooks: PluginHook[] = [\n      'onGraphLoad',\n      'onGraphSave',\n      'onNodeAdd',\n      'onNodeUpdate',\n      'onNodeRemove',\n      'onEdgeAdd',\n      'onEdgeRemove',\n      'onAnalysisStart',\n      'onAnalysisComplete',\n      'onAgentTaskStart',\n      'onAgentTaskComplete',\n      'onFileChange',\n      'onShutdown',\n    ];\n\n    return allHooks.filter(hook => typeof plugin[hook] === 'function');\n  }\n\n  async install(source: string): Promise<{\n    success: boolean;\n    name?: string;\n    version?: string;\n    error?: string;\n  }> {\n    logger.info(`Installing plugin: ${source}`);\n\n    try {\n      // Check if it's a local path\n      const { stat } = await import('fs/promises');\n      const isLocal = await stat(source).then(() => true).catch(() => false);\n\n      if (isLocal) {\n        // Load from local path\n        const result = await this.loader.loadFromPath(source, { validate: true });\n        if (!result.success) {\n          return { success: false, error: result.error };\n        }\n\n        // Initialize the plugin\n        await this.initializePlugin(result.plugin!.name, result.plugin!);\n\n        return {\n          success: true,\n          name: result.plugin!.name,\n          version: result.plugin!.version,\n        };\n      }\n\n      // For npm packages, we would typically use npm/yarn to install\n      // This is a simplified implementation\n      const result = await this.loader.load(source, { validate: true });\n      if (!result.success) {\n        return { success: false, error: result.error };\n      }\n\n      await this.initializePlugin(result.plugin!.name, result.plugin!);\n\n      return {\n        success: true,\n        name: result.plugin!.name,\n        version: result.plugin!.version,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  async uninstall(name: string): Promise<boolean> {\n    logger.info(`Uninstalling plugin: ${name}`);\n\n    try {\n      // Disable and cleanup\n      const plugin = this.registry.get(name);\n      if (plugin?.onShutdown) {\n        await plugin.onShutdown();\n      }\n\n      // Unregister from registry\n      this.registry.unregister(name);\n\n      // Unload from loader\n      await this.loader.unload(name);\n\n      // Clear context\n      this.contexts.delete(name);\n      this.pluginConfigs.delete(name);\n\n      logger.info(`Plugin uninstalled: ${name}`);\n      return true;\n    } catch (error) {\n      logger.error(`Failed to uninstall plugin ${name}`, error instanceof Error ? error : undefined);\n      return false;\n    }\n  }\n\n  async update(name: string): Promise<{\n    success: boolean;\n    previousVersion?: string;\n    newVersion?: string;\n    error?: string;\n  }> {\n    const currentPlugin = this.registry.get(name);\n    const previousVersion = currentPlugin?.version;\n\n    try {\n      // Reload the plugin\n      const result = await this.loader.reload(name);\n      if (!result.success) {\n        return { success: false, previousVersion, error: result.error };\n      }\n\n      // Reinitialize\n      await this.initializePlugin(name, result.plugin!);\n\n      return {\n        success: true,\n        previousVersion,\n        newVersion: result.plugin!.version,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        previousVersion,\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  async checkUpdates(): Promise<Array<{\n    name: string;\n    currentVersion: string;\n    latestVersion: string;\n  }>> {\n    // This would typically check npm registry for newer versions\n    // Simplified implementation returns empty array\n    logger.debug('Checking for plugin updates...');\n    return [];\n  }\n\n  getConfig(name: string): Record<string, unknown> | undefined {\n    return this.pluginConfigs.get(name);\n  }\n\n  async setConfig(name: string, config: Record<string, unknown>): Promise<void> {\n    this.pluginConfigs.set(name, config);\n\n    // Update the plugin context\n    const context = this.contexts.get(name);\n    if (context) {\n      context.pluginConfig = config;\n    }\n\n    logger.debug(`Plugin config updated: ${name}`);\n  }\n\n  /**\n   * Get plugin context for a specific plugin\n   */\n  getPluginContext(name: string): PluginContext {\n    if (this.contexts.has(name)) {\n      return this.contexts.get(name)!;\n    }\n\n    const pluginConfig = this.pluginConfigs.get(name) ?? {};\n    const pluginPath = this.findPluginPath(name);\n\n    const context: PluginContext = {\n      database: this.database ?? this.createMockDatabase(),\n      graph: this.graph ?? this.createMockGraph(),\n      cache: this.cache ?? this.createMockCache(),\n      logger: createLogger(`plugin:${name}`),\n      config: this.appConfig ?? this.createDefaultConfig(),\n      pluginConfig,\n      events: this.sharedEventEmitter,\n      api: this.createPluginAPI(),\n      projectRoot: this.projectRoot ?? process.cwd(),\n      pluginRoot: pluginPath,\n      abortSignal: this.abortController?.signal,\n    };\n\n    this.contexts.set(name, context);\n    return context;\n  }\n\n  /**\n   * Find the path to a plugin\n   */\n  private findPluginPath(name: string): string {\n    for (const basePath of this.config.searchPaths) {\n      const pluginPath = resolve(basePath, name);\n      return pluginPath;\n    }\n    return resolve(process.cwd(), 'plugins', name);\n  }\n\n  /**\n   * Create plugin API for system interaction\n   */\n  private createPluginAPI(): PluginAPI {\n    return {\n      getPlugin: <T extends KGPlugin>(name: string) => this.registry.get<T>(name),\n      getPluginsByType: (type: PluginType) => this.registry.getByType(type),\n      getAnalyzers: () => this.registry.getAnalyzers(),\n      registerCommand: (command: PluginCommand) => {\n        this.commands.set(command.name, command);\n        logger.debug(`Command registered: ${command.name}`);\n      },\n      unregisterCommand: (name: string) => {\n        this.commands.delete(name);\n      },\n      getVersion: () => '1.0.0', // TODO: Get from package.json\n      hasCapability: (name: string) => {\n        for (const plugin of this.registry.getAll()) {\n          const meta = this.registry.getMetadata(plugin.name);\n          if (meta?.capabilities.includes(name)) {\n            return true;\n          }\n        }\n        return false;\n      },\n    };\n  }\n\n  /**\n   * Invoke a lifecycle hook on all plugins\n   */\n  async invokeHook<T = void>(hook: PluginHook, ...args: unknown[]): Promise<Map<string, T | Error>> {\n    if (this.isShuttingDown && hook !== 'onShutdown') {\n      logger.debug(`Skipping hook ${hook} during shutdown`);\n      return new Map();\n    }\n\n    return this.registry.executeHook<T>(hook, ...args);\n  }\n\n  /**\n   * Enable a specific plugin\n   */\n  async enablePlugin(name: string): Promise<void> {\n    const plugin = this.registry.get(name);\n    if (!plugin) {\n      throw new Error(`Plugin not found: ${name}`);\n    }\n\n    await this.registry.enable(name);\n  }\n\n  /**\n   * Disable a specific plugin\n   */\n  async disablePlugin(name: string): Promise<void> {\n    const plugin = this.registry.get(name);\n    if (!plugin) {\n      throw new Error(`Plugin not found: ${name}`);\n    }\n\n    await this.registry.disable(name);\n  }\n\n  async shutdown(): Promise<void> {\n    if (this.isShuttingDown) {\n      logger.debug('Shutdown already in progress');\n      return;\n    }\n\n    this.isShuttingDown = true;\n    logger.info('Shutting down plugin manager...');\n\n    // Signal abort to all plugins\n    this.abortController?.abort();\n\n    // Invoke shutdown hook on all plugins\n    await this.invokeHook('onShutdown');\n\n    // Clear registry\n    await this.registry.clear();\n\n    // Clear contexts and configs\n    this.contexts.clear();\n    this.pluginConfigs.clear();\n    this.commands.clear();\n\n    logger.info('Plugin manager shutdown complete');\n    this.emit('shutdown');\n  }\n\n  // ========================================================================\n  // Mock implementations for when dependencies aren't set\n  // ========================================================================\n\n  private createMockDatabase(): KnowledgeGraphDatabase {\n    return {\n      query: async () => [],\n      queryOne: async () => null,\n      execute: async () => ({ changes: 0 }),\n      beginTransaction: async () => {},\n      commit: async () => {},\n      rollback: async () => {},\n      isConnected: () => false,\n    };\n  }\n\n  private createMockGraph(): KnowledgeGraphManager {\n    // Create a minimal mock - in real usage, setDependencies should be called\n    return {\n      addNode: () => {},\n      getNode: () => undefined,\n      getAllNodes: () => [],\n      getNodesByType: () => [],\n      getNodesByStatus: () => [],\n      getNodesByTag: () => [],\n      updateNode: () => false,\n      removeNode: () => false,\n      addEdge: () => {},\n      getIncomingEdges: () => [],\n      getOutgoingEdges: () => [],\n      getAllEdges: () => [],\n      findOrphanNodes: () => [],\n      findMostConnected: () => [],\n      findPath: () => null,\n      findRelated: () => [],\n      getStats: () => ({\n        totalNodes: 0,\n        totalEdges: 0,\n        nodesByType: {},\n        nodesByStatus: {},\n        orphanNodes: 0,\n        avgLinksPerNode: 0,\n        mostConnected: [],\n      }),\n      toJSON: () => ({ nodes: new Map(), edges: [], metadata: {} as any }),\n      getMetadata: () => ({} as any),\n    } as unknown as KnowledgeGraphManager;\n  }\n\n  private createMockCache(): ShadowCache {\n    const cache = new Map<string, unknown>();\n    return {\n      get: async (key) => cache.get(key) as any,\n      set: async (key, value) => { cache.set(key, value); },\n      delete: async (key) => cache.delete(key),\n      deleteByTag: async () => 0,\n      clear: async () => { cache.clear(); },\n      has: async (key) => cache.has(key),\n      getStats: async () => ({\n        entries: cache.size,\n        size: 0,\n        hits: 0,\n        misses: 0,\n        hitRate: 0,\n      }),\n    };\n  }\n\n  private createDefaultConfig(): KGConfiguration {\n    return {\n      version: '1.0.0',\n      projectRoot: process.cwd(),\n      docsPath: 'docs',\n      database: {\n        path: '.kg/knowledge.db',\n        autoBackup: true,\n        backupInterval: 86400000,\n        maxBackups: 7,\n      },\n      cache: {\n        enabled: true,\n        maxSize: 1000,\n        ttl: 3600000,\n        evictionPolicy: 'lru',\n      },\n      agents: {\n        maxConcurrent: 5,\n        defaultTimeout: 30000,\n        retryAttempts: 3,\n        claudeFlowEnabled: false,\n      },\n      services: {\n        watcherEnabled: false,\n        schedulerEnabled: false,\n        syncEnabled: false,\n        healthCheckInterval: 60000,\n      },\n      logging: {\n        level: 'info',\n        format: 'text',\n      },\n    };\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\n/**\n * Create a new plugin registry\n */\nexport function createPluginRegistry(): PluginRegistry {\n  return new PluginRegistryImpl();\n}\n\n/**\n * Create a new plugin loader\n */\nexport function createPluginLoader(searchPaths: string[] = []): PluginLoader {\n  return new PluginLoaderImpl(searchPaths);\n}\n\n/**\n * Create a new plugin manager\n */\nexport function createPluginManager(config: PluginManagerConfig): PluginManager {\n  return new PluginManagerImpl(config);\n}\n\n/**\n * Create a plugin manager with default configuration\n */\nexport function createDefaultPluginManager(projectRoot: string): PluginManager {\n  const searchPaths = [\n    resolve(projectRoot, 'plugins'),\n    resolve(projectRoot, 'node_modules'),\n  ];\n\n  return createPluginManager({\n    searchPaths,\n    autoLoad: [],\n    hotReload: false,\n    maxConcurrency: 5,\n    loadTimeout: 30000,\n  });\n}\n"],"names":["result"],"mappings":"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"}