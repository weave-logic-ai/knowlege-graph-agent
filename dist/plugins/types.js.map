{"version":3,"file":"types.js","sources":["../../src/plugins/types.ts"],"sourcesContent":["/**\n * Plugin System Types\n *\n * Complete type definitions for the knowledge-graph-agent plugin system.\n * Supports plugin discovery, loading, lifecycle management, and custom analyzers.\n *\n * @module plugins/types\n */\n\nimport type { EventEmitter } from 'events';\nimport type { KnowledgeGraphManager } from '../core/graph.js';\nimport type { KGConfiguration } from '../config/types.js';\nimport type { Logger } from '../utils/logger.js';\n\n// ============================================================================\n// Plugin Manifest Types (package.json extension)\n// ============================================================================\n\n/**\n * Plugin type classification\n */\nexport type PluginType =\n  | 'analyzer'     // Custom content analyzers\n  | 'transformer'  // Content transformation plugins\n  | 'exporter'     // Export format plugins\n  | 'importer'     // Import format plugins\n  | 'integration'  // External service integrations\n  | 'visualization' // Graph visualization plugins\n  | 'storage'      // Custom storage backends\n  | 'agent'        // Custom agent types\n  | 'hook'         // Lifecycle hook plugins\n  | 'generic';     // General purpose plugins\n\n/**\n * Plugin lifecycle hook names\n */\nexport type PluginHook =\n  | 'onGraphLoad'\n  | 'onGraphSave'\n  | 'onNodeAdd'\n  | 'onNodeUpdate'\n  | 'onNodeRemove'\n  | 'onEdgeAdd'\n  | 'onEdgeRemove'\n  | 'onAnalysisStart'\n  | 'onAnalysisComplete'\n  | 'onAgentTaskStart'\n  | 'onAgentTaskComplete'\n  | 'onFileChange'\n  | 'onShutdown';\n\n/**\n * Plugin capability declaration\n */\nexport interface PluginCapability {\n  /** Capability identifier */\n  name: string;\n\n  /** Human-readable description */\n  description?: string;\n\n  /** Capability version */\n  version?: string;\n\n  /** Whether this capability is optional */\n  optional?: boolean;\n}\n\n/**\n * Plugin dependency specification\n */\nexport interface PluginDependency {\n  /** Plugin package name */\n  name: string;\n\n  /** Semver version range */\n  version: string;\n\n  /** Whether the dependency is optional */\n  optional?: boolean;\n}\n\n/**\n * Plugin configuration schema definition\n */\nexport interface PluginConfigSchema {\n  /** Schema type (JSON Schema compatible) */\n  type: 'object' | 'array' | 'string' | 'number' | 'boolean';\n\n  /** Schema properties for object types */\n  properties?: Record<string, {\n    type: string;\n    description?: string;\n    default?: unknown;\n    required?: boolean;\n    enum?: unknown[];\n  }>;\n\n  /** Required property names */\n  required?: string[];\n\n  /** Default configuration values */\n  defaults?: Record<string, unknown>;\n}\n\n/**\n * Plugin manifest - extends package.json with kg-plugin field\n *\n * @example\n * ```json\n * {\n *   \"name\": \"@kg-plugins/markdown-analyzer\",\n *   \"version\": \"1.0.0\",\n *   \"description\": \"Advanced markdown analysis for knowledge graphs\",\n *   \"kg-plugin\": {\n *     \"type\": \"analyzer\",\n *     \"main\": \"./dist/index.js\",\n *     \"hooks\": [\"onNodeAdd\", \"onAnalysisComplete\"],\n *     \"capabilities\": [\n *       { \"name\": \"markdown-parsing\", \"description\": \"Parse markdown content\" }\n *     ],\n *     \"configSchema\": {\n *       \"type\": \"object\",\n *       \"properties\": {\n *         \"enableGFM\": { \"type\": \"boolean\", \"default\": true }\n *       }\n *     }\n *   }\n * }\n * ```\n */\nexport interface KGPluginManifest {\n  /** Plugin package name (from package.json) */\n  name: string;\n\n  /** Plugin version (semver) */\n  version: string;\n\n  /** Plugin description */\n  description?: string;\n\n  /** Plugin author */\n  author?: string | { name: string; email?: string; url?: string };\n\n  /** Plugin license */\n  license?: string;\n\n  /** Plugin repository */\n  repository?: string | { type: string; url: string };\n\n  /** Plugin keywords for discovery */\n  keywords?: string[];\n\n  /** Knowledge graph plugin configuration */\n  'kg-plugin': {\n    /** Plugin type classification */\n    type: PluginType;\n\n    /** Path to main entry point (relative to package root) */\n    main: string;\n\n    /** Plugin display name */\n    displayName?: string;\n\n    /** Minimum knowledge-graph-agent version required */\n    minVersion?: string;\n\n    /** Maximum knowledge-graph-agent version supported */\n    maxVersion?: string;\n\n    /** Lifecycle hooks this plugin subscribes to */\n    hooks?: PluginHook[];\n\n    /** Plugin capabilities */\n    capabilities?: PluginCapability[];\n\n    /** Plugin dependencies on other plugins */\n    pluginDependencies?: PluginDependency[];\n\n    /** Configuration schema */\n    configSchema?: PluginConfigSchema;\n\n    /** Whether the plugin supports hot reload */\n    hotReload?: boolean;\n\n    /** Priority for hook execution (lower = earlier, default: 100) */\n    priority?: number;\n\n    /** Tags for categorization */\n    tags?: string[];\n  };\n\n  /** Standard package.json fields */\n  main?: string;\n  types?: string;\n  exports?: Record<string, unknown>;\n  dependencies?: Record<string, string>;\n  peerDependencies?: Record<string, string>;\n}\n\n// ============================================================================\n// Plugin Context Types\n// ============================================================================\n\n/**\n * Database interface for plugin context\n */\nexport interface KnowledgeGraphDatabase {\n  /** Execute a query and return results */\n  query<T = unknown>(sql: string, params?: unknown[]): Promise<T[]>;\n\n  /** Execute a query and return first result */\n  queryOne<T = unknown>(sql: string, params?: unknown[]): Promise<T | null>;\n\n  /** Execute a mutation (insert, update, delete) */\n  execute(sql: string, params?: unknown[]): Promise<{ changes: number; lastInsertRowid?: number | bigint }>;\n\n  /** Begin a transaction */\n  beginTransaction(): Promise<void>;\n\n  /** Commit a transaction */\n  commit(): Promise<void>;\n\n  /** Rollback a transaction */\n  rollback(): Promise<void>;\n\n  /** Check if the database is connected */\n  isConnected(): boolean;\n}\n\n/**\n * Shadow cache interface for plugin context\n */\nexport interface ShadowCache {\n  /** Get a cached value */\n  get<T>(key: string): Promise<T | undefined>;\n\n  /** Set a cached value */\n  set<T>(key: string, value: T, options?: { ttl?: number; tags?: string[] }): Promise<void>;\n\n  /** Delete a cached value */\n  delete(key: string): Promise<boolean>;\n\n  /** Delete all values with a specific tag */\n  deleteByTag(tag: string): Promise<number>;\n\n  /** Clear all cached values */\n  clear(): Promise<void>;\n\n  /** Check if a key exists */\n  has(key: string): Promise<boolean>;\n\n  /** Get cache statistics */\n  getStats(): Promise<{\n    entries: number;\n    size: number;\n    hits: number;\n    misses: number;\n    hitRate: number;\n  }>;\n}\n\n/**\n * Plugin event emitter for inter-plugin communication\n */\nexport interface PluginEventEmitter extends EventEmitter {\n  /** Emit an event to all registered listeners */\n  emit(event: string, ...args: unknown[]): boolean;\n\n  /** Subscribe to an event */\n  on(event: string, listener: (...args: unknown[]) => void): this;\n\n  /** Subscribe to an event once */\n  once(event: string, listener: (...args: unknown[]) => void): this;\n\n  /** Unsubscribe from an event */\n  off(event: string, listener: (...args: unknown[]) => void): this;\n\n  /** Get all registered event names */\n  eventNames(): (string | symbol)[];\n}\n\n/**\n * Plugin API for interacting with the knowledge graph system\n */\nexport interface PluginAPI {\n  /** Get plugin by name */\n  getPlugin<T extends KGPlugin = KGPlugin>(name: string): T | undefined;\n\n  /** Get all plugins of a specific type */\n  getPluginsByType(type: PluginType): KGPlugin[];\n\n  /** Get all analyzer plugins */\n  getAnalyzers(): AnalyzerPlugin[];\n\n  /** Register a custom command */\n  registerCommand(command: PluginCommand): void;\n\n  /** Unregister a custom command */\n  unregisterCommand(name: string): void;\n\n  /** Get the current knowledge graph agent version */\n  getVersion(): string;\n\n  /** Check if a capability is available */\n  hasCapability(name: string): boolean;\n}\n\n/**\n * Plugin command registration\n */\nexport interface PluginCommand {\n  /** Command name (used in CLI) */\n  name: string;\n\n  /** Command description */\n  description: string;\n\n  /** Command aliases */\n  aliases?: string[];\n\n  /** Command options */\n  options?: Array<{\n    name: string;\n    description: string;\n    type: 'string' | 'number' | 'boolean';\n    required?: boolean;\n    default?: unknown;\n  }>;\n\n  /** Command handler */\n  handler: (args: Record<string, unknown>, context: PluginContext) => Promise<void>;\n}\n\n/**\n * Plugin context provided during initialization and execution\n */\nexport interface PluginContext {\n  /** Database instance for persistent storage */\n  database: KnowledgeGraphDatabase;\n\n  /** Knowledge graph manager instance */\n  graph: KnowledgeGraphManager;\n\n  /** Shadow cache for temporary storage */\n  cache: ShadowCache;\n\n  /** Logger instance scoped to the plugin */\n  logger: Logger;\n\n  /** Current configuration */\n  config: KGConfiguration;\n\n  /** Plugin configuration (from user config or defaults) */\n  pluginConfig: Record<string, unknown>;\n\n  /** Event emitter for plugin communication */\n  events: PluginEventEmitter;\n\n  /** Plugin API for system interaction */\n  api: PluginAPI;\n\n  /** Root path of the project */\n  projectRoot: string;\n\n  /** Path to the plugin's package directory */\n  pluginRoot: string;\n\n  /** Abort signal for graceful shutdown */\n  abortSignal?: AbortSignal;\n}\n\n// ============================================================================\n// Base Plugin Interface\n// ============================================================================\n\n/**\n * Plugin status\n */\nexport type PluginStatus =\n  | 'unloaded'\n  | 'loading'\n  | 'initialized'\n  | 'active'\n  | 'error'\n  | 'disabled';\n\n/**\n * Plugin metadata at runtime\n */\nexport interface PluginMetadata {\n  /** Plugin name */\n  name: string;\n\n  /** Plugin version */\n  version: string;\n\n  /** Plugin type */\n  type: PluginType;\n\n  /** Plugin status */\n  status: PluginStatus;\n\n  /** Load time in milliseconds */\n  loadTime?: number;\n\n  /** Initialize time in milliseconds */\n  initTime?: number;\n\n  /** Last error if status is 'error' */\n  lastError?: string;\n\n  /** Registered hooks */\n  hooks: PluginHook[];\n\n  /** Available capabilities */\n  capabilities: string[];\n}\n\n/**\n * Base plugin interface that all plugins must implement\n */\nexport interface KGPlugin {\n  /** Plugin name (must match manifest) */\n  readonly name: string;\n\n  /** Plugin version (must match manifest) */\n  readonly version: string;\n\n  /** Plugin type */\n  readonly type: PluginType;\n\n  /**\n   * Initialize the plugin\n   *\n   * Called once when the plugin is loaded. Use this to set up resources,\n   * register event listeners, and validate configuration.\n   *\n   * @param context - Plugin context with system access\n   * @throws Error if initialization fails\n   */\n  initialize(context: PluginContext): Promise<void>;\n\n  /**\n   * Destroy the plugin (optional)\n   *\n   * Called when the plugin is being unloaded. Use this to clean up resources,\n   * close connections, and remove event listeners.\n   */\n  destroy?(): Promise<void>;\n\n  /**\n   * Get plugin health status (optional)\n   *\n   * @returns Health status information\n   */\n  healthCheck?(): Promise<{\n    healthy: boolean;\n    message?: string;\n    details?: Record<string, unknown>;\n  }>;\n\n  /**\n   * Get plugin statistics (optional)\n   *\n   * @returns Plugin-specific statistics\n   */\n  getStats?(): Promise<Record<string, unknown>>;\n\n  // ========================================================================\n  // Lifecycle Hooks (optional)\n  // ========================================================================\n\n  /** Called when the knowledge graph is loaded */\n  onGraphLoad?(graph: KnowledgeGraphManager): Promise<void>;\n\n  /** Called before the knowledge graph is saved */\n  onGraphSave?(graph: KnowledgeGraphManager): Promise<void>;\n\n  /** Called when a node is added to the graph */\n  onNodeAdd?(nodeId: string, nodeData: unknown): Promise<void>;\n\n  /** Called when a node is updated */\n  onNodeUpdate?(nodeId: string, changes: unknown): Promise<void>;\n\n  /** Called when a node is removed */\n  onNodeRemove?(nodeId: string): Promise<void>;\n\n  /** Called when an edge is added */\n  onEdgeAdd?(sourceId: string, targetId: string, edgeData: unknown): Promise<void>;\n\n  /** Called when an edge is removed */\n  onEdgeRemove?(sourceId: string, targetId: string): Promise<void>;\n\n  /** Called when analysis starts */\n  onAnalysisStart?(analysisType: string): Promise<void>;\n\n  /** Called when analysis completes */\n  onAnalysisComplete?(analysisType: string, results: unknown): Promise<void>;\n\n  /** Called when an agent task starts */\n  onAgentTaskStart?(agentId: string, taskId: string, taskData: unknown): Promise<void>;\n\n  /** Called when an agent task completes */\n  onAgentTaskComplete?(agentId: string, taskId: string, result: unknown): Promise<void>;\n\n  /** Called when a file changes */\n  onFileChange?(filePath: string, changeType: 'add' | 'change' | 'unlink'): Promise<void>;\n\n  /** Called during shutdown */\n  onShutdown?(): Promise<void>;\n}\n\n// ============================================================================\n// Analyzer Plugin Interface\n// ============================================================================\n\n/**\n * Analysis input data\n */\nexport interface AnalysisInput {\n  /** Unique identifier for this analysis */\n  id: string;\n\n  /** Content to analyze */\n  content: string;\n\n  /** Content type (e.g., 'markdown', 'typescript', 'json') */\n  contentType: string;\n\n  /** Source file path (if applicable) */\n  filePath?: string;\n\n  /** Related node IDs for context */\n  relatedNodes?: string[];\n\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n\n  /** Analysis options */\n  options?: Record<string, unknown>;\n}\n\n/**\n * Analysis result structure\n */\nexport interface AnalysisResult {\n  /** Whether analysis was successful */\n  success: boolean;\n\n  /** Analysis type identifier */\n  analysisType: string;\n\n  /** Extracted entities */\n  entities?: Array<{\n    id: string;\n    type: string;\n    value: string;\n    confidence: number;\n    position?: { start: number; end: number };\n    metadata?: Record<string, unknown>;\n  }>;\n\n  /** Extracted relationships */\n  relationships?: Array<{\n    sourceId: string;\n    targetId: string;\n    type: string;\n    confidence: number;\n    metadata?: Record<string, unknown>;\n  }>;\n\n  /** Extracted tags/keywords */\n  tags?: Array<{\n    value: string;\n    confidence: number;\n    category?: string;\n  }>;\n\n  /** Content summary */\n  summary?: string;\n\n  /** Quality score (0-1) */\n  qualityScore?: number;\n\n  /** Analysis metrics */\n  metrics?: {\n    durationMs: number;\n    tokensProcessed?: number;\n    entitiesFound?: number;\n    relationshipsFound?: number;\n  };\n\n  /** Suggestions for improvement */\n  suggestions?: Array<{\n    type: 'add_link' | 'add_tag' | 'fix_format' | 'add_content' | 'other';\n    message: string;\n    confidence: number;\n    action?: Record<string, unknown>;\n  }>;\n\n  /** Raw analysis data for debugging */\n  raw?: unknown;\n\n  /** Error information if analysis failed */\n  error?: {\n    code: string;\n    message: string;\n    details?: Record<string, unknown>;\n  };\n}\n\n/**\n * Stream chunk for streaming analysis\n */\nexport interface AnalysisStreamChunk {\n  /** Chunk type */\n  type: 'entity' | 'relationship' | 'tag' | 'progress' | 'error' | 'complete';\n\n  /** Chunk data */\n  data: unknown;\n\n  /** Progress percentage (0-100) for progress chunks */\n  progress?: number;\n\n  /** Timestamp */\n  timestamp: Date;\n}\n\n/**\n * Analyzer plugin interface for custom content analysis\n */\nexport interface AnalyzerPlugin extends KGPlugin {\n  readonly type: 'analyzer';\n\n  /**\n   * Supported content types for this analyzer\n   */\n  readonly supportedContentTypes: string[];\n\n  /**\n   * Analyze content and return structured results\n   *\n   * @param input - Analysis input data\n   * @returns Analysis results\n   */\n  analyze(input: AnalysisInput): Promise<AnalysisResult>;\n\n  /**\n   * Stream analysis results (optional)\n   *\n   * For large content, streaming provides incremental results.\n   *\n   * @param input - Analysis input data\n   * @returns Async iterable of analysis chunks\n   */\n  analyzeStream?(input: AnalysisInput): AsyncIterable<AnalysisStreamChunk>;\n\n  /**\n   * Check if this analyzer can handle the given content\n   *\n   * @param contentType - Content type to check\n   * @returns Whether this analyzer supports the content type\n   */\n  canAnalyze(contentType: string): boolean;\n\n  /**\n   * Get analyzer-specific configuration options\n   *\n   * @returns Configuration options with descriptions\n   */\n  getConfigOptions?(): Record<string, {\n    type: 'string' | 'number' | 'boolean' | 'array' | 'object';\n    description: string;\n    default?: unknown;\n    required?: boolean;\n  }>;\n}\n\n// ============================================================================\n// Plugin Loader Interface\n// ============================================================================\n\n/**\n * Plugin discovery result\n */\nexport interface DiscoveredPlugin {\n  /** Plugin manifest */\n  manifest: KGPluginManifest;\n\n  /** Absolute path to the plugin package */\n  path: string;\n\n  /** Whether the plugin is locally installed */\n  isLocal: boolean;\n\n  /** Whether the plugin is valid */\n  valid: boolean;\n\n  /** Validation errors if not valid */\n  errors?: string[];\n}\n\n/**\n * Plugin load options\n */\nexport interface PluginLoadOptions {\n  /** Plugin configuration to pass */\n  config?: Record<string, unknown>;\n\n  /** Force reload even if already loaded */\n  force?: boolean;\n\n  /** Validate plugin before loading */\n  validate?: boolean;\n\n  /** Timeout for initialization in milliseconds */\n  timeout?: number;\n}\n\n/**\n * Plugin load result\n */\nexport interface PluginLoadResult {\n  /** Whether loading was successful */\n  success: boolean;\n\n  /** Loaded plugin instance (if successful) */\n  plugin?: KGPlugin;\n\n  /** Plugin metadata */\n  metadata?: PluginMetadata;\n\n  /** Error message (if failed) */\n  error?: string;\n\n  /** Load duration in milliseconds */\n  loadTime: number;\n}\n\n/**\n * Plugin loader interface for discovering and loading plugins\n */\nexport interface PluginLoader {\n  /**\n   * Discover available plugins\n   *\n   * Searches configured paths for valid plugin packages.\n   *\n   * @returns Array of discovered plugin manifests\n   */\n  discover(): Promise<DiscoveredPlugin[]>;\n\n  /**\n   * Load a plugin by name\n   *\n   * @param name - Plugin package name\n   * @param options - Load options\n   * @returns Load result\n   */\n  load(name: string, options?: PluginLoadOptions): Promise<PluginLoadResult>;\n\n  /**\n   * Load a plugin from a specific path\n   *\n   * @param path - Absolute path to plugin package\n   * @param options - Load options\n   * @returns Load result\n   */\n  loadFromPath(path: string, options?: PluginLoadOptions): Promise<PluginLoadResult>;\n\n  /**\n   * Unload a plugin by name\n   *\n   * @param name - Plugin package name\n   * @returns Whether unload was successful\n   */\n  unload(name: string): Promise<boolean>;\n\n  /**\n   * Reload a plugin\n   *\n   * @param name - Plugin package name\n   * @returns Load result\n   */\n  reload(name: string): Promise<PluginLoadResult>;\n\n  /**\n   * Get a loaded plugin by name\n   *\n   * @param name - Plugin package name\n   * @returns Plugin instance or undefined\n   */\n  get(name: string): KGPlugin | undefined;\n\n  /**\n   * Check if a plugin is loaded\n   *\n   * @param name - Plugin package name\n   * @returns Whether the plugin is loaded\n   */\n  isLoaded(name: string): boolean;\n\n  /**\n   * Get all loaded plugins\n   *\n   * @returns Array of loaded plugin instances\n   */\n  getAll(): KGPlugin[];\n\n  /**\n   * Validate a plugin manifest\n   *\n   * @param manifest - Plugin manifest to validate\n   * @returns Validation result\n   */\n  validateManifest(manifest: KGPluginManifest): {\n    valid: boolean;\n    errors: string[];\n    warnings: string[];\n  };\n\n  /**\n   * Set plugin search paths\n   *\n   * @param paths - Array of paths to search for plugins\n   */\n  setSearchPaths(paths: string[]): void;\n\n  /**\n   * Get current plugin search paths\n   *\n   * @returns Array of search paths\n   */\n  getSearchPaths(): string[];\n}\n\n// ============================================================================\n// Plugin Registry Interface\n// ============================================================================\n\n/**\n * Plugin registry events\n */\nexport interface PluginRegistryEvents {\n  /** Emitted when a plugin is registered */\n  registered: { plugin: KGPlugin; metadata: PluginMetadata };\n\n  /** Emitted when a plugin is unregistered */\n  unregistered: { name: string };\n\n  /** Emitted when a plugin is enabled */\n  enabled: { name: string };\n\n  /** Emitted when a plugin is disabled */\n  disabled: { name: string };\n\n  /** Emitted when a plugin encounters an error */\n  error: { name: string; error: Error };\n\n  /** Emitted when a hook is executed */\n  hookExecuted: { hook: PluginHook; plugins: string[]; duration: number };\n}\n\n/**\n * Plugin registry for managing loaded plugins\n */\nexport interface PluginRegistry {\n  /**\n   * Register a plugin\n   *\n   * @param plugin - Plugin instance to register\n   * @param manifest - Plugin manifest\n   */\n  register(plugin: KGPlugin, manifest: KGPluginManifest): void;\n\n  /**\n   * Unregister a plugin\n   *\n   * @param name - Plugin name to unregister\n   * @returns Whether the plugin was found and unregistered\n   */\n  unregister(name: string): boolean;\n\n  /**\n   * Get a plugin by name\n   *\n   * @param name - Plugin name\n   * @returns Plugin instance or undefined\n   */\n  get<T extends KGPlugin = KGPlugin>(name: string): T | undefined;\n\n  /**\n   * Get all registered plugins\n   *\n   * @returns Array of all registered plugins\n   */\n  getAll(): KGPlugin[];\n\n  /**\n   * Get plugins by type\n   *\n   * @param type - Plugin type to filter\n   * @returns Array of plugins of the specified type\n   */\n  getByType<T extends KGPlugin = KGPlugin>(type: PluginType): T[];\n\n  /**\n   * Get all analyzer plugins\n   *\n   * @returns Array of analyzer plugins\n   */\n  getAnalyzers(): AnalyzerPlugin[];\n\n  /**\n   * Check if a plugin is registered\n   *\n   * @param name - Plugin name\n   * @returns Whether the plugin is registered\n   */\n  has(name: string): boolean;\n\n  /**\n   * Get plugin metadata\n   *\n   * @param name - Plugin name\n   * @returns Plugin metadata or undefined\n   */\n  getMetadata(name: string): PluginMetadata | undefined;\n\n  /**\n   * Enable a plugin\n   *\n   * @param name - Plugin name\n   * @returns Whether the plugin was enabled\n   */\n  enable(name: string): Promise<boolean>;\n\n  /**\n   * Disable a plugin\n   *\n   * @param name - Plugin name\n   * @returns Whether the plugin was disabled\n   */\n  disable(name: string): Promise<boolean>;\n\n  /**\n   * Execute a lifecycle hook on all applicable plugins\n   *\n   * @param hook - Hook name to execute\n   * @param args - Arguments to pass to the hook\n   * @returns Results from each plugin\n   */\n  executeHook<T = void>(\n    hook: PluginHook,\n    ...args: unknown[]\n  ): Promise<Map<string, T | Error>>;\n\n  /**\n   * Get plugins that subscribe to a specific hook\n   *\n   * @param hook - Hook name\n   * @returns Array of plugin names\n   */\n  getHookSubscribers(hook: PluginHook): string[];\n\n  /**\n   * Get registry statistics\n   *\n   * @returns Registry statistics\n   */\n  getStats(): {\n    totalPlugins: number;\n    activePlugins: number;\n    disabledPlugins: number;\n    errorPlugins: number;\n    pluginsByType: Record<PluginType, number>;\n    hookSubscriptions: Record<PluginHook, number>;\n  };\n\n  /**\n   * Subscribe to registry events\n   *\n   * @param event - Event name\n   * @param listener - Event listener\n   */\n  on<K extends keyof PluginRegistryEvents>(\n    event: K,\n    listener: (data: PluginRegistryEvents[K]) => void\n  ): void;\n\n  /**\n   * Unsubscribe from registry events\n   *\n   * @param event - Event name\n   * @param listener - Event listener\n   */\n  off<K extends keyof PluginRegistryEvents>(\n    event: K,\n    listener: (data: PluginRegistryEvents[K]) => void\n  ): void;\n\n  /**\n   * Clear all registered plugins\n   */\n  clear(): Promise<void>;\n}\n\n// ============================================================================\n// Plugin Manager Interface\n// ============================================================================\n\n/**\n * Plugin manager configuration\n */\nexport interface PluginManagerConfig {\n  /** Paths to search for plugins */\n  searchPaths: string[];\n\n  /** Plugins to auto-load on initialization */\n  autoLoad?: string[];\n\n  /** Whether to enable hot reload */\n  hotReload?: boolean;\n\n  /** Default plugin configuration */\n  defaultConfig?: Record<string, Record<string, unknown>>;\n\n  /** Logger instance */\n  logger?: Logger;\n\n  /** Maximum plugin load concurrency */\n  maxConcurrency?: number;\n\n  /** Plugin load timeout in milliseconds */\n  loadTimeout?: number;\n}\n\n/**\n * Plugin manager for high-level plugin operations\n */\nexport interface PluginManager {\n  /** Plugin loader instance */\n  readonly loader: PluginLoader;\n\n  /** Plugin registry instance */\n  readonly registry: PluginRegistry;\n\n  /**\n   * Initialize the plugin manager\n   *\n   * Discovers and loads configured plugins.\n   */\n  initialize(): Promise<void>;\n\n  /**\n   * Install a plugin from npm or local path\n   *\n   * @param source - npm package name or local path\n   * @returns Installation result\n   */\n  install(source: string): Promise<{\n    success: boolean;\n    name?: string;\n    version?: string;\n    error?: string;\n  }>;\n\n  /**\n   * Uninstall a plugin\n   *\n   * @param name - Plugin name to uninstall\n   * @returns Whether uninstallation was successful\n   */\n  uninstall(name: string): Promise<boolean>;\n\n  /**\n   * Update a plugin to the latest version\n   *\n   * @param name - Plugin name to update\n   * @returns Update result\n   */\n  update(name: string): Promise<{\n    success: boolean;\n    previousVersion?: string;\n    newVersion?: string;\n    error?: string;\n  }>;\n\n  /**\n   * Check for plugin updates\n   *\n   * @returns Available updates\n   */\n  checkUpdates(): Promise<Array<{\n    name: string;\n    currentVersion: string;\n    latestVersion: string;\n  }>>;\n\n  /**\n   * Get plugin configuration\n   *\n   * @param name - Plugin name\n   * @returns Plugin configuration\n   */\n  getConfig(name: string): Record<string, unknown> | undefined;\n\n  /**\n   * Set plugin configuration\n   *\n   * @param name - Plugin name\n   * @param config - Configuration to set\n   */\n  setConfig(name: string, config: Record<string, unknown>): Promise<void>;\n\n  /**\n   * Shutdown the plugin manager\n   *\n   * Destroys all loaded plugins and cleans up resources.\n   */\n  shutdown(): Promise<void>;\n}\n\n// ============================================================================\n// Type Guards\n// ============================================================================\n\n/**\n * Type guard for checking if a plugin is an AnalyzerPlugin\n */\nexport function isAnalyzerPlugin(plugin: KGPlugin): plugin is AnalyzerPlugin {\n  return (\n    plugin.type === 'analyzer' &&\n    'analyze' in plugin &&\n    typeof (plugin as AnalyzerPlugin).analyze === 'function' &&\n    'supportedContentTypes' in plugin &&\n    Array.isArray((plugin as AnalyzerPlugin).supportedContentTypes)\n  );\n}\n\n/**\n * Type guard for checking if an object is a valid plugin manifest\n */\nexport function isPluginManifest(obj: unknown): obj is KGPluginManifest {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const manifest = obj as Record<string, unknown>;\n\n  return (\n    typeof manifest.name === 'string' &&\n    typeof manifest.version === 'string' &&\n    typeof manifest['kg-plugin'] === 'object' &&\n    manifest['kg-plugin'] !== null &&\n    typeof (manifest['kg-plugin'] as Record<string, unknown>).type === 'string' &&\n    typeof (manifest['kg-plugin'] as Record<string, unknown>).main === 'string'\n  );\n}\n\n/**\n * Type guard for checking if an object is an AnalysisResult\n */\nexport function isAnalysisResult(obj: unknown): obj is AnalysisResult {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const result = obj as Record<string, unknown>;\n\n  return (\n    typeof result.success === 'boolean' &&\n    typeof result.analysisType === 'string'\n  );\n}\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\n/**\n * Extract the configuration type from a plugin manifest\n */\nexport type PluginConfigType<T extends KGPluginManifest> =\n  T['kg-plugin']['configSchema'] extends PluginConfigSchema\n    ? Record<string, unknown>\n    : Record<string, unknown>;\n\n/**\n * Plugin factory function type\n */\nexport type PluginFactory = () => KGPlugin | Promise<KGPlugin>;\n\n/**\n * Plugin constructor type\n */\nexport interface PluginConstructor {\n  new (): KGPlugin;\n}\n\n/**\n * Plugin module default export types\n */\nexport type PluginModuleExport = KGPlugin | PluginFactory | PluginConstructor;\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Create a unique plugin instance ID\n */\nexport function createPluginId(name: string): string {\n  return `plugin_${name}_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n\n/**\n * Validate semver version string\n */\nexport function isValidSemver(version: string): boolean {\n  const semverRegex = /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n  return semverRegex.test(version);\n}\n\n/**\n * Get default plugin metadata\n */\nexport function createDefaultPluginMetadata(\n  name: string,\n  version: string,\n  type: PluginType\n): PluginMetadata {\n  return {\n    name,\n    version,\n    type,\n    status: 'unloaded',\n    hooks: [],\n    capabilities: [],\n  };\n}\n"],"names":[],"mappings":"AA2mCO,SAAS,iBAAiB,QAA4C;AAC3E,SACE,OAAO,SAAS,cAChB,aAAa,UACb,OAAQ,OAA0B,YAAY,cAC9C,2BAA2B,UAC3B,MAAM,QAAS,OAA0B,qBAAqB;AAElE;AAKO,SAAS,iBAAiB,KAAuC;AACtE,MAAI,OAAO,QAAQ,YAAY,QAAQ,MAAM;AAC3C,WAAO;AAAA,EACT;AAEA,QAAM,WAAW;AAEjB,SACE,OAAO,SAAS,SAAS,YACzB,OAAO,SAAS,YAAY,YAC5B,OAAO,SAAS,WAAW,MAAM,YACjC,SAAS,WAAW,MAAM,QAC1B,OAAQ,SAAS,WAAW,EAA8B,SAAS,YACnE,OAAQ,SAAS,WAAW,EAA8B,SAAS;AAEvE;AAKO,SAAS,iBAAiB,KAAqC;AACpE,MAAI,OAAO,QAAQ,YAAY,QAAQ,MAAM;AAC3C,WAAO;AAAA,EACT;AAEA,QAAM,SAAS;AAEf,SACE,OAAO,OAAO,YAAY,aAC1B,OAAO,OAAO,iBAAiB;AAEnC;AAsCO,SAAS,eAAe,MAAsB;AACnD,SAAO,UAAU,IAAI,IAAI,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,UAAU,GAAG,CAAC,CAAC;AACnF;AAKO,SAAS,cAAc,SAA0B;AACtD,QAAM,cAAc;AACpB,SAAO,YAAY,KAAK,OAAO;AACjC;AAKO,SAAS,4BACd,MACA,SACA,MACgB;AAChB,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,CAAA;AAAA,IACP,cAAc,CAAA;AAAA,EAAC;AAEnB;"}