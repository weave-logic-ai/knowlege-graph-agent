{"version":3,"file":"event-bus.js","sources":["../../src/server/event-bus.ts"],"sourcesContent":["/**\n * TypedEventBus - Cross-Service Communication\n *\n * Provides strongly-typed event pub/sub for communication between\n * MCP, GraphQL, Dashboard, and other services. Features include:\n * - TypeScript generics for type-safe events\n * - Event history with configurable retention\n * - Event filtering by type and source\n * - Async event handlers with error isolation\n * - Integration with GraphQL subscriptions\n * - Metrics tracking (event counts, latency)\n *\n * @module server/event-bus\n */\n\nimport { EventEmitter } from 'events';\nimport { createLogger } from '../utils/index.js';\n\nconst logger = createLogger('event-bus');\n\n// ============================================================================\n// Event Type Definitions\n// ============================================================================\n\n/**\n * All supported event types in the system\n */\nexport type EventType =\n  // Node events\n  | 'NodeCreated'\n  | 'NodeUpdated'\n  | 'NodeDeleted'\n  // Relation events\n  | 'RelationCreated'\n  | 'RelationDeleted'\n  // Agent events\n  | 'AgentSpawned'\n  | 'AgentCompleted'\n  | 'AgentFailed'\n  // Workflow events\n  | 'WorkflowStarted'\n  | 'WorkflowProgress'\n  | 'WorkflowCompleted'\n  // Plugin events\n  | 'PluginLoaded'\n  | 'PluginError'\n  // Health events\n  | 'HealthCheckFailed'\n  | 'HealthCheckRecovered'\n  // Cache events\n  | 'CacheEviction';\n\n/**\n * Node-related event data\n */\nexport interface NodeEventData {\n  nodeId: string;\n  path: string;\n  type: string;\n  title?: string;\n  previousState?: Record<string, unknown>;\n  newState?: Record<string, unknown>;\n}\n\n/**\n * Relation-related event data\n */\nexport interface RelationEventData {\n  sourceId: string;\n  targetId: string;\n  relationType: string;\n  context?: string;\n}\n\n/**\n * Agent-related event data\n */\nexport interface AgentEventData {\n  agentId: string;\n  agentType: string;\n  taskId?: string;\n  result?: unknown;\n  error?: string;\n  duration?: number;\n}\n\n/**\n * Workflow-related event data\n */\nexport interface WorkflowEventData {\n  workflowId: string;\n  executionId: string;\n  stepId?: string;\n  progress?: number;\n  result?: unknown;\n  error?: string;\n}\n\n/**\n * Plugin-related event data\n */\nexport interface PluginEventData {\n  pluginId: string;\n  pluginName: string;\n  version?: string;\n  error?: string;\n}\n\n/**\n * Health check event data\n */\nexport interface HealthEventData {\n  component: string;\n  reason?: string;\n  metrics?: Record<string, number | string>;\n}\n\n/**\n * Cache eviction event data\n */\nexport interface CacheEvictionData {\n  key: string;\n  reason: 'ttl' | 'capacity' | 'manual';\n  age?: number;\n}\n\n/**\n * Mapping of event types to their data types\n */\nexport interface EventDataMap {\n  NodeCreated: NodeEventData;\n  NodeUpdated: NodeEventData;\n  NodeDeleted: NodeEventData;\n  RelationCreated: RelationEventData;\n  RelationDeleted: RelationEventData;\n  AgentSpawned: AgentEventData;\n  AgentCompleted: AgentEventData;\n  AgentFailed: AgentEventData;\n  WorkflowStarted: WorkflowEventData;\n  WorkflowProgress: WorkflowEventData;\n  WorkflowCompleted: WorkflowEventData;\n  PluginLoaded: PluginEventData;\n  PluginError: PluginEventData;\n  HealthCheckFailed: HealthEventData;\n  HealthCheckRecovered: HealthEventData;\n  CacheEviction: CacheEvictionData;\n}\n\n// ============================================================================\n// Event Entry and Filter Types\n// ============================================================================\n\n/**\n * Immutable event entry stored in history\n */\nexport interface EventEntry<T extends EventType = EventType> {\n  /** Unique event ID */\n  readonly id: string;\n  /** Event type */\n  readonly type: T;\n  /** Event data */\n  readonly data: EventDataMap[T];\n  /** Source of the event (e.g., 'mcp-server', 'graphql-resolver') */\n  readonly source: string;\n  /** When the event occurred */\n  readonly timestamp: Date;\n  /** Processing latency in milliseconds (set after handlers complete) */\n  readonly latency?: number;\n}\n\n/**\n * Filter for querying event history\n */\nexport interface EventFilter {\n  /** Filter by event types */\n  types?: EventType[];\n  /** Filter by source */\n  source?: string;\n  /** Filter by source pattern (regex) */\n  sourcePattern?: RegExp;\n  /** Start time (inclusive) */\n  since?: Date;\n  /** End time (exclusive) */\n  until?: Date;\n  /** Maximum number of events to return */\n  limit?: number;\n  /** Skip first N events */\n  offset?: number;\n}\n\n/**\n * Event handler function type\n */\nexport type EventHandler<T extends EventType> = (\n  data: EventDataMap[T],\n  entry: EventEntry<T>\n) => void | Promise<void>;\n\n/**\n * Unsubscribe function type\n */\nexport type Unsubscribe = () => void;\n\n// ============================================================================\n// Metrics Types\n// ============================================================================\n\n/**\n * Metrics for a specific event type\n */\nexport interface EventTypeMetrics {\n  /** Total events emitted */\n  count: number;\n  /** Number of handler errors */\n  errorCount: number;\n  /** Average processing latency in ms */\n  avgLatency: number;\n  /** Maximum processing latency in ms */\n  maxLatency: number;\n  /** Last event timestamp */\n  lastEvent?: Date;\n}\n\n/**\n * Overall event bus metrics\n */\nexport interface EventBusMetrics {\n  /** Total events emitted across all types */\n  totalEvents: number;\n  /** Total handler errors across all types */\n  totalErrors: number;\n  /** Events per type */\n  byType: Partial<Record<EventType, EventTypeMetrics>>;\n  /** Current history size */\n  historySize: number;\n  /** Active subscriber count */\n  subscriberCount: number;\n}\n\n// ============================================================================\n// TypedEventBus Interface\n// ============================================================================\n\n/**\n * TypedEventBus interface for cross-service communication\n */\nexport interface ITypedEventBus {\n  /**\n   * Emit an event with typed data\n   */\n  emit<T extends EventType>(event: T, data: EventDataMap[T], source?: string): void;\n\n  /**\n   * Subscribe to an event type\n   */\n  on<T extends EventType>(event: T, handler: EventHandler<T>): Unsubscribe;\n\n  /**\n   * Subscribe to an event type for a single occurrence\n   */\n  once<T extends EventType>(event: T, handler: EventHandler<T>): Unsubscribe;\n\n  /**\n   * Unsubscribe a specific handler\n   */\n  off<T extends EventType>(event: T, handler: EventHandler<T>): void;\n\n  /**\n   * Get event history with optional filtering\n   */\n  getHistory(filter?: EventFilter): EventEntry[];\n\n  /**\n   * Get event bus metrics\n   */\n  getMetrics(): EventBusMetrics;\n\n  /**\n   * Clear event history\n   */\n  clearHistory(): void;\n\n  /**\n   * Subscribe to all events (wildcard)\n   */\n  onAny(handler: (entry: EventEntry) => void | Promise<void>): Unsubscribe;\n\n  /**\n   * Get the underlying EventEmitter for GraphQL subscriptions\n   */\n  getEmitter(): EventEmitter;\n}\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\n/**\n * TypedEventBus configuration options\n */\nexport interface TypedEventBusOptions {\n  /** Maximum history entries to retain (default: 1000) */\n  maxHistorySize?: number;\n  /** History retention time in milliseconds (default: 1 hour) */\n  historyRetention?: number;\n  /** Maximum listeners per event (default: 100) */\n  maxListeners?: number;\n  /** Log events at debug level (default: false) */\n  debugEvents?: boolean;\n}\n\n// ============================================================================\n// TypedEventBus Implementation\n// ============================================================================\n\n/**\n * TypedEventBus\n *\n * Strongly-typed event emitter with history, filtering, and metrics.\n * Provides error isolation so one failing handler doesn't affect others.\n *\n * @example\n * ```typescript\n * const eventBus = createTypedEventBus({ maxHistorySize: 500 });\n *\n * // Subscribe with type safety\n * const unsubscribe = eventBus.on('NodeCreated', (data, entry) => {\n *   console.log(`Node ${data.nodeId} created at ${data.path}`);\n * });\n *\n * // Emit with type safety\n * eventBus.emit('NodeCreated', {\n *   nodeId: '123',\n *   path: '/docs/readme.md',\n *   type: 'document',\n * }, 'mcp-server');\n *\n * // Query history\n * const recentNodeEvents = eventBus.getHistory({\n *   types: ['NodeCreated', 'NodeUpdated'],\n *   limit: 10,\n * });\n *\n * // Cleanup\n * unsubscribe();\n * ```\n */\nexport class TypedEventBus implements ITypedEventBus {\n  private readonly emitter: EventEmitter;\n  private readonly history: EventEntry[] = [];\n  private readonly options: Required<TypedEventBusOptions>;\n  private readonly metrics: Map<EventType, EventTypeMetrics> = new Map();\n  private readonly handlers: Map<EventType, Set<EventHandler<EventType>>> = new Map();\n  private readonly wildcardHandlers: Set<(entry: EventEntry) => void | Promise<void>> = new Set();\n  private eventCounter = 0;\n  private cleanupInterval?: NodeJS.Timeout;\n\n  constructor(options: TypedEventBusOptions = {}) {\n    this.options = {\n      maxHistorySize: options.maxHistorySize ?? 1000,\n      historyRetention: options.historyRetention ?? 60 * 60 * 1000, // 1 hour\n      maxListeners: options.maxListeners ?? 100,\n      debugEvents: options.debugEvents ?? false,\n    };\n\n    this.emitter = new EventEmitter();\n    this.emitter.setMaxListeners(this.options.maxListeners);\n\n    // Setup periodic history cleanup\n    this.cleanupInterval = setInterval(\n      () => this.pruneHistory(),\n      Math.min(this.options.historyRetention / 10, 60000) // At most every minute\n    );\n\n    // Ensure cleanup interval doesn't prevent process exit\n    if (this.cleanupInterval.unref) {\n      this.cleanupInterval.unref();\n    }\n\n    logger.debug('TypedEventBus initialized', {\n      maxHistorySize: this.options.maxHistorySize,\n      historyRetention: this.options.historyRetention,\n    });\n  }\n\n  /**\n   * Emit an event with typed data\n   */\n  emit<T extends EventType>(event: T, data: EventDataMap[T], source = 'unknown'): void {\n    this.emitEvent(event, source, data as unknown as Record<string, unknown>);\n  }\n\n  /**\n   * Emit an event using (type, source, data) signature\n   * This method supports both typed events and arbitrary string events\n   * for backwards compatibility with container and other components.\n   *\n   * @param type - Event type (can be EventType or any string)\n   * @param source - Source of the event\n   * @param data - Event data payload\n   */\n  emitEvent(type: EventType | string, source: string, data: Record<string, unknown>): void {\n    const startTime = Date.now();\n    const id = this.generateEventId();\n\n    // Create entry with type cast to handle both typed and untyped events\n    const entry: EventEntry = {\n      id,\n      type: type as EventType,\n      data: data as unknown as EventDataMap[EventType],\n      source,\n      timestamp: new Date(),\n    };\n\n    if (this.options.debugEvents) {\n      logger.debug(`Event emitted: ${type}`, { source, id, data });\n    }\n\n    // Add to history (before handlers for consistency)\n    this.addToHistory(entry);\n\n    // Execute handlers with error isolation (only for known event types)\n    let handlersExecuted = { executed: 0, errors: 0 };\n    if (this.isKnownEventType(type)) {\n      handlersExecuted = this.executeHandlers(\n        type as EventType,\n        data as unknown as EventDataMap[EventType],\n        entry\n      );\n    }\n\n    // Execute wildcard handlers for all events\n    for (const handler of this.wildcardHandlers) {\n      this.safeExecute(handler, entry, type as EventType);\n    }\n\n    // Calculate latency and update metrics\n    const latency = Date.now() - startTime;\n    (entry as { latency: number }).latency = latency;\n\n    if (this.isKnownEventType(type)) {\n      this.updateMetrics(type as EventType, latency, handlersExecuted.errors);\n    }\n\n    // Emit on the underlying EventEmitter for GraphQL subscriptions\n    this.emitter.emit(type, entry);\n    this.emitter.emit('*', entry);\n  }\n\n  /**\n   * Check if an event type is a known typed event\n   */\n  private isKnownEventType(type: string): type is EventType {\n    const knownTypes: Set<string> = new Set([\n      'NodeCreated', 'NodeUpdated', 'NodeDeleted',\n      'RelationCreated', 'RelationDeleted',\n      'AgentSpawned', 'AgentCompleted', 'AgentFailed',\n      'WorkflowStarted', 'WorkflowProgress', 'WorkflowCompleted',\n      'PluginLoaded', 'PluginError',\n      'HealthCheckFailed', 'HealthCheckRecovered',\n      'CacheEviction',\n    ]);\n    return knownTypes.has(type);\n  }\n\n  /**\n   * Subscribe to an event type\n   */\n  on<T extends EventType>(event: T, handler: EventHandler<T>): Unsubscribe {\n    const handlers = this.getOrCreateHandlerSet(event);\n    handlers.add(handler as EventHandler<EventType>);\n\n    logger.debug(`Handler subscribed to ${event}`, {\n      totalHandlers: handlers.size,\n    });\n\n    return () => this.off(event, handler);\n  }\n\n  /**\n   * Subscribe to an event type for a single occurrence\n   */\n  once<T extends EventType>(event: T, handler: EventHandler<T>): Unsubscribe {\n    const wrappedHandler: EventHandler<T> = (data, entry) => {\n      this.off(event, wrappedHandler);\n      return handler(data, entry);\n    };\n\n    return this.on(event, wrappedHandler);\n  }\n\n  /**\n   * Unsubscribe a specific handler\n   */\n  off<T extends EventType>(event: T, handler: EventHandler<T>): void {\n    const handlers = this.handlers.get(event);\n    if (handlers) {\n      handlers.delete(handler as EventHandler<EventType>);\n\n      logger.debug(`Handler unsubscribed from ${event}`, {\n        remainingHandlers: handlers.size,\n      });\n    }\n  }\n\n  /**\n   * Subscribe to all events (wildcard)\n   */\n  onAny(handler: (entry: EventEntry) => void | Promise<void>): Unsubscribe {\n    this.wildcardHandlers.add(handler);\n\n    logger.debug('Wildcard handler subscribed', {\n      totalWildcardHandlers: this.wildcardHandlers.size,\n    });\n\n    return () => {\n      this.wildcardHandlers.delete(handler);\n      logger.debug('Wildcard handler unsubscribed', {\n        remainingWildcardHandlers: this.wildcardHandlers.size,\n      });\n    };\n  }\n\n  /**\n   * Get event history with optional filtering\n   */\n  getHistory(filter?: EventFilter): EventEntry[] {\n    let result = [...this.history];\n\n    if (!filter) {\n      return result;\n    }\n\n    // Filter by types\n    if (filter.types && filter.types.length > 0) {\n      const typeSet = new Set(filter.types);\n      result = result.filter((e) => typeSet.has(e.type));\n    }\n\n    // Filter by source\n    if (filter.source) {\n      result = result.filter((e) => e.source === filter.source);\n    }\n\n    // Filter by source pattern\n    if (filter.sourcePattern) {\n      result = result.filter((e) => filter.sourcePattern!.test(e.source));\n    }\n\n    // Filter by time range\n    if (filter.since) {\n      result = result.filter((e) => e.timestamp >= filter.since!);\n    }\n    if (filter.until) {\n      result = result.filter((e) => e.timestamp < filter.until!);\n    }\n\n    // Apply offset\n    if (filter.offset && filter.offset > 0) {\n      result = result.slice(filter.offset);\n    }\n\n    // Apply limit\n    if (filter.limit && filter.limit > 0) {\n      result = result.slice(0, filter.limit);\n    }\n\n    return result;\n  }\n\n  /**\n   * Get event bus metrics\n   */\n  getMetrics(): EventBusMetrics {\n    let totalEvents = 0;\n    let totalErrors = 0;\n    const byType: Partial<Record<EventType, EventTypeMetrics>> = {};\n\n    for (const [type, metrics] of this.metrics) {\n      totalEvents += metrics.count;\n      totalErrors += metrics.errorCount;\n      byType[type] = { ...metrics };\n    }\n\n    let subscriberCount = this.wildcardHandlers.size;\n    for (const handlers of this.handlers.values()) {\n      subscriberCount += handlers.size;\n    }\n\n    return {\n      totalEvents,\n      totalErrors,\n      byType,\n      historySize: this.history.length,\n      subscriberCount,\n    };\n  }\n\n  /**\n   * Clear event history\n   */\n  clearHistory(): void {\n    this.history.length = 0;\n    logger.debug('Event history cleared');\n  }\n\n  /**\n   * Get the underlying EventEmitter for GraphQL subscriptions\n   */\n  getEmitter(): EventEmitter {\n    return this.emitter;\n  }\n\n  /**\n   * Stop the event bus and cleanup resources\n   */\n  dispose(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = undefined;\n    }\n\n    this.handlers.clear();\n    this.wildcardHandlers.clear();\n    this.history.length = 0;\n    this.metrics.clear();\n    this.emitter.removeAllListeners();\n\n    logger.debug('TypedEventBus disposed');\n  }\n\n  // ============================================================================\n  // Private Methods\n  // ============================================================================\n\n  /**\n   * Generate a unique event ID\n   */\n  private generateEventId(): string {\n    this.eventCounter += 1;\n    const timestamp = Date.now().toString(36);\n    const counter = this.eventCounter.toString(36).padStart(4, '0');\n    const random = Math.random().toString(36).substring(2, 6);\n    return `evt_${timestamp}_${counter}_${random}`;\n  }\n\n  /**\n   * Get or create handler set for an event type\n   */\n  private getOrCreateHandlerSet(event: EventType): Set<EventHandler<EventType>> {\n    let handlers = this.handlers.get(event);\n    if (!handlers) {\n      handlers = new Set();\n      this.handlers.set(event, handlers);\n    }\n    return handlers;\n  }\n\n  /**\n   * Execute all handlers for an event with error isolation\n   */\n  private executeHandlers<T extends EventType>(\n    event: T,\n    data: EventDataMap[T],\n    entry: EventEntry<T>\n  ): { executed: number; errors: number } {\n    const handlers = this.handlers.get(event);\n    let executed = 0;\n    let errors = 0;\n\n    if (!handlers || handlers.size === 0) {\n      return { executed, errors };\n    }\n\n    for (const handler of handlers) {\n      executed += 1;\n      const success = this.safeExecute(\n        () => (handler as EventHandler<T>)(data, entry),\n        entry,\n        event\n      );\n      if (!success) {\n        errors += 1;\n      }\n    }\n\n    return { executed, errors };\n  }\n\n  /**\n   * Safely execute a handler with error isolation\n   */\n  private safeExecute(\n    handler: (() => void | Promise<void>) | ((entry: EventEntry) => void | Promise<void>),\n    entry: EventEntry,\n    eventType: EventType\n  ): boolean {\n    try {\n      const result = typeof handler === 'function'\n        ? (handler as (e: EventEntry) => void | Promise<void>)(entry)\n        : undefined;\n\n      // Handle async handlers\n      if (result && typeof (result as Promise<void>).catch === 'function') {\n        (result as Promise<void>).catch((error) => {\n          this.handleHandlerError(error, eventType, entry.id);\n        });\n      }\n\n      return true;\n    } catch (error) {\n      this.handleHandlerError(error, eventType, entry.id);\n      return false;\n    }\n  }\n\n  /**\n   * Handle a handler error without affecting other handlers\n   */\n  private handleHandlerError(error: unknown, eventType: EventType, eventId: string): void {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error(`Handler error for ${eventType}`, error instanceof Error ? error : undefined, {\n      eventId,\n      eventType,\n      errorMessage,\n    });\n\n    // Emit error event on underlying emitter for external handling\n    this.emitter.emit('handler:error', {\n      eventType,\n      eventId,\n      error,\n      timestamp: new Date(),\n    });\n  }\n\n  /**\n   * Add an event to history\n   */\n  private addToHistory(entry: EventEntry): void {\n    this.history.push(entry);\n\n    // Enforce size limit\n    if (this.history.length > this.options.maxHistorySize) {\n      const removeCount = this.history.length - this.options.maxHistorySize;\n      this.history.splice(0, removeCount);\n    }\n  }\n\n  /**\n   * Prune old entries from history based on retention time\n   */\n  private pruneHistory(): void {\n    const cutoff = new Date(Date.now() - this.options.historyRetention);\n    const initialSize = this.history.length;\n\n    // Find first entry that's not expired\n    let firstValidIndex = 0;\n    for (let i = 0; i < this.history.length; i++) {\n      if (this.history[i].timestamp >= cutoff) {\n        firstValidIndex = i;\n        break;\n      }\n      firstValidIndex = this.history.length; // All expired\n    }\n\n    if (firstValidIndex > 0) {\n      this.history.splice(0, firstValidIndex);\n      logger.debug('Pruned old events from history', {\n        removed: firstValidIndex,\n        remaining: this.history.length,\n      });\n    }\n  }\n\n  /**\n   * Update metrics for an event type\n   */\n  private updateMetrics(event: EventType, latency: number, errors: number): void {\n    let metrics = this.metrics.get(event);\n\n    if (!metrics) {\n      metrics = {\n        count: 0,\n        errorCount: 0,\n        avgLatency: 0,\n        maxLatency: 0,\n      };\n      this.metrics.set(event, metrics);\n    }\n\n    // Update counts\n    metrics.count += 1;\n    metrics.errorCount += errors;\n    metrics.lastEvent = new Date();\n\n    // Update latency (rolling average)\n    metrics.avgLatency = (metrics.avgLatency * (metrics.count - 1) + latency) / metrics.count;\n    metrics.maxLatency = Math.max(metrics.maxLatency, latency);\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\n/**\n * Create a new TypedEventBus instance\n *\n * @param options - Configuration options\n * @returns New TypedEventBus instance\n *\n * @example\n * ```typescript\n * const eventBus = createTypedEventBus({\n *   maxHistorySize: 500,\n *   historyRetention: 30 * 60 * 1000, // 30 minutes\n *   debugEvents: true,\n * });\n * ```\n */\nexport function createTypedEventBus(options?: TypedEventBusOptions): TypedEventBus {\n  return new TypedEventBus(options);\n}\n\n// ============================================================================\n// GraphQL Subscription Helpers\n// ============================================================================\n\n/**\n * Create an async iterator for GraphQL subscriptions\n *\n * This wraps the EventEmitter to provide an AsyncIterator interface\n * compatible with GraphQL subscription resolvers.\n *\n * @param eventBus - The TypedEventBus instance\n * @param eventTypes - Event types to subscribe to\n * @returns AsyncIterator for GraphQL subscriptions\n *\n * @example\n * ```typescript\n * // In GraphQL resolver\n * const resolvers = {\n *   Subscription: {\n *     nodeChanged: {\n *       subscribe: () => createSubscriptionIterator(eventBus, ['NodeCreated', 'NodeUpdated', 'NodeDeleted']),\n *     },\n *   },\n * };\n * ```\n */\nexport function createSubscriptionIterator<T extends EventType>(\n  eventBus: TypedEventBus,\n  eventTypes: T[]\n): AsyncIterableIterator<EventEntry<T>> {\n  const emitter = eventBus.getEmitter();\n  const queue: EventEntry<T>[] = [];\n  let resolveNext: ((value: IteratorResult<EventEntry<T>>) => void) | null = null;\n  let done = false;\n\n  // Handler for events\n  const handler = (entry: EventEntry) => {\n    if (eventTypes.includes(entry.type as T)) {\n      if (resolveNext) {\n        resolveNext({ value: entry as EventEntry<T>, done: false });\n        resolveNext = null;\n      } else {\n        queue.push(entry as EventEntry<T>);\n      }\n    }\n  };\n\n  // Subscribe to all specified event types\n  for (const eventType of eventTypes) {\n    emitter.on(eventType, handler);\n  }\n\n  const iterator: AsyncIterableIterator<EventEntry<T>> = {\n    next(): Promise<IteratorResult<EventEntry<T>>> {\n      if (done) {\n        return Promise.resolve({ value: undefined as unknown as EventEntry<T>, done: true });\n      }\n\n      if (queue.length > 0) {\n        return Promise.resolve({ value: queue.shift()!, done: false });\n      }\n\n      return new Promise((resolve) => {\n        resolveNext = resolve;\n      });\n    },\n\n    return(): Promise<IteratorResult<EventEntry<T>>> {\n      done = true;\n      // Cleanup listeners\n      for (const eventType of eventTypes) {\n        emitter.off(eventType, handler);\n      }\n      return Promise.resolve({ value: undefined as unknown as EventEntry<T>, done: true });\n    },\n\n    throw(error?: unknown): Promise<IteratorResult<EventEntry<T>>> {\n      done = true;\n      // Cleanup listeners\n      for (const eventType of eventTypes) {\n        emitter.off(eventType, handler);\n      }\n      return Promise.reject(error);\n    },\n\n    [Symbol.asyncIterator](): AsyncIterableIterator<EventEntry<T>> {\n      return this;\n    },\n  };\n\n  return iterator;\n}\n\n/**\n * Filter events by node types for GraphQL subscriptions\n *\n * @param nodeTypes - Node types to filter by\n * @returns Filter function for subscription\n */\nexport function createNodeTypeFilter(\n  nodeTypes: string[]\n): (entry: EventEntry<'NodeCreated' | 'NodeUpdated' | 'NodeDeleted'>) => boolean {\n  const typeSet = new Set(nodeTypes);\n  return (entry) => typeSet.has(entry.data.type);\n}\n\n/**\n * Filter events by source for GraphQL subscriptions\n *\n * @param sources - Sources to filter by\n * @returns Filter function for subscription\n */\nexport function createSourceFilter(sources: string[]): (entry: EventEntry) => boolean {\n  const sourceSet = new Set(sources);\n  return (entry) => sourceSet.has(entry.source);\n}\n"],"names":[],"mappings":"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"}