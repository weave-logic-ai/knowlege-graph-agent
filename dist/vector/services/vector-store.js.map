{"version":3,"file":"vector-store.js","sources":["../../../src/vector/services/vector-store.ts"],"sourcesContent":["/**\n * Enhanced Vector Store\n *\n * Provides vector storage with HNSW indexing and hybrid search\n * combining vector similarity with graph queries.\n *\n * Designed to integrate with RuVector patterns while working\n * with the existing SQLite database as a fallback.\n *\n * @module vector/services/vector-store\n */\n\nimport type {\n  VectorEntry,\n  SearchResult,\n  HybridSearchQuery,\n  HybridSearchResult,\n  BatchInsertOperation,\n  BatchInsertResult,\n  VectorIndexStats,\n  IVectorStore,\n  VectorStoreEvent,\n  VectorStoreEventListener,\n} from '../types.js';\nimport type { RuVectorConfig } from '../config.js';\nimport { createRuVectorConfig, validateRuVectorConfig } from '../config.js';\nimport { createLogger } from '../../utils/index.js';\n\nconst logger = createLogger('vector-store');\n\n/**\n * HNSW Node for in-memory index\n *\n * Represents a single node in the Hierarchical Navigable Small World graph.\n * Each node stores its vector, metadata, and connections at different levels.\n */\ninterface HNSWNode {\n  /** Unique identifier for this node */\n  id: string;\n\n  /** Vector embedding data */\n  vector: number[];\n\n  /** Neighbor connections per level (level -> neighbor ids) */\n  neighbors: Map<number, string[]>;\n\n  /** Associated metadata */\n  metadata: Record<string, unknown>;\n\n  /** Node's maximum level in the hierarchy */\n  level: number;\n\n  /** Creation timestamp */\n  createdAt: Date;\n}\n\n/**\n * Enhanced Vector Store class\n *\n * Provides:\n * - HNSW-based approximate nearest neighbor search\n * - Hybrid search combining vectors and graph queries\n * - Batch operations for efficient bulk inserts\n * - Integration with existing knowledge graph\n *\n * @example\n * ```typescript\n * const store = createVectorStore({\n *   index: { dimensions: 1536, distanceMetric: 'cosine' }\n * });\n * await store.initialize();\n *\n * await store.insert({\n *   id: 'doc-1',\n *   vector: embeddings,\n *   metadata: { title: 'Document 1' }\n * });\n *\n * const results = await store.search({\n *   vector: queryEmbedding,\n *   k: 10\n * });\n * ```\n */\nexport class EnhancedVectorStore implements IVectorStore {\n  /** Store configuration */\n  private config: RuVectorConfig;\n\n  /** In-memory node storage */\n  private nodes: Map<string, HNSWNode> = new Map();\n\n  /** Entry point node ID for HNSW search */\n  private entryPoint: string | null = null;\n\n  /** Maximum level in the current index */\n  private maxLevel: number = 0;\n\n  /** Level generation multiplier (1/ln(M)) */\n  private levelMultiplier: number;\n\n  /** Initialization state */\n  private isInitialized: boolean = false;\n\n  /** Event listeners */\n  private eventListeners: Map<string, Set<VectorStoreEventListener>> = new Map();\n\n  /**\n   * Create a new EnhancedVectorStore\n   *\n   * @param config - Optional configuration overrides\n   */\n  constructor(config?: Partial<RuVectorConfig>) {\n    const baseConfig = createRuVectorConfig();\n    this.config = { ...baseConfig, ...config };\n\n    // Level multiplier for HNSW (1/ln(M))\n    const m = this.config.index.hnswConfig?.m || 16;\n    this.levelMultiplier = 1 / Math.log(m);\n\n    const validation = validateRuVectorConfig(this.config);\n    if (!validation.valid) {\n      logger.warn('Invalid configuration', { errors: validation.errors });\n    }\n    if (validation.warnings.length > 0) {\n      logger.debug('Configuration warnings', { warnings: validation.warnings });\n    }\n  }\n\n  /**\n   * Initialize the vector store\n   *\n   * Sets up the storage backend and prepares the index for operations.\n   * Must be called before any other operations.\n   *\n   * @throws Error if initialization fails\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    logger.info('Initializing vector store', {\n      backend: this.config.backend,\n      dimensions: this.config.index.dimensions,\n      indexType: this.config.index.indexType,\n      distanceMetric: this.config.index.distanceMetric,\n    });\n\n    // For memory backend, nothing to initialize\n    // For postgres/standalone, would connect to storage\n    switch (this.config.backend) {\n      case 'memory':\n        // In-memory storage is ready\n        break;\n      case 'postgres':\n        logger.warn('PostgreSQL backend not yet implemented, using memory');\n        break;\n      case 'standalone':\n        logger.warn('Standalone backend not yet implemented, using memory');\n        break;\n      case 'sqlite':\n        logger.warn('SQLite backend not yet implemented, using memory');\n        break;\n    }\n\n    this.isInitialized = true;\n    logger.info('Vector store initialized');\n  }\n\n  /**\n   * Calculate distance between two vectors\n   *\n   * @param a - First vector\n   * @param b - Second vector\n   * @returns Distance value (lower = more similar for most metrics)\n   * @throws Error if vectors have different dimensions\n   */\n  private calculateDistance(a: number[], b: number[]): number {\n    if (a.length !== b.length) {\n      throw new Error(`Vector dimension mismatch: ${a.length} vs ${b.length}`);\n    }\n\n    switch (this.config.index.distanceMetric) {\n      case 'cosine':\n        return this.cosineDistance(a, b);\n      case 'euclidean':\n        return this.euclideanDistance(a, b);\n      case 'dotProduct':\n        return this.dotProductDistance(a, b);\n      case 'manhattan':\n        return this.manhattanDistance(a, b);\n      default:\n        return this.cosineDistance(a, b);\n    }\n  }\n\n  /**\n   * Calculate cosine distance (1 - cosine similarity)\n   *\n   * @param a - First vector\n   * @param b - Second vector\n   * @returns Cosine distance (0 = identical, 2 = opposite)\n   */\n  private cosineDistance(a: number[], b: number[]): number {\n    let dotProduct = 0;\n    let normA = 0;\n    let normB = 0;\n\n    for (let i = 0; i < a.length; i++) {\n      dotProduct += a[i] * b[i];\n      normA += a[i] * a[i];\n      normB += b[i] * b[i];\n    }\n\n    const denominator = Math.sqrt(normA) * Math.sqrt(normB);\n    if (denominator === 0) {\n      return 1; // Handle zero vectors\n    }\n\n    const similarity = dotProduct / denominator;\n    return 1 - similarity; // Convert to distance\n  }\n\n  /**\n   * Calculate Euclidean (L2) distance\n   *\n   * @param a - First vector\n   * @param b - Second vector\n   * @returns Euclidean distance\n   */\n  private euclideanDistance(a: number[], b: number[]): number {\n    let sum = 0;\n    for (let i = 0; i < a.length; i++) {\n      const diff = a[i] - b[i];\n      sum += diff * diff;\n    }\n    return Math.sqrt(sum);\n  }\n\n  /**\n   * Calculate negative dot product distance\n   *\n   * Higher dot product means more similar, so we negate for distance.\n   *\n   * @param a - First vector\n   * @param b - Second vector\n   * @returns Negative dot product\n   */\n  private dotProductDistance(a: number[], b: number[]): number {\n    let dotProduct = 0;\n    for (let i = 0; i < a.length; i++) {\n      dotProduct += a[i] * b[i];\n    }\n    return -dotProduct; // Negative because higher dot product = more similar\n  }\n\n  /**\n   * Calculate Manhattan (L1) distance\n   *\n   * @param a - First vector\n   * @param b - Second vector\n   * @returns Manhattan distance\n   */\n  private manhattanDistance(a: number[], b: number[]): number {\n    let sum = 0;\n    for (let i = 0; i < a.length; i++) {\n      sum += Math.abs(a[i] - b[i]);\n    }\n    return sum;\n  }\n\n  /**\n   * Generate random level for new node (HNSW algorithm)\n   *\n   * Uses exponential distribution to generate levels.\n   * Most nodes will be at level 0, with exponentially fewer at higher levels.\n   *\n   * @returns Generated level (0 or higher)\n   */\n  private generateLevel(): number {\n    const random = Math.random();\n    return Math.floor(-Math.log(random) * this.levelMultiplier);\n  }\n\n  /**\n   * Insert a vector into the index\n   *\n   * Implements the HNSW insertion algorithm:\n   * 1. Generate random level for the new node\n   * 2. If first node, make it the entry point\n   * 3. Otherwise, traverse from entry point to find insertion position\n   * 4. Connect to nearest neighbors at each level\n   *\n   * @param entry - Vector entry to insert\n   * @throws Error if not initialized or dimensions mismatch\n   */\n  async insert(entry: {\n    id: string;\n    vector: number[];\n    metadata?: Record<string, unknown>;\n  }): Promise<void> {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n\n    if (entry.vector.length !== this.config.index.dimensions) {\n      throw new Error(\n        `Vector dimension mismatch: expected ${this.config.index.dimensions}, got ${entry.vector.length}`\n      );\n    }\n\n    const level = this.generateLevel();\n    const node: HNSWNode = {\n      id: entry.id,\n      vector: entry.vector,\n      neighbors: new Map(),\n      metadata: entry.metadata || {},\n      level,\n      createdAt: new Date(),\n    };\n\n    // Initialize neighbor lists for each level\n    for (let l = 0; l <= level; l++) {\n      node.neighbors.set(l, []);\n    }\n\n    if (!this.entryPoint) {\n      // First node\n      this.entryPoint = entry.id;\n      this.maxLevel = level;\n      this.nodes.set(entry.id, node);\n      this.emitEvent({ type: 'insert', id: entry.id, timestamp: new Date() });\n      return;\n    }\n\n    // Find entry point for insertion\n    let currentId = this.entryPoint;\n    const m = this.config.index.hnswConfig?.m || 16;\n    const efConstruction = this.config.index.hnswConfig?.efConstruction || 200;\n\n    // Traverse from top level down to level+1\n    for (let l = this.maxLevel; l > level; l--) {\n      currentId = this.greedySearch(entry.vector, currentId, l);\n    }\n\n    // Insert at levels [level, 0]\n    for (let l = Math.min(level, this.maxLevel); l >= 0; l--) {\n      const neighbors = this.searchLayer(entry.vector, currentId, efConstruction, l);\n\n      // Select M nearest neighbors\n      const selected = neighbors.slice(0, m);\n      node.neighbors.set(l, selected.map((n) => n.id));\n\n      // Add bidirectional links\n      for (const neighbor of selected) {\n        const neighborNode = this.nodes.get(neighbor.id);\n        if (neighborNode) {\n          const neighborList = neighborNode.neighbors.get(l) || [];\n          neighborList.push(entry.id);\n\n          // Prune if too many neighbors\n          const maxConnections = l === 0 ? m * 2 : m;\n          if (neighborList.length > maxConnections) {\n            const pruned = this.pruneNeighbors(neighborNode.vector, neighborList, m);\n            neighborNode.neighbors.set(l, pruned);\n          } else {\n            neighborNode.neighbors.set(l, neighborList);\n          }\n        }\n      }\n\n      if (neighbors.length > 0) {\n        currentId = neighbors[0].id;\n      }\n    }\n\n    // Update entry point if new node has higher level\n    if (level > this.maxLevel) {\n      this.entryPoint = entry.id;\n      this.maxLevel = level;\n    }\n\n    this.nodes.set(entry.id, node);\n    this.emitEvent({ type: 'insert', id: entry.id, timestamp: new Date() });\n    logger.debug('Inserted vector', { id: entry.id, level });\n  }\n\n  /**\n   * Greedy search to find nearest neighbor at a level\n   *\n   * Traverses the graph at the specified level, always moving\n   * toward the nearest neighbor until no improvement is found.\n   *\n   * @param query - Query vector\n   * @param startId - Starting node ID\n   * @param level - Level to search at\n   * @returns ID of nearest node found\n   */\n  private greedySearch(query: number[], startId: string, level: number): string {\n    let currentId = startId;\n    const currentNode = this.nodes.get(currentId);\n    if (!currentNode) {\n      return startId;\n    }\n\n    let currentDist = this.calculateDistance(query, currentNode.vector);\n\n    let improved = true;\n    while (improved) {\n      improved = false;\n      const node = this.nodes.get(currentId);\n      if (!node) break;\n\n      const neighbors = node.neighbors.get(level) || [];\n\n      for (const neighborId of neighbors) {\n        const neighborNode = this.nodes.get(neighborId);\n        if (!neighborNode) continue;\n\n        const dist = this.calculateDistance(query, neighborNode.vector);\n        if (dist < currentDist) {\n          currentId = neighborId;\n          currentDist = dist;\n          improved = true;\n        }\n      }\n    }\n\n    return currentId;\n  }\n\n  /**\n   * Search a layer for nearest neighbors\n   *\n   * Implements beam search at a specific level using a priority queue.\n   *\n   * @param query - Query vector\n   * @param startId - Starting node ID\n   * @param ef - Size of dynamic candidate list\n   * @param level - Level to search at\n   * @returns Array of nearest neighbors with distances\n   */\n  private searchLayer(\n    query: number[],\n    startId: string,\n    ef: number,\n    level: number\n  ): Array<{ id: string; distance: number }> {\n    const visited = new Set<string>();\n    const candidates: Array<{ id: string; distance: number }> = [];\n    const results: Array<{ id: string; distance: number }> = [];\n\n    const startNode = this.nodes.get(startId);\n    if (!startNode) return [];\n\n    const startDist = this.calculateDistance(query, startNode.vector);\n    candidates.push({ id: startId, distance: startDist });\n    results.push({ id: startId, distance: startDist });\n    visited.add(startId);\n\n    while (candidates.length > 0) {\n      // Get nearest candidate\n      candidates.sort((a, b) => a.distance - b.distance);\n      const current = candidates.shift()!;\n\n      // Check if we can improve\n      results.sort((a, b) => a.distance - b.distance);\n      const furthestResult = results[results.length - 1];\n      if (current.distance > furthestResult.distance && results.length >= ef) {\n        break;\n      }\n\n      // Explore neighbors\n      const node = this.nodes.get(current.id);\n      if (!node) continue;\n\n      const neighbors = node.neighbors.get(level) || [];\n      for (const neighborId of neighbors) {\n        if (visited.has(neighborId)) continue;\n        visited.add(neighborId);\n\n        const neighborNode = this.nodes.get(neighborId);\n        if (!neighborNode) continue;\n\n        const dist = this.calculateDistance(query, neighborNode.vector);\n\n        if (results.length < ef || dist < furthestResult.distance) {\n          candidates.push({ id: neighborId, distance: dist });\n          results.push({ id: neighborId, distance: dist });\n          results.sort((a, b) => a.distance - b.distance);\n\n          if (results.length > ef) {\n            results.pop();\n          }\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Prune neighbors to keep only the best M\n   *\n   * Uses a simple distance-based pruning strategy.\n   *\n   * @param nodeVector - Vector of the node being pruned\n   * @param neighborIds - Current neighbor IDs\n   * @param m - Maximum neighbors to keep\n   * @returns Pruned list of neighbor IDs\n   */\n  private pruneNeighbors(nodeVector: number[], neighborIds: string[], m: number): string[] {\n    const distances = neighborIds.map((id) => {\n      const node = this.nodes.get(id);\n      if (!node) return { id, distance: Infinity };\n      return { id, distance: this.calculateDistance(nodeVector, node.vector) };\n    });\n\n    distances.sort((a, b) => a.distance - b.distance);\n    return distances.slice(0, m).map((d) => d.id);\n  }\n\n  /**\n   * Search for similar vectors\n   *\n   * Implements HNSW search algorithm:\n   * 1. Start from entry point at top level\n   * 2. Greedy search down to level 1\n   * 3. Beam search at level 0 with efSearch candidates\n   * 4. Return top-k results\n   *\n   * @param query - Search query with vector and options\n   * @returns Array of search results sorted by similarity\n   */\n  async search(query: {\n    vector: number[];\n    k?: number;\n    filter?: Record<string, unknown>;\n    minScore?: number;\n  }): Promise<SearchResult[]> {\n    const startTime = Date.now();\n\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n\n    if (!this.entryPoint) {\n      return [];\n    }\n\n    const k = query.k || 10;\n    const efSearch = this.config.index.hnswConfig?.efSearch || 100;\n\n    // Start from entry point\n    let currentId = this.entryPoint;\n\n    // Traverse from top level down\n    for (let l = this.maxLevel; l > 0; l--) {\n      currentId = this.greedySearch(query.vector, currentId, l);\n    }\n\n    // Search at level 0\n    const candidates = this.searchLayer(query.vector, currentId, Math.max(efSearch, k), 0);\n\n    // Convert to results\n    const results: SearchResult[] = candidates\n      .slice(0, k * 2) // Get more candidates for filtering\n      .map((c) => {\n        const node = this.nodes.get(c.id)!;\n        const score = this.distanceToScore(c.distance);\n\n        return {\n          id: c.id,\n          score,\n          metadata: node.metadata,\n          distance: c.distance,\n        };\n      })\n      .filter((r) => {\n        // Apply minimum score filter\n        if (query.minScore !== undefined && r.score < query.minScore) {\n          return false;\n        }\n        // Apply metadata filters\n        if (query.filter) {\n          for (const [key, value] of Object.entries(query.filter)) {\n            if (r.metadata[key] !== value) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })\n      .slice(0, k);\n\n    const durationMs = Date.now() - startTime;\n    this.emitEvent({\n      type: 'search',\n      queryId: crypto.randomUUID?.() || `search-${Date.now()}`,\n      resultCount: results.length,\n      durationMs,\n      timestamp: new Date(),\n    });\n\n    return results;\n  }\n\n  /**\n   * Convert distance to similarity score\n   *\n   * @param distance - Distance value\n   * @returns Similarity score between 0 and 1\n   */\n  private distanceToScore(distance: number): number {\n    switch (this.config.index.distanceMetric) {\n      case 'cosine':\n        // Cosine distance is 1 - similarity, so score = 1 - distance\n        return Math.max(0, Math.min(1, 1 - distance));\n      case 'euclidean':\n        // Convert using exponential decay\n        return Math.exp(-distance);\n      case 'dotProduct':\n        // Negative dot product was used, so negate back\n        // Normalize using sigmoid-like function\n        return 1 / (1 + Math.exp(distance));\n      case 'manhattan':\n        // Similar to euclidean\n        return Math.exp(-distance / 10);\n      default:\n        return Math.max(0, Math.min(1, 1 - distance));\n    }\n  }\n\n  /**\n   * Hybrid search combining vectors and graph queries\n   *\n   * Performs vector similarity search and optionally enriches\n   * results with data from graph queries (Cypher).\n   *\n   * @param query - Hybrid search query\n   * @returns Array of hybrid search results\n   */\n  async hybridSearch(query: HybridSearchQuery): Promise<HybridSearchResult[]> {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n\n    const limit = query.limit || 10;\n\n    // Vector similarity search\n    const vectorResults = await this.search({\n      vector: query.embedding,\n      k: limit * 2, // Get more candidates for merging\n      filter: query.filters,\n      minScore: query.minScore,\n    });\n\n    // If no Cypher query, return vector results\n    if (!query.cypher) {\n      return vectorResults.map((r) => ({\n        ...r,\n        source: 'vector' as const,\n      }));\n    }\n\n    // TODO: Execute Cypher query against graph database\n    // For now, return vector results with placeholder graph data\n    logger.debug('Hybrid search with Cypher query', {\n      cypher: query.cypher,\n      vectorResultCount: vectorResults.length,\n    });\n\n    const hybridResults: HybridSearchResult[] = vectorResults.slice(0, limit).map((r) => ({\n      ...r,\n      source: 'merged' as const,\n      graphData: {\n        cypherQuery: query.cypher,\n        cypherParams: query.cypherParams,\n        note: 'Graph query execution pending integration',\n      },\n    }));\n\n    return hybridResults;\n  }\n\n  /**\n   * Batch insert vectors\n   *\n   * Efficiently inserts multiple vectors in a single operation.\n   * Supports progress callbacks and duplicate handling.\n   *\n   * @param operation - Batch insert operation configuration\n   * @returns Result with counts of inserted, skipped, and errors\n   */\n  async batchInsert(operation: BatchInsertOperation): Promise<BatchInsertResult> {\n    const startTime = Date.now();\n    const result: BatchInsertResult = {\n      inserted: 0,\n      skipped: 0,\n      errors: [],\n    };\n\n    const total = operation.entries.length;\n\n    for (let i = 0; i < operation.entries.length; i++) {\n      const entry = operation.entries[i];\n\n      try {\n        if (this.nodes.has(entry.id)) {\n          if (operation.skipDuplicates) {\n            result.skipped++;\n            continue;\n          }\n          throw new Error(`Duplicate ID: ${entry.id}`);\n        }\n\n        await this.insert(entry);\n        result.inserted++;\n\n        // Progress callback\n        if (operation.onProgress) {\n          operation.onProgress(result.inserted + result.skipped, total);\n        }\n      } catch (error) {\n        result.errors.push({\n          id: entry.id,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    result.durationMs = Date.now() - startTime;\n    logger.info('Batch insert completed', {\n      inserted: result.inserted,\n      skipped: result.skipped,\n      errors: result.errors.length,\n      durationMs: result.durationMs,\n    });\n    return result;\n  }\n\n  /**\n   * Get a vector by ID\n   *\n   * @param id - Vector ID to retrieve\n   * @returns Vector entry or null if not found\n   */\n  async get(id: string): Promise<VectorEntry | null> {\n    const node = this.nodes.get(id);\n    if (!node) return null;\n\n    return {\n      id: node.id,\n      vector: node.vector,\n      metadata: node.metadata,\n      createdAt: node.createdAt,\n    };\n  }\n\n  /**\n   * Delete a vector by ID\n   *\n   * Removes the vector from the index and updates neighbor connections.\n   *\n   * @param id - Vector ID to delete\n   * @returns True if deleted, false if not found\n   */\n  async delete(id: string): Promise<boolean> {\n    const node = this.nodes.get(id);\n    if (!node) return false;\n\n    // Remove from neighbors' lists\n    for (const [level, neighbors] of node.neighbors) {\n      for (const neighborId of neighbors) {\n        const neighborNode = this.nodes.get(neighborId);\n        if (neighborNode) {\n          const neighborList = neighborNode.neighbors.get(level) || [];\n          const idx = neighborList.indexOf(id);\n          if (idx !== -1) {\n            neighborList.splice(idx, 1);\n          }\n        }\n      }\n    }\n\n    // Update entry point if needed\n    if (this.entryPoint === id) {\n      const nodeIterator = this.nodes.keys();\n      let nextEntry = nodeIterator.next();\n      // Find a node that isn't the one being deleted\n      while (!nextEntry.done && nextEntry.value === id) {\n        nextEntry = nodeIterator.next();\n      }\n      this.entryPoint = nextEntry.done ? null : nextEntry.value;\n\n      // Update max level if entry point changed\n      if (this.entryPoint) {\n        const newEntry = this.nodes.get(this.entryPoint);\n        this.maxLevel = newEntry?.level || 0;\n      } else {\n        this.maxLevel = 0;\n      }\n    }\n\n    this.nodes.delete(id);\n    this.emitEvent({ type: 'delete', id, timestamp: new Date() });\n    logger.debug('Deleted vector', { id });\n    return true;\n  }\n\n  /**\n   * Get index statistics\n   *\n   * @returns Current statistics about the vector index\n   */\n  getStats(): VectorIndexStats {\n    return {\n      totalVectors: this.nodes.size,\n      dimensions: this.config.index.dimensions,\n      indexType: this.config.index.indexType,\n      memoryUsage: this.estimateMemoryUsage(),\n      lastUpdated: new Date(),\n      indexStats: {\n        levels: this.maxLevel + 1,\n        entryPoint: this.entryPoint || undefined,\n        avgConnections: this.calculateAverageConnections(),\n      },\n    };\n  }\n\n  /**\n   * Estimate memory usage in bytes\n   *\n   * Provides rough estimate of memory consumption.\n   *\n   * @returns Estimated memory usage in bytes\n   */\n  private estimateMemoryUsage(): number {\n    // Rough estimate: vector + metadata + neighbors per node\n    const vectorSize = this.config.index.dimensions * 4; // float32\n    const metadataSize = 100; // average estimate\n    const neighborsSize = 50 * 8; // average neighbors * pointer size\n    const nodeOverhead = 64; // object overhead\n\n    return this.nodes.size * (vectorSize + metadataSize + neighborsSize + nodeOverhead);\n  }\n\n  /**\n   * Calculate average number of connections per node\n   *\n   * @returns Average connection count\n   */\n  private calculateAverageConnections(): number {\n    if (this.nodes.size === 0) return 0;\n\n    let totalConnections = 0;\n    for (const node of this.nodes.values()) {\n      for (const neighbors of node.neighbors.values()) {\n        totalConnections += neighbors.length;\n      }\n    }\n\n    return totalConnections / this.nodes.size;\n  }\n\n  /**\n   * Clear all vectors\n   *\n   * Removes all vectors from the index and resets state.\n   */\n  async clear(): Promise<void> {\n    this.nodes.clear();\n    this.entryPoint = null;\n    this.maxLevel = 0;\n    logger.info('Vector store cleared');\n  }\n\n  /**\n   * Get configuration\n   *\n   * @returns Copy of current configuration\n   */\n  getConfig(): RuVectorConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Check if store is initialized\n   *\n   * @returns True if initialized\n   */\n  isReady(): boolean {\n    return this.isInitialized;\n  }\n\n  /**\n   * Get total vector count\n   *\n   * @returns Number of vectors in the store\n   */\n  size(): number {\n    return this.nodes.size;\n  }\n\n  /**\n   * Check if a vector exists\n   *\n   * @param id - Vector ID to check\n   * @returns True if exists\n   */\n  has(id: string): boolean {\n    return this.nodes.has(id);\n  }\n\n  /**\n   * Get all vector IDs\n   *\n   * @returns Array of all vector IDs\n   */\n  getAllIds(): string[] {\n    return Array.from(this.nodes.keys());\n  }\n\n  /**\n   * Add event listener\n   *\n   * @param event - Event type to listen for\n   * @param listener - Callback function\n   */\n  on(event: string, listener: VectorStoreEventListener): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, new Set());\n    }\n    this.eventListeners.get(event)!.add(listener);\n  }\n\n  /**\n   * Remove event listener\n   *\n   * @param event - Event type\n   * @param listener - Callback function to remove\n   */\n  off(event: string, listener: VectorStoreEventListener): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      listeners.delete(listener);\n    }\n  }\n\n  /**\n   * Emit an event to all registered listeners\n   *\n   * @param event - Event to emit\n   */\n  private emitEvent(event: VectorStoreEvent): void {\n    const listeners = this.eventListeners.get(event.type);\n    if (listeners) {\n      for (const listener of listeners) {\n        try {\n          listener(event);\n        } catch (error) {\n          logger.error('Event listener error', error instanceof Error ? error : undefined, {\n            eventType: event.type,\n          });\n        }\n      }\n    }\n\n    // Also emit to wildcard listeners\n    const wildcardListeners = this.eventListeners.get('*');\n    if (wildcardListeners) {\n      for (const listener of wildcardListeners) {\n        try {\n          listener(event);\n        } catch (error) {\n          logger.error('Wildcard listener error', error instanceof Error ? error : undefined, {\n            eventType: event.type,\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Create an enhanced vector store instance\n *\n * Factory function for creating vector stores with optional configuration.\n *\n * @param config - Optional configuration overrides\n * @returns New EnhancedVectorStore instance\n *\n * @example\n * ```typescript\n * // Default configuration\n * const store = createVectorStore();\n *\n * // Custom configuration\n * const customStore = createVectorStore({\n *   index: {\n *     dimensions: 768,\n *     distanceMetric: 'euclidean',\n *   },\n *   cache: { enabled: true, maxSize: 5000 },\n * });\n * ```\n */\nexport function createVectorStore(config?: Partial<RuVectorConfig>): EnhancedVectorStore {\n  return new EnhancedVectorStore(config);\n}\n"],"names":[],"mappings":"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"}