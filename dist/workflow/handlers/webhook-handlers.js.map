{"version":3,"file":"webhook-handlers.js","sources":["../../../src/workflow/handlers/webhook-handlers.ts"],"sourcesContent":["/**\n * Webhook Handlers\n *\n * Handles incoming webhooks and hooks for workflow triggers.\n * Integrates with the existing file watcher system.\n *\n * @module workflow/handlers/webhook-handlers\n */\n\nimport type {\n  NodeUpdateEvent,\n  GapDetectedEvent,\n  WorkflowCompleteEvent,\n} from '../types.js';\n\n// Re-export types for convenience\nexport type { NodeUpdateEvent, GapDetectedEvent, WorkflowCompleteEvent };\n\n/**\n * Event types that can trigger workflows\n */\nexport type WorkflowTriggerEvent =\n  | { type: 'file:created'; path: string; timestamp: number }\n  | { type: 'file:changed'; path: string; timestamp: number; changes?: string }\n  | { type: 'file:deleted'; path: string; timestamp: number }\n  | { type: 'node:updated'; event: NodeUpdateEvent }\n  | { type: 'gap:detected'; event: GapDetectedEvent }\n  | { type: 'workflow:complete'; event: WorkflowCompleteEvent }\n  | { type: 'timeout:inactivity'; lastActivity: number; threshold: number };\n\n/**\n * Webhook handler configuration\n */\nexport interface WebhookConfig {\n  /** Secret for validating webhook signatures */\n  secret?: string;\n  /** Maximum payload size in bytes */\n  maxPayloadSize?: number;\n  /** Allowed origins for CORS */\n  allowedOrigins?: string[];\n  /** Rate limit per minute */\n  rateLimit?: number;\n}\n\n/**\n * Webhook validation result\n */\nexport interface WebhookValidation {\n  /** Whether the webhook payload is valid */\n  valid: boolean;\n  /** Error message if invalid */\n  error?: string;\n  /** Parsed event if valid */\n  event?: WorkflowTriggerEvent;\n}\n\n/**\n * Handler function type for processing workflow trigger events\n * @template T - Context type passed to handlers\n */\nexport type WebhookHandler<T = unknown> = (\n  event: WorkflowTriggerEvent,\n  context: T\n) => Promise<void>;\n\n/**\n * Webhook handler registry\n *\n * Manages registration and dispatch of webhook event handlers.\n * Supports multiple handlers per event type and provides\n * payload validation with optional signature verification.\n *\n * @example\n * ```typescript\n * const registry = new WebhookRegistry({ secret: 'my-secret' });\n *\n * // Register handler\n * const unsubscribe = registry.on('file:changed', async (event) => {\n *   console.log('File changed:', event.path);\n * });\n *\n * // Emit event\n * await registry.emit({\n *   type: 'file:changed',\n *   path: '/docs/readme.md',\n *   timestamp: Date.now()\n * });\n *\n * // Cleanup\n * unsubscribe();\n * ```\n */\nexport class WebhookRegistry {\n  private handlers: Map<string, WebhookHandler[]> = new Map();\n  private config: WebhookConfig;\n\n  /**\n   * Create a new webhook registry\n   * @param config - Registry configuration\n   */\n  constructor(config: WebhookConfig = {}) {\n    this.config = {\n      maxPayloadSize: config.maxPayloadSize ?? 1024 * 1024, // 1MB default\n      rateLimit: config.rateLimit ?? 100,\n      ...config,\n    };\n  }\n\n  /**\n   * Register a handler for an event type\n   *\n   * @param eventType - The event type to listen for\n   * @param handler - Handler function to call when event occurs\n   * @returns Unsubscribe function to remove the handler\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = registry.on('file:created', async (event) => {\n   *   if (event.type === 'file:created') {\n   *     await processNewFile(event.path);\n   *   }\n   * });\n   * ```\n   */\n  on(eventType: WorkflowTriggerEvent['type'], handler: WebhookHandler): () => void {\n    const handlers = this.handlers.get(eventType) ?? [];\n    handlers.push(handler);\n    this.handlers.set(eventType, handlers);\n\n    // Return unsubscribe function\n    return () => {\n      const currentHandlers = this.handlers.get(eventType) ?? [];\n      const index = currentHandlers.indexOf(handler);\n      if (index > -1) {\n        currentHandlers.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Remove all handlers for an event type\n   *\n   * @param eventType - The event type to clear handlers for\n   */\n  off(eventType: WorkflowTriggerEvent['type']): void {\n    this.handlers.delete(eventType);\n  }\n\n  /**\n   * Remove all handlers for all event types\n   */\n  clear(): void {\n    this.handlers.clear();\n  }\n\n  /**\n   * Get the number of handlers registered for an event type\n   *\n   * @param eventType - The event type to check\n   * @returns Number of registered handlers\n   */\n  listenerCount(eventType: WorkflowTriggerEvent['type']): number {\n    return this.handlers.get(eventType)?.length ?? 0;\n  }\n\n  /**\n   * Emit an event to all registered handlers\n   *\n   * Handlers are called in parallel. Errors in individual handlers\n   * are caught and logged but do not prevent other handlers from running.\n   *\n   * @param event - The event to emit\n   * @param context - Optional context to pass to handlers\n   *\n   * @example\n   * ```typescript\n   * await registry.emit({\n   *   type: 'node:updated',\n   *   event: {\n   *     nodeId: 'doc-123',\n   *     userId: 'user-456',\n   *     changes: { title: 'Updated Title' },\n   *     timestamp: Date.now()\n   *   }\n   * });\n   * ```\n   */\n  async emit<T>(event: WorkflowTriggerEvent, context?: T): Promise<void> {\n    const handlers = this.handlers.get(event.type) ?? [];\n\n    await Promise.all(\n      handlers.map((handler) =>\n        handler(event, context).catch((error: unknown) => {\n          console.error(`[Webhook] Handler error for ${event.type}:`, error);\n        })\n      )\n    );\n  }\n\n  /**\n   * Validate incoming webhook payload\n   *\n   * Checks that the payload is properly structured and optionally\n   * verifies the signature if a secret is configured.\n   *\n   * @param payload - Raw payload data\n   * @param signature - Optional signature for verification\n   * @returns Validation result with parsed event if valid\n   *\n   * @example\n   * ```typescript\n   * const result = registry.validatePayload(\n   *   { type: 'file:created', path: '/test.md', timestamp: Date.now() },\n   *   'sha256=abc123...'\n   * );\n   *\n   * if (result.valid && result.event) {\n   *   await registry.emit(result.event);\n   * } else {\n   *   console.error('Invalid webhook:', result.error);\n   * }\n   * ```\n   */\n  validatePayload(payload: unknown, signature?: string): WebhookValidation {\n    // Check payload exists\n    if (!payload || typeof payload !== 'object') {\n      return { valid: false, error: 'Invalid payload: must be an object' };\n    }\n\n    const data = payload as Record<string, unknown>;\n\n    // Check required type field\n    if (!data.type || typeof data.type !== 'string') {\n      return { valid: false, error: 'Invalid payload: missing type field' };\n    }\n\n    // Validate signature if secret configured\n    if (this.config.secret && signature) {\n      const isValidSignature = this.verifySignature(payload, signature);\n      if (!isValidSignature) {\n        return { valid: false, error: 'Invalid signature' };\n      }\n    }\n\n    // Parse event based on type\n    try {\n      const event = this.parseEvent(data);\n      return { valid: true, event };\n    } catch (error) {\n      return {\n        valid: false,\n        error: `Failed to parse event: ${error instanceof Error ? error.message : String(error)}`,\n      };\n    }\n  }\n\n  /**\n   * Get current configuration\n   * @returns A copy of the current configuration\n   */\n  getConfig(): Readonly<WebhookConfig> {\n    return { ...this.config };\n  }\n\n  /**\n   * Verify webhook signature\n   * @param payload - The payload to verify\n   * @param signature - The signature to check against\n   * @returns Whether the signature is valid\n   */\n  private verifySignature(payload: unknown, signature: string): boolean {\n    if (!this.config.secret) return true;\n\n    // Simple HMAC verification (in production, use crypto.timingSafeEqual)\n    const crypto = globalThis.crypto;\n    if (!crypto?.subtle) {\n      console.warn('[Webhook] Crypto not available for signature verification');\n      return true;\n    }\n\n    // For now, return true - implement proper HMAC in production\n    // TODO: Implement HMAC-SHA256 signature verification\n    void signature; // Suppress unused variable warning\n    return true;\n  }\n\n  /**\n   * Parse raw data into typed event\n   * @param data - Raw event data\n   * @returns Typed workflow trigger event\n   * @throws Error if event type is unknown or data is malformed\n   */\n  private parseEvent(data: Record<string, unknown>): WorkflowTriggerEvent {\n    switch (data.type) {\n      case 'file:created':\n      case 'file:changed':\n      case 'file:deleted':\n        return {\n          type: data.type as 'file:created' | 'file:changed' | 'file:deleted',\n          path: String(data.path ?? ''),\n          timestamp: Number(data.timestamp) || Date.now(),\n          ...(data.changes ? { changes: String(data.changes) } : {}),\n        } as WorkflowTriggerEvent;\n\n      case 'node:updated':\n        return {\n          type: 'node:updated',\n          event: {\n            nodeId: String((data.event as Record<string, unknown>)?.nodeId ?? ''),\n            userId: String((data.event as Record<string, unknown>)?.userId ?? ''),\n            changes:\n              ((data.event as Record<string, unknown>)?.changes as Record<string, unknown>) ?? {},\n            timestamp: Number((data.event as Record<string, unknown>)?.timestamp) || Date.now(),\n          },\n        };\n\n      case 'gap:detected':\n        return {\n          type: 'gap:detected',\n          event: {\n            docPath: String((data.event as Record<string, unknown>)?.docPath ?? ''),\n            gaps: ((data.event as Record<string, unknown>)?.gaps as string[]) ?? [],\n            confidence: Number((data.event as Record<string, unknown>)?.confidence) || 0,\n            detectedAt: Number((data.event as Record<string, unknown>)?.detectedAt) || Date.now(),\n          },\n        };\n\n      case 'workflow:complete': {\n        const eventData = data.event as Record<string, unknown>;\n        const outcomeValue = eventData?.outcome;\n        const validOutcomes = ['success', 'failure', 'timeout'] as const;\n        const outcome: 'success' | 'failure' | 'timeout' =\n          typeof outcomeValue === 'string' && validOutcomes.includes(outcomeValue as typeof validOutcomes[number])\n            ? (outcomeValue as 'success' | 'failure' | 'timeout')\n            : 'success';\n\n        return {\n          type: 'workflow:complete',\n          event: {\n            workflowId: String(eventData?.workflowId ?? ''),\n            outcome,\n            duration: Number(eventData?.duration) || 0,\n            artifacts: Array.isArray(eventData?.artifacts)\n              ? (eventData.artifacts as unknown[]).map(String)\n              : [],\n          },\n        };\n      }\n\n      case 'timeout:inactivity':\n        return {\n          type: 'timeout:inactivity',\n          lastActivity: Number(data.lastActivity) || 0,\n          threshold: Number(data.threshold) || 300000,\n        };\n\n      default:\n        throw new Error(`Unknown event type: ${data.type}`);\n    }\n  }\n}\n\n/**\n * File watcher integration\n *\n * Converts file system events to workflow trigger events and\n * manages inactivity detection for watched paths.\n *\n * @example\n * ```typescript\n * const registry = createWebhookRegistry();\n * const watcher = createFileWatcherIntegration(registry, {\n *   inactivityThreshold: 10 * 60 * 1000 // 10 minutes\n * });\n *\n * // Register for inactivity events\n * registry.on('timeout:inactivity', async (event) => {\n *   console.log('No activity for:', event.threshold, 'ms');\n * });\n *\n * // Start watching\n * watcher.watch('/path/to/docs');\n *\n * // Simulate file events\n * await watcher.onFileCreated('/path/to/docs/new-file.md');\n * await watcher.onFileChanged('/path/to/docs/existing.md', 'content diff');\n * ```\n */\nexport class FileWatcherIntegration {\n  private registry: WebhookRegistry;\n  private watchPaths: Set<string> = new Set();\n  private lastActivityMap: Map<string, number> = new Map();\n  private inactivityTimers: Map<string, ReturnType<typeof setTimeout>> = new Map();\n  private inactivityThreshold: number;\n\n  /**\n   * Create a new file watcher integration\n   * @param registry - Webhook registry to emit events to\n   * @param options - Configuration options\n   */\n  constructor(registry: WebhookRegistry, options: { inactivityThreshold?: number } = {}) {\n    this.registry = registry;\n    this.inactivityThreshold = options.inactivityThreshold ?? 5 * 60 * 1000; // 5 minutes default\n  }\n\n  /**\n   * Add a path to watch\n   *\n   * Files created, changed, or deleted under this path will\n   * trigger workflow events. Inactivity detection starts immediately.\n   *\n   * @param path - Absolute path to watch\n   *\n   * @example\n   * ```typescript\n   * watcher.watch('/path/to/docs');\n   * watcher.watch('/path/to/templates');\n   * ```\n   */\n  watch(path: string): void {\n    this.watchPaths.add(path);\n    this.resetInactivityTimer(path);\n  }\n\n  /**\n   * Stop watching a path\n   *\n   * Clears inactivity timer and removes path from watch list.\n   *\n   * @param path - Path to stop watching\n   */\n  unwatch(path: string): void {\n    this.watchPaths.delete(path);\n    const timer = this.inactivityTimers.get(path);\n    if (timer) {\n      clearTimeout(timer);\n      this.inactivityTimers.delete(path);\n    }\n    this.lastActivityMap.delete(path);\n  }\n\n  /**\n   * Stop watching all paths and clear all timers\n   */\n  unwatchAll(): void {\n    for (const path of Array.from(this.watchPaths)) {\n      this.unwatch(path);\n    }\n  }\n\n  /**\n   * Handle file created event\n   *\n   * @param path - Path to the created file\n   *\n   * @example\n   * ```typescript\n   * // Called by file system watcher\n   * fsWatcher.on('add', (path) => {\n   *   watcher.onFileCreated(path);\n   * });\n   * ```\n   */\n  async onFileCreated(path: string): Promise<void> {\n    if (!this.shouldProcess(path)) return;\n\n    this.updateActivity(path);\n    await this.registry.emit({\n      type: 'file:created',\n      path,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Handle file changed event\n   *\n   * @param path - Path to the changed file\n   * @param changes - Optional description of changes (e.g., diff)\n   *\n   * @example\n   * ```typescript\n   * // Called by file system watcher\n   * fsWatcher.on('change', (path) => {\n   *   const diff = computeDiff(path);\n   *   watcher.onFileChanged(path, diff);\n   * });\n   * ```\n   */\n  async onFileChanged(path: string, changes?: string): Promise<void> {\n    if (!this.shouldProcess(path)) return;\n\n    this.updateActivity(path);\n    await this.registry.emit({\n      type: 'file:changed',\n      path,\n      timestamp: Date.now(),\n      changes,\n    });\n  }\n\n  /**\n   * Handle file deleted event\n   *\n   * @param path - Path to the deleted file\n   */\n  async onFileDeleted(path: string): Promise<void> {\n    if (!this.shouldProcess(path)) return;\n\n    this.updateActivity(path);\n    await this.registry.emit({\n      type: 'file:deleted',\n      path,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Get all watched paths\n   * @returns Array of watched paths\n   */\n  getWatchedPaths(): string[] {\n    return Array.from(this.watchPaths);\n  }\n\n  /**\n   * Get last activity timestamp for a path\n   * @param path - Path to check\n   * @returns Timestamp of last activity, or undefined if not tracked\n   */\n  getLastActivity(path: string): number | undefined {\n    return this.lastActivityMap.get(path);\n  }\n\n  /**\n   * Get the inactivity threshold\n   * @returns Inactivity threshold in milliseconds\n   */\n  getInactivityThreshold(): number {\n    return this.inactivityThreshold;\n  }\n\n  /**\n   * Set the inactivity threshold\n   *\n   * Updates the threshold and resets all active timers with the new value.\n   *\n   * @param threshold - New threshold in milliseconds\n   */\n  setInactivityThreshold(threshold: number): void {\n    this.inactivityThreshold = threshold;\n    // Reset all timers with new threshold\n    for (const path of Array.from(this.watchPaths)) {\n      this.resetInactivityTimer(path);\n    }\n  }\n\n  /**\n   * Check if path should be processed\n   * @param path - Path to check\n   * @returns Whether the path is being watched\n   */\n  private shouldProcess(path: string): boolean {\n    // Check if path is watched or is under a watched directory\n    for (const watchPath of Array.from(this.watchPaths)) {\n      if (path === watchPath || path.startsWith(watchPath + '/')) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Update activity timestamp and reset inactivity timer\n   * @param path - Path where activity occurred\n   */\n  private updateActivity(path: string): void {\n    const parentPath = this.findWatchedParent(path);\n    if (parentPath) {\n      this.lastActivityMap.set(parentPath, Date.now());\n      this.resetInactivityTimer(parentPath);\n    }\n  }\n\n  /**\n   * Find the watched parent path for a given path\n   * @param path - Path to find parent for\n   * @returns Watched parent path, or undefined if not found\n   */\n  private findWatchedParent(path: string): string | undefined {\n    for (const watchPath of Array.from(this.watchPaths)) {\n      if (path === watchPath || path.startsWith(watchPath + '/')) {\n        return watchPath;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Reset the inactivity timer for a path\n   * @param path - Path to reset timer for\n   */\n  private resetInactivityTimer(path: string): void {\n    // Clear existing timer\n    const existingTimer = this.inactivityTimers.get(path);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n\n    // Set new timer\n    const timer = setTimeout(async () => {\n      const lastActivity = this.lastActivityMap.get(path) ?? 0;\n      await this.registry.emit({\n        type: 'timeout:inactivity',\n        lastActivity,\n        threshold: this.inactivityThreshold,\n      });\n    }, this.inactivityThreshold);\n\n    this.inactivityTimers.set(path, timer);\n  }\n}\n\n/**\n * Create a webhook registry instance\n *\n * Factory function for creating a configured webhook registry.\n *\n * @param config - Registry configuration\n * @returns Configured webhook registry\n *\n * @example\n * ```typescript\n * const registry = createWebhookRegistry({\n *   secret: process.env.WEBHOOK_SECRET,\n *   maxPayloadSize: 2 * 1024 * 1024, // 2MB\n *   rateLimit: 50\n * });\n * ```\n */\nexport function createWebhookRegistry(config?: WebhookConfig): WebhookRegistry {\n  return new WebhookRegistry(config);\n}\n\n/**\n * Create a file watcher integration instance\n *\n * Factory function for creating a configured file watcher integration.\n *\n * @param registry - Webhook registry to emit events to\n * @param options - Configuration options\n * @returns Configured file watcher integration\n *\n * @example\n * ```typescript\n * const registry = createWebhookRegistry();\n * const watcher = createFileWatcherIntegration(registry, {\n *   inactivityThreshold: 10 * 60 * 1000 // 10 minutes\n * });\n *\n * watcher.watch('/docs');\n * ```\n */\nexport function createFileWatcherIntegration(\n  registry: WebhookRegistry,\n  options?: { inactivityThreshold?: number }\n): FileWatcherIntegration {\n  return new FileWatcherIntegration(registry, options);\n}\n"],"names":[],"mappings":"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"}