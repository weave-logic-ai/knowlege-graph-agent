{"version":3,"file":"workflow-service.js","sources":["../../../src/workflow/services/workflow-service.ts"],"sourcesContent":["/**\n * Workflow Service\n *\n * Main service that orchestrates workflow execution with\n * Workflow DevKit, GOAP planning, and webhook handling.\n *\n * This service provides a unified interface for:\n * - Starting and managing workflows\n * - GOAP-based planning for task generation\n * - File watching and webhook handling\n * - Status monitoring and metrics\n *\n * @module workflow/services/workflow-service\n *\n * @example\n * ```typescript\n * import { createWorkflowService } from './workflow-service.js';\n *\n * const service = createWorkflowService({\n *   inactivityTimeout: 5 * 60 * 1000,\n *   autoStartThreshold: 0.7,\n *   watchPaths: ['./docs'],\n * });\n *\n * await service.start();\n *\n * // Start a collaboration workflow\n * const result = await service.startCollaborationWorkflow(\n *   'graph-123',\n *   './docs/spec.md'\n * );\n *\n * // Get service status\n * const status = service.getStatus();\n * console.log(`Active workflows: ${status.activeWorkflows.length}`);\n *\n * await service.stop();\n * ```\n */\n\nimport { createWorkflowConfig, type WorkflowConfig } from '../config.js';\nimport type {\n  WorldState,\n  GOAPPlan,\n  TaskSpec,\n  GapAnalysis,\n  DocumentGap,\n  WorkflowRunMetadata,\n  ReadinessEvaluation,\n} from '../types.js';\nimport { GOAPAdapter, createGOAPAdapter } from '../adapters/goap-adapter.js';\nimport {\n  createWebhookRegistry,\n  createFileWatcherIntegration,\n  type WebhookRegistry,\n  type FileWatcherIntegration,\n  type WorkflowTriggerEvent,\n} from '../handlers/webhook-handlers.js';\nimport { createLogger } from '../../utils/index.js';\n\nconst logger = createLogger('workflow-service');\n\n// ============================================================================\n// Configuration Types\n// ============================================================================\n\n/**\n * Workflow service configuration options\n */\nexport interface WorkflowServiceConfig {\n  /** Workflow DevKit configuration */\n  workflow?: WorkflowConfig;\n  /** Inactivity timeout in ms (default: 5 minutes) */\n  inactivityTimeout?: number;\n  /** Auto-start development threshold (default: 0.7) */\n  autoStartThreshold?: number;\n  /** Paths to watch for changes */\n  watchPaths?: string[];\n  /** Enable debug logging */\n  debug?: boolean;\n  /** Webhook secret for validation */\n  webhookSecret?: string;\n  /** Maximum payload size for webhooks */\n  maxPayloadSize?: number;\n}\n\n/**\n * Resolved configuration with defaults applied\n */\ninterface ResolvedConfig {\n  workflow: WorkflowConfig;\n  inactivityTimeout: number;\n  autoStartThreshold: number;\n  watchPaths: string[];\n  debug: boolean;\n  webhookSecret?: string;\n  maxPayloadSize: number;\n}\n\n// ============================================================================\n// Result Types\n// ============================================================================\n\n/**\n * Workflow execution result\n */\nexport interface WorkflowExecutionResult {\n  /** Whether workflow completed successfully */\n  success: boolean;\n  /** Unique workflow run identifier */\n  workflowId: string;\n  /** When the workflow started */\n  startedAt: Date;\n  /** When the workflow completed (if finished) */\n  completedAt?: Date;\n  /** Outcome of the workflow */\n  outcome?: 'completed' | 'failed' | 'timeout' | 'cancelled';\n  /** Artifacts produced by the workflow */\n  artifacts?: string[];\n  /** Error message if failed */\n  error?: string;\n}\n\n/**\n * Service status information\n */\nexport interface WorkflowServiceStatus {\n  /** Whether the service is currently running */\n  isRunning: boolean;\n  /** List of active workflow runs */\n  activeWorkflows: WorkflowRunMetadata[];\n  /** Paths being watched for changes */\n  watchedPaths: string[];\n  /** Timestamp of last activity */\n  lastActivity?: Date;\n  /** Execution statistics */\n  stats: WorkflowExecutionStats;\n}\n\n/**\n * Execution statistics\n */\nexport interface WorkflowExecutionStats {\n  /** Total number of workflow executions */\n  totalExecutions: number;\n  /** Number of successful executions */\n  successfulExecutions: number;\n  /** Number of failed executions */\n  failedExecutions: number;\n  /** Average execution duration in ms */\n  averageDuration: number;\n}\n\n// ============================================================================\n// Workflow Service Class\n// ============================================================================\n\n/**\n * Workflow Service\n *\n * Orchestrates the entire workflow system including:\n * - GOAP planning for intelligent task generation\n * - File watching for automatic workflow triggers\n * - Webhook handling for external integrations\n * - Execution tracking and metrics collection\n */\nexport class WorkflowService {\n  private config: ResolvedConfig;\n  private goapAdapter: GOAPAdapter;\n  private webhookRegistry: WebhookRegistry;\n  private fileWatcher: FileWatcherIntegration;\n\n  private isRunning = false;\n  private activeWorkflows: Map<string, WorkflowRunMetadata> = new Map();\n  private lastActivity?: Date;\n  private executionStats = {\n    totalExecutions: 0,\n    successfulExecutions: 0,\n    failedExecutions: 0,\n    totalDuration: 0,\n  };\n\n  /**\n   * Create a new workflow service\n   *\n   * @param config - Service configuration options\n   */\n  constructor(config: WorkflowServiceConfig = {}) {\n    this.config = this.resolveConfig(config);\n    this.goapAdapter = createGOAPAdapter();\n    this.webhookRegistry = createWebhookRegistry({\n      secret: this.config.webhookSecret,\n      maxPayloadSize: this.config.maxPayloadSize,\n    });\n    this.fileWatcher = createFileWatcherIntegration(this.webhookRegistry, {\n      inactivityThreshold: this.config.inactivityTimeout,\n    });\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Resolve configuration with defaults\n   */\n  private resolveConfig(config: WorkflowServiceConfig): ResolvedConfig {\n    return {\n      workflow: config.workflow ?? createWorkflowConfig(),\n      inactivityTimeout: config.inactivityTimeout ?? 5 * 60 * 1000,\n      autoStartThreshold: config.autoStartThreshold ?? 0.7,\n      watchPaths: config.watchPaths ?? [],\n      debug: config.debug ?? false,\n      webhookSecret: config.webhookSecret,\n      maxPayloadSize: config.maxPayloadSize ?? 1024 * 1024,\n    };\n  }\n\n  /**\n   * Setup event handlers for workflow triggers\n   */\n  private setupEventHandlers(): void {\n    // Handle file changes\n    this.webhookRegistry.on('file:changed', async (event) => {\n      if (event.type === 'file:changed') {\n        logger.debug('File changed event received', { path: event.path });\n        this.lastActivity = new Date();\n        await this.onDocumentChange(event.path);\n      }\n    });\n\n    // Handle file creation\n    this.webhookRegistry.on('file:created', async (event) => {\n      if (event.type === 'file:created') {\n        logger.debug('File created event received', { path: event.path });\n        this.lastActivity = new Date();\n        await this.onDocumentChange(event.path);\n      }\n    });\n\n    // Handle file deletion\n    this.webhookRegistry.on('file:deleted', async (event) => {\n      if (event.type === 'file:deleted') {\n        logger.debug('File deleted event received', { path: event.path });\n        this.lastActivity = new Date();\n      }\n    });\n\n    // Handle inactivity timeout\n    this.webhookRegistry.on('timeout:inactivity', async (event) => {\n      if (event.type === 'timeout:inactivity') {\n        logger.info('Inactivity timeout triggered', {\n          lastActivity: event.lastActivity,\n          threshold: event.threshold,\n        });\n        await this.onInactivityTimeout();\n      }\n    });\n  }\n\n  // ==========================================================================\n  // Lifecycle Methods\n  // ==========================================================================\n\n  /**\n   * Start the workflow service\n   *\n   * Begins watching configured paths and processing events.\n   */\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      logger.warn('Workflow service is already running');\n      return;\n    }\n\n    logger.info('Starting workflow service', {\n      world: this.config.workflow.world,\n      watchPaths: this.config.watchPaths,\n      inactivityTimeout: this.config.inactivityTimeout,\n    });\n\n    // Start watching configured paths\n    for (const path of this.config.watchPaths) {\n      this.fileWatcher.watch(path);\n    }\n\n    this.isRunning = true;\n    this.lastActivity = new Date();\n    logger.info('Workflow service started');\n  }\n\n  /**\n   * Stop the workflow service\n   *\n   * Stops watching all paths and cleans up resources.\n   */\n  async stop(): Promise<void> {\n    if (!this.isRunning) {\n      logger.warn('Workflow service is not running');\n      return;\n    }\n\n    logger.info('Stopping workflow service');\n\n    // Stop watching all paths\n    this.fileWatcher.unwatchAll();\n\n    // Clear all webhook handlers\n    this.webhookRegistry.clear();\n\n    this.isRunning = false;\n    logger.info('Workflow service stopped');\n  }\n\n  // ==========================================================================\n  // Event Handlers\n  // ==========================================================================\n\n  /**\n   * Handle document change event\n   *\n   * Analyzes the changed document for gaps and potentially\n   * starts development if completeness threshold is met.\n   */\n  private async onDocumentChange(docPath: string): Promise<void> {\n    logger.debug('Processing document change', { docPath });\n\n    try {\n      // Analyze gaps\n      const analysis = await this.analyzeGaps(docPath);\n\n      if (analysis.completeness >= this.config.autoStartThreshold) {\n        // Generate task spec if completeness threshold met\n        logger.info('Completeness threshold met, generating task spec', {\n          completeness: analysis.completeness,\n          threshold: this.config.autoStartThreshold,\n        });\n\n        await this.generateTaskSpec(docPath, analysis);\n      } else {\n        logger.debug('Waiting for more documentation', {\n          completeness: analysis.completeness,\n          threshold: this.config.autoStartThreshold,\n          gaps: analysis.gaps.length,\n        });\n      }\n    } catch (err) {\n      const actualError = err instanceof Error ? err : new Error(String(err));\n      logger.error(`Failed to process document change: ${docPath}`, actualError);\n    }\n  }\n\n  /**\n   * Handle inactivity timeout\n   *\n   * Checks for incomplete documentation and generates\n   * missing content when idle.\n   */\n  private async onInactivityTimeout(): Promise<void> {\n    logger.info('Inactivity timeout - checking for incomplete documentation');\n\n    // Get all watched paths and check for gaps\n    const watchedPaths = this.fileWatcher.getWatchedPaths();\n\n    for (const path of watchedPaths) {\n      try {\n        const analysis = await this.analyzeGaps(path);\n\n        if (analysis.gaps.length > 0) {\n          logger.info('Found documentation gaps during inactivity', {\n            path,\n            gapCount: analysis.gaps.length,\n          });\n\n          await this.generateMissingDocs(path, analysis);\n        }\n      } catch (err) {\n        const actualError = err instanceof Error ? err : new Error(String(err));\n        logger.error(`Failed to analyze path during inactivity: ${path}`, actualError);\n      }\n    }\n  }\n\n  // ==========================================================================\n  // Workflow Execution\n  // ==========================================================================\n\n  /**\n   * Start a collaboration workflow for a graph/document\n   *\n   * @param graphId - Knowledge graph identifier\n   * @param docPath - Path to the document\n   * @returns Workflow execution result\n   */\n  async startCollaborationWorkflow(\n    graphId: string,\n    docPath: string\n  ): Promise<WorkflowExecutionResult> {\n    const workflowId = this.generateWorkflowId('collab');\n    const startedAt = new Date();\n\n    logger.info('Starting collaboration workflow', { workflowId, graphId, docPath });\n\n    const metadata: WorkflowRunMetadata = {\n      id: workflowId,\n      type: 'realtime-collab',\n      startedAt,\n      status: 'running',\n      currentStep: 'initialize',\n      lastEventAt: startedAt,\n    };\n\n    this.activeWorkflows.set(workflowId, metadata);\n    this.executionStats.totalExecutions++;\n\n    try {\n      // Initialize world state from document\n      const worldState = await this.initializeWorldState(docPath);\n\n      // Create GOAP plan\n      const plan = this.goapAdapter.createPlan(worldState, 'start-development');\n\n      if (!plan.achievable) {\n        logger.warn('Goal not achievable with current state', {\n          worldState,\n          reason: plan.goal,\n        });\n      }\n\n      // Update metadata\n      metadata.currentStep = 'executing-plan';\n      metadata.lastEventAt = new Date();\n\n      // Execute plan\n      const execution = await this.goapAdapter.executePlan(plan, worldState);\n\n      const completedAt = new Date();\n      const duration = completedAt.getTime() - startedAt.getTime();\n\n      // Update stats\n      if (execution.success) {\n        this.executionStats.successfulExecutions++;\n        metadata.status = 'completed';\n      } else {\n        this.executionStats.failedExecutions++;\n        metadata.status = 'failed';\n      }\n      this.executionStats.totalDuration += duration;\n      metadata.lastEventAt = completedAt;\n\n      logger.info('Collaboration workflow completed', {\n        workflowId,\n        success: execution.success,\n        duration,\n        completedSteps: execution.completedSteps.length,\n      });\n\n      return {\n        success: execution.success,\n        workflowId,\n        startedAt,\n        completedAt,\n        outcome: execution.success ? 'completed' : 'failed',\n        artifacts: execution.completedSteps,\n        error: execution.error,\n      };\n    } catch (error) {\n      const completedAt = new Date();\n      const duration = completedAt.getTime() - startedAt.getTime();\n\n      metadata.status = 'failed';\n      metadata.lastEventAt = completedAt;\n      this.executionStats.failedExecutions++;\n      this.executionStats.totalDuration += duration;\n\n      const actualError = error instanceof Error ? error : new Error(String(error));\n      logger.error(`Workflow execution failed: ${workflowId}`, actualError);\n\n      return {\n        success: false,\n        workflowId,\n        startedAt,\n        completedAt,\n        outcome: 'failed',\n        error: actualError.message,\n      };\n    }\n  }\n\n  // ==========================================================================\n  // World State & Planning\n  // ==========================================================================\n\n  /**\n   * Initialize world state from a document\n   *\n   * @param docPath - Path to the document\n   * @returns Initial world state for planning\n   */\n  private async initializeWorldState(docPath: string): Promise<WorldState> {\n    // TODO: Integrate with actual document analysis\n    // For now, return a basic initial state\n    return {\n      hasSpecification: true,\n      specCompleteness: 0,\n      hasAcceptanceCriteria: false,\n      taskDefined: false,\n      blockersFree: true,\n      developmentStarted: false,\n      timeSinceLastChange: 0,\n      lastChangeTimestamp: Date.now(),\n      activeCollaborators: [],\n      pendingGaps: [],\n    };\n  }\n\n  /**\n   * Create a GOAP plan for a goal\n   *\n   * @param goal - Goal identifier\n   * @returns Generated plan\n   */\n  async createPlan(goal: string): Promise<GOAPPlan> {\n    const worldState = await this.initializeWorldState('');\n    return this.goapAdapter.createPlan(worldState, goal);\n  }\n\n  /**\n   * Evaluate readiness for development\n   *\n   * @param docPath - Path to the document\n   * @returns Readiness evaluation\n   */\n  async evaluateReadiness(docPath: string): Promise<ReadinessEvaluation> {\n    const worldState = await this.initializeWorldState(docPath);\n    const analysis = await this.analyzeGaps(docPath);\n\n    // Update world state with analysis results\n    worldState.specCompleteness = analysis.completeness;\n    worldState.hasAcceptanceCriteria = analysis.completeness >= 0.5;\n    worldState.pendingGaps = analysis.gaps.map((g) => g.description);\n\n    return this.goapAdapter.evaluateReadiness(worldState);\n  }\n\n  // ==========================================================================\n  // Gap Analysis & Documentation\n  // ==========================================================================\n\n  /**\n   * Analyze document for gaps\n   *\n   * @param docPath - Path to analyze\n   * @returns Gap analysis result\n   */\n  async analyzeGaps(docPath: string): Promise<GapAnalysis> {\n    logger.debug('Analyzing gaps', { docPath });\n\n    // Required sections for a complete specification\n    const requiredSections = [\n      'overview',\n      'requirements',\n      'acceptance-criteria',\n      'technical-spec',\n    ];\n\n    // TODO: Integrate with actual document analysis\n    // For now, simulate finding some sections\n    const foundCount = Math.floor(Math.random() * requiredSections.length) + 1;\n    const completeness = foundCount / requiredSections.length;\n\n    const gaps: DocumentGap[] = [];\n    for (let i = foundCount; i < requiredSections.length; i++) {\n      gaps.push({\n        type: 'missing_section',\n        description: `Missing ${requiredSections[i]} section`,\n        severity: 'high',\n        suggestedContent: `# ${requiredSections[i]}\\n\\nContent to be filled in.`,\n      });\n    }\n\n    const recommendations = gaps.map(\n      (g) => `Add ${g.description.toLowerCase()}`\n    );\n\n    return {\n      docPath,\n      completeness,\n      gaps,\n      recommendations,\n      analyzedAt: new Date(),\n    };\n  }\n\n  /**\n   * Generate task specification from documentation\n   *\n   * @param docPath - Path to the source document\n   * @param analysis - Gap analysis results\n   * @returns Generated task specification\n   */\n  async generateTaskSpec(docPath: string, analysis: GapAnalysis): Promise<TaskSpec> {\n    logger.info('Generating task spec', { docPath, completeness: analysis.completeness });\n\n    const priority = this.determinePriority(analysis.completeness);\n    const complexity = this.estimateComplexity(analysis);\n\n    const spec: TaskSpec = {\n      id: `task-${Date.now()}`,\n      version: '1.0.0',\n      title: `Task from ${this.extractFilename(docPath)}`,\n      description: 'Auto-generated task specification from documentation analysis',\n      priority,\n      requirements: this.extractRequirements(analysis),\n      acceptanceCriteria: this.generateAcceptanceCriteria(analysis),\n      estimatedComplexity: complexity,\n      sourceDoc: docPath,\n      generatedAt: new Date(),\n      confidence: analysis.completeness,\n    };\n\n    logger.debug('Task spec generated', { specId: spec.id, priority, complexity });\n    return spec;\n  }\n\n  /**\n   * Generate missing documentation\n   *\n   * @param docPath - Path to the document\n   * @param analysis - Gap analysis results\n   * @returns List of generated content\n   */\n  async generateMissingDocs(docPath: string, analysis: GapAnalysis): Promise<string[]> {\n    logger.info('Generating missing docs', {\n      docPath,\n      gapCount: analysis.gaps.length,\n    });\n\n    const generatedDocs: string[] = [];\n\n    for (const gap of analysis.gaps) {\n      const content =\n        gap.suggestedContent ||\n        `# ${gap.description}\\n\\nThis section needs to be completed.\\n`;\n      generatedDocs.push(content);\n    }\n\n    return generatedDocs;\n  }\n\n  // ==========================================================================\n  // Helper Methods\n  // ==========================================================================\n\n  /**\n   * Generate a unique workflow ID\n   */\n  private generateWorkflowId(prefix: string): string {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substring(2, 11);\n    return `${prefix}-${timestamp}-${random}`;\n  }\n\n  /**\n   * Extract filename from path\n   */\n  private extractFilename(path: string): string {\n    const parts = path.split('/');\n    return parts[parts.length - 1] || 'unknown';\n  }\n\n  /**\n   * Determine priority based on completeness\n   */\n  private determinePriority(\n    completeness: number\n  ): 'low' | 'medium' | 'high' | 'critical' {\n    if (completeness >= 0.9) return 'high';\n    if (completeness >= 0.7) return 'medium';\n    if (completeness >= 0.5) return 'low';\n    return 'critical'; // Needs more work before starting\n  }\n\n  /**\n   * Estimate complexity from analysis\n   */\n  private estimateComplexity(analysis: GapAnalysis): number {\n    // Base complexity on inverse of completeness\n    const baseComplexity = Math.ceil((1 - analysis.completeness) * 10);\n    // Add complexity for each gap\n    const gapComplexity = analysis.gaps.length;\n    return Math.min(10, Math.max(1, baseComplexity + gapComplexity));\n  }\n\n  /**\n   * Extract requirements from analysis\n   */\n  private extractRequirements(analysis: GapAnalysis): string[] {\n    const requirements = analysis.recommendations.slice();\n    if (requirements.length === 0) {\n      requirements.push('Complete specification document');\n    }\n    return requirements;\n  }\n\n  /**\n   * Generate acceptance criteria from analysis\n   */\n  private generateAcceptanceCriteria(analysis: GapAnalysis): string[] {\n    const criteria = [\n      'Documentation is complete',\n      'All tests pass',\n      `Completeness score >= ${this.config.autoStartThreshold}`,\n    ];\n\n    if (analysis.gaps.length > 0) {\n      criteria.push(`All ${analysis.gaps.length} gaps are addressed`);\n    }\n\n    return criteria;\n  }\n\n  // ==========================================================================\n  // Public API\n  // ==========================================================================\n\n  /**\n   * Add a path to watch\n   *\n   * @param path - Path to watch for changes\n   */\n  watch(path: string): void {\n    this.fileWatcher.watch(path);\n    this.config.watchPaths.push(path);\n    logger.debug('Added watch path', { path });\n  }\n\n  /**\n   * Stop watching a path\n   *\n   * @param path - Path to stop watching\n   */\n  unwatch(path: string): void {\n    this.fileWatcher.unwatch(path);\n    const index = this.config.watchPaths.indexOf(path);\n    if (index > -1) {\n      this.config.watchPaths.splice(index, 1);\n    }\n    logger.debug('Removed watch path', { path });\n  }\n\n  /**\n   * Get the webhook registry for external event handling\n   *\n   * @returns Webhook registry instance\n   */\n  getWebhookRegistry(): WebhookRegistry {\n    return this.webhookRegistry;\n  }\n\n  /**\n   * Get the GOAP adapter for direct planning access\n   *\n   * @returns GOAP adapter instance\n   */\n  getGOAPAdapter(): GOAPAdapter {\n    return this.goapAdapter;\n  }\n\n  /**\n   * Emit a workflow trigger event\n   *\n   * @param event - Event to emit\n   */\n  async emitEvent(event: WorkflowTriggerEvent): Promise<void> {\n    await this.webhookRegistry.emit(event);\n    this.lastActivity = new Date();\n  }\n\n  /**\n   * Get service status\n   *\n   * @returns Current service status\n   */\n  getStatus(): WorkflowServiceStatus {\n    const avgDuration =\n      this.executionStats.totalExecutions > 0\n        ? this.executionStats.totalDuration / this.executionStats.totalExecutions\n        : 0;\n\n    return {\n      isRunning: this.isRunning,\n      activeWorkflows: Array.from(this.activeWorkflows.values()),\n      watchedPaths: this.fileWatcher.getWatchedPaths(),\n      lastActivity: this.lastActivity,\n      stats: {\n        totalExecutions: this.executionStats.totalExecutions,\n        successfulExecutions: this.executionStats.successfulExecutions,\n        failedExecutions: this.executionStats.failedExecutions,\n        averageDuration: avgDuration,\n      },\n    };\n  }\n\n  /**\n   * Get workflow configuration\n   *\n   * @returns Copy of the current configuration\n   */\n  getConfig(): WorkflowServiceConfig {\n    return {\n      workflow: this.config.workflow,\n      inactivityTimeout: this.config.inactivityTimeout,\n      autoStartThreshold: this.config.autoStartThreshold,\n      watchPaths: [...this.config.watchPaths],\n      debug: this.config.debug,\n    };\n  }\n\n  /**\n   * Get a specific workflow run by ID\n   *\n   * @param workflowId - Workflow run identifier\n   * @returns Workflow metadata or undefined\n   */\n  getWorkflow(workflowId: string): WorkflowRunMetadata | undefined {\n    return this.activeWorkflows.get(workflowId);\n  }\n\n  /**\n   * Cancel a running workflow\n   *\n   * @param workflowId - Workflow to cancel\n   * @returns Whether the workflow was cancelled\n   */\n  cancelWorkflow(workflowId: string): boolean {\n    const workflow = this.activeWorkflows.get(workflowId);\n    if (workflow && workflow.status === 'running') {\n      workflow.status = 'failed';\n      workflow.lastEventAt = new Date();\n      logger.info('Workflow cancelled', { workflowId });\n      return true;\n    }\n    return false;\n  }\n}\n\n// ============================================================================\n// Factory Function\n// ============================================================================\n\n/**\n * Create a workflow service instance\n *\n * @param config - Service configuration options\n * @returns Configured workflow service\n *\n * @example\n * ```typescript\n * const service = createWorkflowService({\n *   watchPaths: ['./docs', './specs'],\n *   autoStartThreshold: 0.8,\n * });\n *\n * await service.start();\n * ```\n */\nexport function createWorkflowService(config?: WorkflowServiceConfig): WorkflowService {\n  return new WorkflowService(config);\n}\n"],"names":[],"mappings":"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"}