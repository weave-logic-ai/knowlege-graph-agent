{"version":3,"file":"registry.js","sources":["../../src/workflows/registry.ts"],"sourcesContent":["/**\n * Workflow Registry\n *\n * Manages workflow definitions, execution, and history tracking.\n * Supports step dependencies, parallel execution, and rollback.\n *\n * @module workflows/registry\n */\n\nimport { createLogger } from '../utils/index.js';\nimport {\n  WorkflowStatus,\n  type WorkflowDefinition,\n  type WorkflowStep,\n  type WorkflowExecution,\n  type WorkflowResult,\n  type WorkflowExecutionStats,\n  type StepExecution,\n  type StepContext,\n  type WorkflowRegistryOptions,\n  type WorkflowListOptions,\n  type ExecutionHistoryOptions,\n  type WorkflowEvent,\n  type WorkflowEventType,\n  type WorkflowEventListener,\n} from './types.js';\n\nconst logger = createLogger('workflow-registry');\n\n/**\n * Generate unique execution ID\n */\nfunction generateExecutionId(): string {\n  const timestamp = Date.now().toString(36);\n  const random = Math.random().toString(36).substring(2, 10);\n  return `exec_${timestamp}_${random}`;\n}\n\n/**\n * Workflow Registry\n *\n * Central registry for managing workflow definitions and executions.\n *\n * @example\n * ```typescript\n * const registry = new WorkflowRegistry();\n *\n * // Register a workflow\n * registry.register({\n *   id: 'sync-workflow',\n *   name: 'Sync Knowledge Graph',\n *   version: '1.0.0',\n *   steps: [\n *     {\n *       id: 'analyze',\n *       name: 'Analyze Changes',\n *       handler: async (input, ctx) => {\n *         // Analyze logic\n *         return { changes: [] };\n *       },\n *     },\n *     {\n *       id: 'sync',\n *       name: 'Sync to Memory',\n *       dependencies: ['analyze'],\n *       handler: async (input, ctx) => {\n *         const analysis = ctx.previousResults.get('analyze');\n *         // Sync logic\n *       },\n *     },\n *   ],\n * });\n *\n * // Execute workflow\n * const result = await registry.execute('sync-workflow', { projectRoot: '.' });\n * ```\n */\nexport class WorkflowRegistry {\n  private workflows: Map<string, WorkflowDefinition> = new Map();\n  private executions: Map<string, WorkflowExecution> = new Map();\n  private history: WorkflowExecution[] = [];\n  private activeExecutions: Set<string> = new Set();\n  private eventListeners: Map<WorkflowEventType | '*', Set<WorkflowEventListener>> = new Map();\n  private abortControllers: Map<string, AbortController> = new Map();\n\n  private options: Required<WorkflowRegistryOptions>;\n\n  constructor(options: WorkflowRegistryOptions = {}) {\n    this.options = {\n      maxConcurrentExecutions: options.maxConcurrentExecutions ?? 10,\n      defaultStepTimeout: options.defaultStepTimeout ?? 300000, // 5 minutes\n      defaultRetries: options.defaultRetries ?? 3,\n      defaultRetryDelay: options.defaultRetryDelay ?? 1000,\n      persistHistory: options.persistHistory ?? true,\n      maxHistoryEntries: options.maxHistoryEntries ?? 1000,\n      logger: options.logger ?? ((level, msg, data) => {\n        if (level === 'error') logger.error(msg, data as Error | undefined);\n        else if (level === 'warn') logger.warn(msg, data);\n        else if (level === 'debug') logger.debug(msg, data);\n        else logger.info(msg, data);\n      }),\n    };\n  }\n\n  /**\n   * Register a workflow definition\n   */\n  register<TInput = unknown, TOutput = unknown>(\n    workflow: WorkflowDefinition<TInput, TOutput>\n  ): void {\n    // Validate workflow\n    this.validateWorkflow(workflow as WorkflowDefinition);\n\n    // Check for duplicate\n    if (this.workflows.has(workflow.id)) {\n      logger.warn('Overwriting existing workflow', { workflowId: workflow.id });\n    }\n\n    // Store with type assertion - the generic types are preserved at runtime\n    this.workflows.set(workflow.id, workflow as unknown as WorkflowDefinition);\n    logger.info('Workflow registered', {\n      workflowId: workflow.id,\n      version: workflow.version,\n      steps: workflow.steps.length,\n    });\n  }\n\n  /**\n   * Unregister a workflow definition\n   */\n  unregister(workflowId: string): boolean {\n    const existed = this.workflows.delete(workflowId);\n    if (existed) {\n      logger.info('Workflow unregistered', { workflowId });\n    }\n    return existed;\n  }\n\n  /**\n   * Get a workflow definition by ID\n   */\n  get<TInput = unknown, TOutput = unknown>(\n    workflowId: string\n  ): WorkflowDefinition<TInput, TOutput> | undefined {\n    return this.workflows.get(workflowId) as WorkflowDefinition<TInput, TOutput> | undefined;\n  }\n\n  /**\n   * List all registered workflows\n   */\n  list(options: WorkflowListOptions = {}): WorkflowDefinition[] {\n    let workflows = Array.from(this.workflows.values());\n\n    // Filter by tags\n    if (options.tags && options.tags.length > 0) {\n      workflows = workflows.filter(w =>\n        w.tags?.some(t => options.tags!.includes(t))\n      );\n    }\n\n    // Filter by version\n    if (options.version) {\n      const versionPattern = new RegExp(options.version);\n      workflows = workflows.filter(w => versionPattern.test(w.version));\n    }\n\n    // Filter by name pattern\n    if (options.namePattern) {\n      const namePattern = new RegExp(options.namePattern, 'i');\n      workflows = workflows.filter(w => namePattern.test(w.name));\n    }\n\n    // Apply pagination\n    const offset = options.offset ?? 0;\n    const limit = options.limit ?? workflows.length;\n    workflows = workflows.slice(offset, offset + limit);\n\n    return workflows;\n  }\n\n  /**\n   * Execute a workflow\n   */\n  async execute<TInput = unknown, TOutput = unknown>(\n    workflowId: string,\n    input: TInput,\n    options: { metadata?: Record<string, unknown> } = {}\n  ): Promise<WorkflowResult<TOutput>> {\n    const workflow = this.workflows.get(workflowId);\n    if (!workflow) {\n      throw new Error(`Workflow not found: ${workflowId}`);\n    }\n\n    // Check concurrent execution limit\n    if (this.activeExecutions.size >= this.options.maxConcurrentExecutions) {\n      throw new Error('Maximum concurrent executions reached');\n    }\n\n    // Create execution record\n    const executionId = generateExecutionId();\n    const abortController = new AbortController();\n    this.abortControllers.set(executionId, abortController);\n\n    const execution: WorkflowExecution<TInput, TOutput> = {\n      id: executionId,\n      workflowId,\n      status: WorkflowStatus.Pending,\n      input,\n      state: { ...workflow.initialState },\n      steps: new Map(),\n      createdAt: new Date(),\n      metadata: options.metadata,\n      progress: 0,\n    };\n\n    // Initialize step executions\n    for (const step of workflow.steps) {\n      execution.steps.set(step.id, {\n        stepId: step.id,\n        status: WorkflowStatus.Pending,\n        attempts: 0,\n      });\n    }\n\n    this.executions.set(executionId, execution as WorkflowExecution);\n    this.activeExecutions.add(executionId);\n\n    try {\n      // Start execution\n      execution.status = WorkflowStatus.Running;\n      execution.startedAt = new Date();\n      this.emitEvent('workflow:started', executionId, workflowId);\n\n      // Create step context\n      const context: StepContext = {\n        workflowId,\n        stepId: '',\n        previousResults: new Map(),\n        state: execution.state,\n        log: (message, data) => {\n          this.options.logger('info', `[${workflowId}] ${message}`, data);\n        },\n        signal: abortController.signal,\n      };\n\n      // Call onStart hook\n      if (workflow.onStart) {\n        await workflow.onStart(input as never, context);\n      }\n\n      // Execute steps in dependency order\n      const completedSteps: Set<string> = new Set();\n      const stepResults = new Map<string, unknown>();\n\n      await this.executeSteps(\n        workflow,\n        execution as WorkflowExecution,\n        context,\n        completedSteps,\n        stepResults\n      );\n\n      // Transform output\n      const output = workflow.transformOutput\n        ? workflow.transformOutput(stepResults)\n        : stepResults.get(workflow.steps[workflow.steps.length - 1]?.id);\n\n      execution.output = output as TOutput;\n      execution.status = WorkflowStatus.Completed;\n      execution.completedAt = new Date();\n      execution.durationMs = execution.completedAt.getTime() - execution.startedAt.getTime();\n      execution.progress = 100;\n\n      // Call onComplete hook\n      if (workflow.onComplete) {\n        await workflow.onComplete(output as never, context);\n      }\n\n      this.emitEvent('workflow:completed', executionId, workflowId);\n\n      return this.createResult(execution as WorkflowExecution, stepResults);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      const errorStack = error instanceof Error ? error.stack : undefined;\n\n      execution.error = errorMessage;\n      execution.errorStack = errorStack;\n      execution.status = WorkflowStatus.Failed;\n      execution.completedAt = new Date();\n      execution.durationMs = execution.startedAt\n        ? execution.completedAt.getTime() - execution.startedAt.getTime()\n        : 0;\n\n      // Call onError hook\n      if (workflow.onError) {\n        const context: StepContext = {\n          workflowId,\n          stepId: '',\n          previousResults: new Map(),\n          state: execution.state,\n          log: (message, data) => {\n            this.options.logger('info', `[${workflowId}] ${message}`, data);\n          },\n        };\n        await workflow.onError(error instanceof Error ? error : new Error(errorMessage), context);\n      }\n\n      // Attempt rollback if enabled\n      if (workflow.enableRollback) {\n        await this.rollback(execution as WorkflowExecution, workflow);\n      }\n\n      this.emitEvent('workflow:failed', executionId, workflowId, undefined, { error: errorMessage });\n\n      return this.createResult(execution as WorkflowExecution, new Map());\n    } finally {\n      this.activeExecutions.delete(executionId);\n      this.abortControllers.delete(executionId);\n\n      // Add to history\n      if (this.options.persistHistory) {\n        this.history.push(execution as WorkflowExecution);\n        if (this.history.length > this.options.maxHistoryEntries) {\n          this.history.shift();\n        }\n      }\n    }\n  }\n\n  /**\n   * Cancel a running workflow execution\n   */\n  cancel(executionId: string): boolean {\n    const execution = this.executions.get(executionId);\n    if (!execution || execution.status !== WorkflowStatus.Running) {\n      return false;\n    }\n\n    const abortController = this.abortControllers.get(executionId);\n    if (abortController) {\n      abortController.abort();\n    }\n\n    execution.status = WorkflowStatus.Cancelled;\n    execution.completedAt = new Date();\n    this.emitEvent('workflow:cancelled', executionId, execution.workflowId);\n\n    return true;\n  }\n\n  /**\n   * Get execution by ID\n   */\n  getExecution(executionId: string): WorkflowExecution | undefined {\n    return this.executions.get(executionId);\n  }\n\n  /**\n   * Get execution history\n   */\n  getHistory(options: ExecutionHistoryOptions = {}): WorkflowExecution[] {\n    let history = [...this.history];\n\n    // Apply filters\n    if (options.workflowId) {\n      history = history.filter(e => e.workflowId === options.workflowId);\n    }\n    if (options.status) {\n      history = history.filter(e => e.status === options.status);\n    }\n    if (options.after) {\n      history = history.filter(e => e.startedAt && e.startedAt >= options.after!);\n    }\n    if (options.before) {\n      history = history.filter(e => e.startedAt && e.startedAt <= options.before!);\n    }\n\n    // Sort\n    history.sort((a, b) => {\n      const aTime = a.startedAt?.getTime() ?? a.createdAt.getTime();\n      const bTime = b.startedAt?.getTime() ?? b.createdAt.getTime();\n      return options.sortOrder === 'asc' ? aTime - bTime : bTime - aTime;\n    });\n\n    // Apply pagination\n    const offset = options.offset ?? 0;\n    const limit = options.limit ?? history.length;\n    return history.slice(offset, offset + limit);\n  }\n\n  /**\n   * Add event listener\n   */\n  on(event: WorkflowEventType | '*', listener: WorkflowEventListener): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, new Set());\n    }\n    this.eventListeners.get(event)!.add(listener);\n  }\n\n  /**\n   * Remove event listener\n   */\n  off(event: WorkflowEventType | '*', listener: WorkflowEventListener): void {\n    this.eventListeners.get(event)?.delete(listener);\n  }\n\n  /**\n   * Clear all executions and history\n   */\n  clear(): void {\n    this.executions.clear();\n    this.history = [];\n    this.activeExecutions.clear();\n  }\n\n  // Private methods\n\n  private validateWorkflow(workflow: WorkflowDefinition): void {\n    if (!workflow.id) {\n      throw new Error('Workflow must have an id');\n    }\n    if (!workflow.name) {\n      throw new Error('Workflow must have a name');\n    }\n    if (!workflow.version) {\n      throw new Error('Workflow must have a version');\n    }\n    if (!workflow.steps || workflow.steps.length === 0) {\n      throw new Error('Workflow must have at least one step');\n    }\n\n    // Validate steps\n    const stepIds = new Set<string>();\n    for (const step of workflow.steps) {\n      if (!step.id) {\n        throw new Error('Step must have an id');\n      }\n      if (!step.name) {\n        throw new Error(`Step ${step.id} must have a name`);\n      }\n      if (!step.handler) {\n        throw new Error(`Step ${step.id} must have a handler`);\n      }\n      if (stepIds.has(step.id)) {\n        throw new Error(`Duplicate step id: ${step.id}`);\n      }\n      stepIds.add(step.id);\n    }\n\n    // Validate dependencies\n    for (const step of workflow.steps) {\n      if (step.dependencies) {\n        for (const dep of step.dependencies) {\n          if (!stepIds.has(dep)) {\n            throw new Error(`Step ${step.id} depends on unknown step: ${dep}`);\n          }\n        }\n      }\n    }\n\n    // Check for circular dependencies\n    this.checkCircularDependencies(workflow.steps);\n  }\n\n  private checkCircularDependencies(steps: WorkflowStep[]): void {\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n\n    const dfs = (stepId: string): boolean => {\n      visited.add(stepId);\n      recursionStack.add(stepId);\n\n      const step = steps.find(s => s.id === stepId);\n      if (step?.dependencies) {\n        for (const dep of step.dependencies) {\n          if (!visited.has(dep)) {\n            if (dfs(dep)) return true;\n          } else if (recursionStack.has(dep)) {\n            return true;\n          }\n        }\n      }\n\n      recursionStack.delete(stepId);\n      return false;\n    };\n\n    for (const step of steps) {\n      if (!visited.has(step.id)) {\n        if (dfs(step.id)) {\n          throw new Error(`Circular dependency detected involving step: ${step.id}`);\n        }\n      }\n    }\n  }\n\n  private async executeSteps(\n    workflow: WorkflowDefinition,\n    execution: WorkflowExecution,\n    context: StepContext,\n    completedSteps: Set<string>,\n    stepResults: Map<string, unknown>\n  ): Promise<void> {\n    const remainingSteps = workflow.steps.filter(s => !completedSteps.has(s.id));\n\n    if (remainingSteps.length === 0) {\n      return;\n    }\n\n    // Find steps that can be executed (all dependencies completed)\n    const executableSteps = remainingSteps.filter(step => {\n      if (!step.dependencies || step.dependencies.length === 0) {\n        return true;\n      }\n      return step.dependencies.every(dep => completedSteps.has(dep));\n    });\n\n    if (executableSteps.length === 0) {\n      // This shouldn't happen if dependency validation is correct\n      throw new Error('No executable steps found but workflow not complete');\n    }\n\n    // Group parallel steps\n    const parallelSteps = executableSteps.filter(s => s.parallel !== false);\n    const sequentialSteps = executableSteps.filter(s => s.parallel === false);\n\n    // Execute parallel steps concurrently\n    if (parallelSteps.length > 0) {\n      await Promise.all(\n        parallelSteps.map(step =>\n          this.executeStep(step, workflow, execution, context, stepResults)\n        )\n      );\n      parallelSteps.forEach(s => completedSteps.add(s.id));\n    }\n\n    // Execute sequential steps one by one\n    for (const step of sequentialSteps) {\n      await this.executeStep(step, workflow, execution, context, stepResults);\n      completedSteps.add(step.id);\n    }\n\n    // Update progress\n    execution.progress = Math.round((completedSteps.size / workflow.steps.length) * 100);\n\n    // Continue with remaining steps\n    await this.executeSteps(workflow, execution, context, completedSteps, stepResults);\n  }\n\n  private async executeStep(\n    step: WorkflowStep,\n    workflow: WorkflowDefinition,\n    execution: WorkflowExecution,\n    context: StepContext,\n    stepResults: Map<string, unknown>\n  ): Promise<void> {\n    const stepExecution = execution.steps.get(step.id)!;\n    execution.currentStep = step.id;\n\n    // Check abort signal\n    if (context.signal?.aborted) {\n      throw new Error('Workflow cancelled');\n    }\n\n    // Update context\n    context.stepId = step.id;\n    context.previousResults = new Map(stepResults);\n\n    // Check condition\n    if (step.condition) {\n      const shouldRun = await step.condition(context);\n      if (!shouldRun) {\n        stepExecution.status = WorkflowStatus.Completed;\n        stepExecution.skipped = true;\n        stepExecution.skipReason = 'Condition not met';\n        this.emitEvent('step:skipped', execution.id, workflow.id, step.id);\n        return;\n      }\n    }\n\n    stepExecution.status = WorkflowStatus.Running;\n    stepExecution.startedAt = new Date();\n    this.emitEvent('step:started', execution.id, workflow.id, step.id);\n\n    const timeout = step.timeout ?? this.options.defaultStepTimeout;\n    const maxRetries = step.retries ?? this.options.defaultRetries;\n    const retryDelay = step.retryDelay ?? this.options.defaultRetryDelay;\n\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      stepExecution.attempts = attempt + 1;\n\n      try {\n        // Get input\n        const input = step.transformInput\n          ? step.transformInput(context.previousResults)\n          : context.previousResults.get(step.dependencies?.[0] ?? '');\n\n        // Execute with timeout\n        const result = await this.executeWithTimeout(\n          step.handler(input, context),\n          timeout,\n          `Step ${step.id} timed out after ${timeout}ms`\n        );\n\n        stepExecution.result = result;\n        stepExecution.status = WorkflowStatus.Completed;\n        stepExecution.completedAt = new Date();\n        stepExecution.durationMs =\n          stepExecution.completedAt.getTime() - stepExecution.startedAt!.getTime();\n\n        stepResults.set(step.id, result);\n        this.emitEvent('step:completed', execution.id, workflow.id, step.id);\n        return;\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (attempt < maxRetries) {\n          this.emitEvent('step:retrying', execution.id, workflow.id, step.id, {\n            attempt: attempt + 1,\n            error: lastError.message,\n          });\n          await this.sleep(retryDelay * Math.pow(2, attempt)); // Exponential backoff\n        }\n      }\n    }\n\n    // All retries exhausted\n    stepExecution.error = lastError?.message ?? 'Unknown error';\n    stepExecution.errorStack = lastError?.stack;\n    stepExecution.status = WorkflowStatus.Failed;\n    stepExecution.completedAt = new Date();\n    stepExecution.durationMs =\n      stepExecution.completedAt.getTime() - stepExecution.startedAt!.getTime();\n\n    this.emitEvent('step:failed', execution.id, workflow.id, step.id, {\n      error: stepExecution.error,\n    });\n\n    // If step is optional, don't throw\n    if (step.optional) {\n      stepExecution.skipped = true;\n      stepExecution.skipReason = 'Failed but optional';\n      return;\n    }\n\n    throw lastError ?? new Error(`Step ${step.id} failed`);\n  }\n\n  private async rollback(\n    execution: WorkflowExecution,\n    workflow: WorkflowDefinition\n  ): Promise<void> {\n    execution.status = WorkflowStatus.RollingBack;\n    this.emitEvent('rollback:started', execution.id, workflow.id);\n\n    const context: StepContext = {\n      workflowId: workflow.id,\n      stepId: '',\n      previousResults: new Map(),\n      state: execution.state,\n      log: (message, data) => {\n        this.options.logger('info', `[${workflow.id}] ${message}`, data);\n      },\n    };\n\n    // Get completed steps in reverse order\n    const completedSteps = workflow.steps\n      .filter(s => {\n        const stepExec = execution.steps.get(s.id);\n        return stepExec?.status === WorkflowStatus.Completed && !stepExec.skipped;\n      })\n      .reverse();\n\n    let rollbackFailed = false;\n\n    for (const step of completedSteps) {\n      if (!step.rollback) continue;\n\n      context.stepId = step.id;\n      const stepExec = execution.steps.get(step.id)!;\n\n      try {\n        await step.rollback(stepExec.result, context);\n        logger.info('Step rolled back', { stepId: step.id });\n      } catch (error) {\n        logger.error(\n          'Rollback failed for step',\n          error instanceof Error ? error : new Error(String(error)),\n          { stepId: step.id }\n        );\n        rollbackFailed = true;\n      }\n    }\n\n    execution.rolledBack = true;\n    execution.status = rollbackFailed ? WorkflowStatus.Failed : WorkflowStatus.RolledBack;\n    this.emitEvent(\n      rollbackFailed ? 'rollback:failed' : 'rollback:completed',\n      execution.id,\n      workflow.id\n    );\n  }\n\n  private async executeWithTimeout<T>(\n    promise: Promise<T>,\n    timeoutMs: number,\n    errorMessage: string\n  ): Promise<T> {\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      setTimeout(() => reject(new Error(errorMessage)), timeoutMs);\n    });\n    return Promise.race([promise, timeoutPromise]);\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  private createResult<TOutput>(\n    execution: WorkflowExecution,\n    stepResults: Map<string, unknown>\n  ): WorkflowResult<TOutput> {\n    const stepErrors = new Map<string, string>();\n    let completedSteps = 0;\n    let failedSteps = 0;\n    let skippedSteps = 0;\n    let totalRetries = 0;\n\n    for (const [stepId, stepExec] of execution.steps) {\n      if (stepExec.status === WorkflowStatus.Completed) {\n        if (stepExec.skipped) {\n          skippedSteps++;\n        } else {\n          completedSteps++;\n        }\n      } else if (stepExec.status === WorkflowStatus.Failed) {\n        failedSteps++;\n        if (stepExec.error) {\n          stepErrors.set(stepId, stepExec.error);\n        }\n      }\n      totalRetries += Math.max(0, stepExec.attempts - 1);\n    }\n\n    const stats: WorkflowExecutionStats = {\n      totalSteps: execution.steps.size,\n      completedSteps,\n      failedSteps,\n      skippedSteps,\n      totalRetries,\n      startTime: execution.startedAt ?? execution.createdAt,\n      endTime: execution.completedAt ?? new Date(),\n      totalDurationMs: execution.durationMs ?? 0,\n      avgStepDurationMs: completedSteps > 0 ? (execution.durationMs ?? 0) / completedSteps : 0,\n    };\n\n    return {\n      success: execution.status === WorkflowStatus.Completed,\n      executionId: execution.id,\n      workflowId: execution.workflowId,\n      status: execution.status,\n      output: execution.output as TOutput,\n      error: execution.error,\n      errorStack: execution.errorStack,\n      durationMs: execution.durationMs ?? 0,\n      stepResults,\n      stepErrors,\n      rolledBack: execution.rolledBack ?? false,\n      stats,\n    };\n  }\n\n  private emitEvent(\n    type: WorkflowEventType,\n    executionId: string,\n    workflowId: string,\n    stepId?: string,\n    data?: Record<string, unknown>\n  ): void {\n    const event: WorkflowEvent = {\n      type,\n      executionId,\n      workflowId,\n      stepId,\n      timestamp: new Date(),\n      data,\n      error: data?.error as string | undefined,\n    };\n\n    // Emit to specific listeners\n    const specificListeners = this.eventListeners.get(type);\n    if (specificListeners) {\n      for (const listener of specificListeners) {\n        try {\n          const result = listener(event);\n          if (result instanceof Promise) {\n            result.catch(err => logger.error('Event listener error', err));\n          }\n        } catch (error) {\n          logger.error('Event listener error', error as Error);\n        }\n      }\n    }\n\n    // Emit to wildcard listeners\n    const wildcardListeners = this.eventListeners.get('*');\n    if (wildcardListeners) {\n      for (const listener of wildcardListeners) {\n        try {\n          const result = listener(event);\n          if (result instanceof Promise) {\n            result.catch(err => logger.error('Event listener error', err));\n          }\n        } catch (error) {\n          logger.error('Event listener error', error as Error);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Create a workflow registry instance\n */\nexport function createWorkflowRegistry(\n  options?: WorkflowRegistryOptions\n): WorkflowRegistry {\n  return new WorkflowRegistry(options);\n}\n"],"names":[],"mappings":"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"}