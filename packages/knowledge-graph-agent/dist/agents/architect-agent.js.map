{"version":3,"file":"architect-agent.js","sources":["../../src/agents/architect-agent.ts"],"sourcesContent":["/**\n * Architect Agent\n *\n * Specialized agent for architecture analysis, design decisions, and dependency analysis.\n * Extends BaseAgent with system design capabilities and knowledge graph integration.\n *\n * @module agents/architect-agent\n */\n\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseAgent } from './base-agent.js';\nimport {\n  AgentType,\n  type AgentTask,\n  type AgentResult,\n  type ArchitectAgentConfig,\n  type ResultArtifact,\n} from './types.js';\nimport { KnowledgeGraphManager } from '../core/graph.js';\nimport type { KnowledgeNode } from '../core/types.js';\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Architecture pattern\n */\nexport type ArchitecturePattern =\n  | 'mvc'\n  | 'mvvm'\n  | 'clean-architecture'\n  | 'hexagonal'\n  | 'microservices'\n  | 'monolith'\n  | 'serverless'\n  | 'event-driven'\n  | 'layered'\n  | 'modular';\n\n/**\n * Component type\n */\nexport type ComponentType =\n  | 'service'\n  | 'controller'\n  | 'repository'\n  | 'model'\n  | 'view'\n  | 'utility'\n  | 'middleware'\n  | 'handler'\n  | 'factory'\n  | 'adapter';\n\n/**\n * Architecture component\n */\nexport interface ArchitectureComponent {\n  /** Component name */\n  name: string;\n  /** Component type */\n  type: ComponentType;\n  /** File path */\n  path: string;\n  /** Component description */\n  description?: string;\n  /** Dependencies (other components) */\n  dependencies: string[];\n  /** Dependents (components that depend on this) */\n  dependents: string[];\n  /** Exports provided */\n  exports: string[];\n  /** Lines of code */\n  linesOfCode: number;\n  /** Complexity score */\n  complexity: number;\n}\n\n/**\n * Architecture layer\n */\nexport interface ArchitectureLayer {\n  /** Layer name */\n  name: string;\n  /** Layer level (0 = highest, like UI) */\n  level: number;\n  /** Components in this layer */\n  components: string[];\n  /** Allowed dependencies (layer names) */\n  allowedDependencies: string[];\n  /** Actual dependencies found */\n  actualDependencies: string[];\n  /** Violations (dependencies to wrong layers) */\n  violations: string[];\n}\n\n/**\n * Dependency graph node\n */\nexport interface DependencyNode {\n  /** Node identifier */\n  id: string;\n  /** Node label */\n  label: string;\n  /** Node type */\n  type: ComponentType;\n  /** Outgoing edges (dependencies) */\n  outgoing: string[];\n  /** Incoming edges (dependents) */\n  incoming: string[];\n  /** Metrics */\n  metrics: {\n    fanIn: number;\n    fanOut: number;\n    instability: number;\n    abstractness: number;\n  };\n}\n\n/**\n * Dependency analysis result\n */\nexport interface DependencyAnalysis {\n  /** Dependency graph */\n  graph: DependencyNode[];\n  /** Circular dependencies */\n  cycles: string[][];\n  /** Orphan modules (no deps or dependents) */\n  orphans: string[];\n  /** Hub modules (many dependencies) */\n  hubs: Array<{ module: string; connections: number }>;\n  /** Recommendations */\n  recommendations: string[];\n}\n\n/**\n * Design decision\n */\nexport interface DesignDecision {\n  /** Decision title */\n  title: string;\n  /** Decision category */\n  category: 'structure' | 'pattern' | 'technology' | 'integration' | 'security';\n  /** Decision description */\n  description: string;\n  /** Rationale */\n  rationale: string;\n  /** Pros */\n  pros: string[];\n  /** Cons */\n  cons: string[];\n  /** Alternatives considered */\n  alternatives?: string[];\n  /** Priority */\n  priority: 'low' | 'medium' | 'high';\n}\n\n/**\n * Architecture analysis result\n */\nexport interface ArchitectureAnalysis {\n  /** Project name */\n  projectName: string;\n  /** Detected patterns */\n  patterns: ArchitecturePattern[];\n  /** Architecture layers */\n  layers: ArchitectureLayer[];\n  /** Components */\n  components: ArchitectureComponent[];\n  /** Dependency analysis */\n  dependencies: DependencyAnalysis;\n  /** Design decisions/recommendations */\n  decisions: DesignDecision[];\n  /** Overall health score (0-100) */\n  healthScore: number;\n  /** Analysis timestamp */\n  timestamp: Date;\n}\n\n/**\n * Design suggestion\n */\nexport interface DesignSuggestion {\n  /** Suggestion type */\n  type: 'refactor' | 'extract' | 'merge' | 'introduce' | 'remove';\n  /** Target component/module */\n  target: string;\n  /** Description */\n  description: string;\n  /** Priority */\n  priority: 'low' | 'medium' | 'high';\n  /** Expected benefit */\n  benefit: string;\n  /** Effort estimate */\n  effort: 'low' | 'medium' | 'high';\n}\n\n/**\n * Architect task type\n */\nexport type ArchitectTaskType = 'analyze' | 'design' | 'dependencies' | 'suggest';\n\n// ============================================================================\n// Architect Agent\n// ============================================================================\n\n/**\n * Architect Agent\n *\n * Capabilities:\n * - Architecture analysis and pattern detection\n * - Design decision recommendations\n * - Dependency analysis and visualization\n * - Layer validation\n *\n * @example\n * ```typescript\n * const architect = new ArchitectAgent({\n *   name: 'architect-agent',\n *   type: AgentType.ARCHITECT,\n * });\n *\n * const result = await architect.execute({\n *   id: 'task-1',\n *   description: 'Analyze project architecture',\n *   priority: TaskPriority.MEDIUM,\n *   input: {\n *     data: {\n *       projectRoot: '/path/to/project'\n *     }\n *   },\n *   createdAt: new Date()\n * });\n * ```\n */\nexport class ArchitectAgent extends BaseAgent {\n  /** File patterns to analyze */\n  private readonly codePatterns = ['.ts', '.tsx', '.js', '.jsx', '.mts', '.mjs'];\n\n  /** Knowledge graph reference */\n  private knowledgeGraph: KnowledgeGraphManager | null = null;\n\n  /** Layer definitions for common architectures */\n  private readonly layerDefinitions: Record<string, string[]> = {\n    presentation: ['components', 'views', 'pages', 'ui'],\n    application: ['services', 'usecases', 'handlers', 'controllers'],\n    domain: ['models', 'entities', 'domain', 'core'],\n    infrastructure: ['repositories', 'adapters', 'database', 'api'],\n    shared: ['utils', 'helpers', 'common', 'shared', 'lib'],\n  };\n\n  constructor(config: Partial<ArchitectAgentConfig> & { name: string }) {\n    super({\n      type: AgentType.ARCHITECT,\n      taskTimeout: 300000, // 5 minutes for large projects\n      capabilities: ['architecture-analysis', 'design', 'dependency-analysis'],\n      ...config,\n    });\n  }\n\n  // ==========================================================================\n  // Knowledge Graph Integration\n  // ==========================================================================\n\n  /**\n   * Set knowledge graph for context-aware analysis\n   */\n  setKnowledgeGraph(graph: KnowledgeGraphManager): void {\n    this.knowledgeGraph = graph;\n    this.logger.debug('Knowledge graph attached', {\n      nodeCount: graph.getMetadata().nodeCount,\n    });\n  }\n\n  // ==========================================================================\n  // Task Execution\n  // ==========================================================================\n\n  /**\n   * Execute architect task\n   */\n  protected async executeTask(task: AgentTask): Promise<AgentResult> {\n    const startTime = new Date();\n    const taskType = (task.input?.parameters?.taskType as ArchitectTaskType) || 'analyze';\n\n    switch (taskType) {\n      case 'analyze':\n        return this.handleAnalyzeTask(task, startTime);\n      case 'design':\n        return this.handleDesignTask(task, startTime);\n      case 'dependencies':\n        return this.handleDependenciesTask(task, startTime);\n      case 'suggest':\n        return this.handleSuggestTask(task, startTime);\n      default:\n        return this.createErrorResult(\n          'INVALID_TASK_TYPE',\n          `Unknown task type: ${taskType}`,\n          startTime\n        );\n    }\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Analyze project architecture\n   */\n  async analyzeArchitecture(projectRoot: string): Promise<ArchitectureAnalysis> {\n    this.logger.info('Analyzing architecture', { root: projectRoot });\n\n    // Discover components\n    const components = await this.discoverComponents(projectRoot);\n\n    // Detect patterns\n    const patterns = this.detectPatterns(components, projectRoot);\n\n    // Identify layers\n    const layers = this.identifyLayers(components);\n\n    // Analyze dependencies\n    const dependencies = this.analyzeDependencies(components);\n\n    // Generate design decisions\n    const decisions = this.generateDesignDecisions(components, layers, dependencies);\n\n    // Calculate health score\n    const healthScore = this.calculateHealthScore(components, layers, dependencies);\n\n    return {\n      projectName: path.basename(projectRoot),\n      patterns,\n      layers,\n      components,\n      dependencies,\n      decisions,\n      healthScore,\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Suggest design improvements\n   */\n  async suggestDesign(projectRoot: string): Promise<DesignSuggestion[]> {\n    this.logger.info('Generating design suggestions', { root: projectRoot });\n\n    const analysis = await this.analyzeArchitecture(projectRoot);\n    const suggestions: DesignSuggestion[] = [];\n\n    // Check for circular dependencies\n    for (const cycle of analysis.dependencies.cycles) {\n      suggestions.push({\n        type: 'refactor',\n        target: cycle.join(' -> '),\n        description: 'Break circular dependency',\n        priority: 'high',\n        benefit: 'Improves testability and maintainability',\n        effort: 'medium',\n      });\n    }\n\n    // Check for hub components (too many dependencies)\n    for (const hub of analysis.dependencies.hubs) {\n      if (hub.connections > 10) {\n        suggestions.push({\n          type: 'extract',\n          target: hub.module,\n          description: `Split ${hub.module} - too many connections (${hub.connections})`,\n          priority: hub.connections > 20 ? 'high' : 'medium',\n          benefit: 'Reduces coupling and improves modularity',\n          effort: 'high',\n        });\n      }\n    }\n\n    // Check for layer violations\n    for (const layer of analysis.layers) {\n      if (layer.violations.length > 0) {\n        suggestions.push({\n          type: 'refactor',\n          target: layer.name,\n          description: `Fix ${layer.violations.length} layer violation(s) in ${layer.name}`,\n          priority: 'high',\n          benefit: 'Enforces clean architecture boundaries',\n          effort: 'medium',\n        });\n      }\n    }\n\n    // Check for orphan components\n    for (const orphan of analysis.dependencies.orphans) {\n      suggestions.push({\n        type: 'remove',\n        target: orphan,\n        description: `Consider removing unused module: ${orphan}`,\n        priority: 'low',\n        benefit: 'Reduces codebase size and maintenance burden',\n        effort: 'low',\n      });\n    }\n\n    // Check component complexity\n    for (const component of analysis.components) {\n      if (component.complexity > 30) {\n        suggestions.push({\n          type: 'extract',\n          target: component.name,\n          description: `Reduce complexity of ${component.name} (${component.complexity})`,\n          priority: component.complexity > 50 ? 'high' : 'medium',\n          benefit: 'Improves readability and testability',\n          effort: 'medium',\n        });\n      }\n    }\n\n    return suggestions.sort((a, b) => {\n      const priorityOrder = { high: 0, medium: 1, low: 2 };\n      return priorityOrder[a.priority] - priorityOrder[b.priority];\n    });\n  }\n\n  /**\n   * Map dependencies between modules\n   */\n  async mapDependencies(projectRoot: string): Promise<DependencyAnalysis> {\n    this.logger.info('Mapping dependencies', { root: projectRoot });\n\n    const components = await this.discoverComponents(projectRoot);\n    return this.analyzeDependencies(components);\n  }\n\n  // ==========================================================================\n  // Private Task Handlers\n  // ==========================================================================\n\n  private async handleAnalyzeTask(\n    task: AgentTask,\n    startTime: Date\n  ): Promise<AgentResult<ArchitectureAnalysis>> {\n    const input = task.input?.data as { projectRoot: string } | undefined;\n\n    if (!input?.projectRoot) {\n      return this.createErrorResult(\n        'VALIDATION_ERROR',\n        'Project root is required for architecture analysis',\n        startTime\n      ) as AgentResult<ArchitectureAnalysis>;\n    }\n\n    try {\n      const analysis = await this.analyzeArchitecture(input.projectRoot);\n      const artifacts: ResultArtifact[] = [{\n        type: 'report',\n        name: 'architecture-analysis',\n        content: JSON.stringify(analysis, null, 2),\n        mimeType: 'application/json',\n      }];\n\n      return this.createSuccessResult(analysis, startTime, artifacts);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return this.createErrorResult('ANALYSIS_ERROR', `Architecture analysis failed: ${message}`, startTime) as AgentResult<ArchitectureAnalysis>;\n    }\n  }\n\n  private async handleDesignTask(\n    task: AgentTask,\n    startTime: Date\n  ): Promise<AgentResult<DesignDecision[]>> {\n    const input = task.input?.data as { projectRoot: string } | undefined;\n\n    if (!input?.projectRoot) {\n      return this.createErrorResult(\n        'VALIDATION_ERROR',\n        'Project root is required for design analysis',\n        startTime\n      ) as AgentResult<DesignDecision[]>;\n    }\n\n    try {\n      const analysis = await this.analyzeArchitecture(input.projectRoot);\n      return this.createSuccessResult(analysis.decisions, startTime);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return this.createErrorResult('DESIGN_ERROR', `Design analysis failed: ${message}`, startTime) as AgentResult<DesignDecision[]>;\n    }\n  }\n\n  private async handleDependenciesTask(\n    task: AgentTask,\n    startTime: Date\n  ): Promise<AgentResult<DependencyAnalysis>> {\n    const input = task.input?.data as { projectRoot: string } | undefined;\n\n    if (!input?.projectRoot) {\n      return this.createErrorResult(\n        'VALIDATION_ERROR',\n        'Project root is required for dependency analysis',\n        startTime\n      ) as AgentResult<DependencyAnalysis>;\n    }\n\n    try {\n      const analysis = await this.mapDependencies(input.projectRoot);\n      return this.createSuccessResult(analysis, startTime);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return this.createErrorResult('DEPENDENCY_ERROR', `Dependency analysis failed: ${message}`, startTime) as AgentResult<DependencyAnalysis>;\n    }\n  }\n\n  private async handleSuggestTask(\n    task: AgentTask,\n    startTime: Date\n  ): Promise<AgentResult<DesignSuggestion[]>> {\n    const input = task.input?.data as { projectRoot: string } | undefined;\n\n    if (!input?.projectRoot) {\n      return this.createErrorResult(\n        'VALIDATION_ERROR',\n        'Project root is required for design suggestions',\n        startTime\n      ) as AgentResult<DesignSuggestion[]>;\n    }\n\n    try {\n      const suggestions = await this.suggestDesign(input.projectRoot);\n      return this.createSuccessResult(suggestions, startTime);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return this.createErrorResult('SUGGEST_ERROR', `Design suggestion failed: ${message}`, startTime) as AgentResult<DesignSuggestion[]>;\n    }\n  }\n\n  // ==========================================================================\n  // Component Discovery\n  // ==========================================================================\n\n  private async discoverComponents(projectRoot: string): Promise<ArchitectureComponent[]> {\n    const components: ArchitectureComponent[] = [];\n    const files = await this.findFiles(projectRoot);\n\n    for (const file of files) {\n      try {\n        const content = await fs.readFile(file, 'utf-8');\n        const relativePath = path.relative(projectRoot, file);\n        const component = this.analyzeComponent(content, relativePath);\n        components.push(component);\n      } catch (error) {\n        this.logger.warn(`Failed to analyze ${file}`, { error });\n      }\n    }\n\n    // Resolve dependencies to component names\n    this.resolveDependencies(components);\n\n    return components;\n  }\n\n  private analyzeComponent(content: string, filePath: string): ArchitectureComponent {\n    const name = path.basename(filePath, path.extname(filePath));\n    const type = this.inferComponentType(filePath, content);\n    const dependencies = this.extractDependencies(content);\n    const exports = this.extractExports(content);\n    const linesOfCode = content.split('\\n').filter(l => l.trim().length > 0).length;\n    const complexity = this.calculateComplexity(content);\n\n    return {\n      name,\n      type,\n      path: filePath,\n      dependencies,\n      dependents: [], // Filled later\n      exports,\n      linesOfCode,\n      complexity,\n    };\n  }\n\n  private inferComponentType(filePath: string, content: string): ComponentType {\n    const lowerPath = filePath.toLowerCase();\n    const lowerContent = content.toLowerCase();\n\n    if (lowerPath.includes('service') || lowerPath.includes('services')) return 'service';\n    if (lowerPath.includes('controller') || lowerPath.includes('controllers')) return 'controller';\n    if (lowerPath.includes('repository') || lowerPath.includes('repositories')) return 'repository';\n    if (lowerPath.includes('model') || lowerPath.includes('models')) return 'model';\n    if (lowerPath.includes('view') || lowerPath.includes('component')) return 'view';\n    if (lowerPath.includes('util') || lowerPath.includes('helper')) return 'utility';\n    if (lowerPath.includes('middleware')) return 'middleware';\n    if (lowerPath.includes('handler')) return 'handler';\n    if (lowerPath.includes('factory')) return 'factory';\n    if (lowerPath.includes('adapter')) return 'adapter';\n\n    // Infer from content\n    if (lowerContent.includes('class') && lowerContent.includes('service')) return 'service';\n    if (lowerContent.includes('@controller') || lowerContent.includes('router')) return 'controller';\n    if (lowerContent.includes('repository') || lowerContent.includes('findby')) return 'repository';\n    if (lowerContent.includes('interface') && lowerContent.includes('model')) return 'model';\n\n    return 'utility';\n  }\n\n  private resolveDependencies(components: ArchitectureComponent[]): void {\n    const componentMap = new Map(components.map(c => [c.path, c]));\n    const nameMap = new Map(components.map(c => [c.name, c]));\n\n    for (const component of components) {\n      for (const dep of component.dependencies) {\n        // Try to find the dependency by path or name\n        const depPath = this.resolveDependencyPath(component.path, dep);\n        const depComponent = componentMap.get(depPath) || nameMap.get(dep);\n\n        if (depComponent && depComponent !== component) {\n          // Add to dependents list\n          if (!depComponent.dependents.includes(component.name)) {\n            depComponent.dependents.push(component.name);\n          }\n        }\n      }\n    }\n  }\n\n  private resolveDependencyPath(fromPath: string, dep: string): string {\n    if (dep.startsWith('.')) {\n      const dir = path.dirname(fromPath);\n      const resolved = path.normalize(path.join(dir, dep));\n      // Add extension if missing\n      for (const ext of this.codePatterns) {\n        if (resolved.endsWith(ext)) return resolved;\n      }\n      return resolved + '.ts';\n    }\n    return dep;\n  }\n\n  // ==========================================================================\n  // Pattern Detection\n  // ==========================================================================\n\n  private detectPatterns(\n    components: ArchitectureComponent[],\n    projectRoot: string\n  ): ArchitecturePattern[] {\n    const patterns: ArchitecturePattern[] = [];\n\n    // Check for MVC\n    const hasControllers = components.some(c => c.type === 'controller');\n    const hasModels = components.some(c => c.type === 'model');\n    const hasViews = components.some(c => c.type === 'view');\n\n    if (hasControllers && hasModels && hasViews) {\n      patterns.push('mvc');\n    }\n\n    // Check for layered architecture\n    const layers = this.identifyLayers(components);\n    if (layers.length >= 3) {\n      patterns.push('layered');\n    }\n\n    // Check for clean/hexagonal architecture\n    const hasAdapters = components.some(c => c.type === 'adapter');\n    const hasRepositories = components.some(c => c.type === 'repository');\n    if (hasAdapters && hasRepositories && layers.length >= 3) {\n      patterns.push('clean-architecture');\n    }\n\n    // Check for modular architecture\n    const directories = new Set(components.map(c => path.dirname(c.path)));\n    if (directories.size > 5) {\n      patterns.push('modular');\n    }\n\n    // Check for event-driven patterns\n    const hasEvents = components.some(c =>\n      c.exports.some(e => e.toLowerCase().includes('event') || e.toLowerCase().includes('emit'))\n    );\n    if (hasEvents) {\n      patterns.push('event-driven');\n    }\n\n    return patterns.length > 0 ? patterns : ['monolith'];\n  }\n\n  // ==========================================================================\n  // Layer Analysis\n  // ==========================================================================\n\n  private identifyLayers(components: ArchitectureComponent[]): ArchitectureLayer[] {\n    const layers: ArchitectureLayer[] = [];\n    const layerComponents: Record<string, string[]> = {};\n\n    // Categorize components into layers\n    for (const component of components) {\n      const layer = this.inferLayer(component.path);\n      if (!layerComponents[layer]) {\n        layerComponents[layer] = [];\n      }\n      layerComponents[layer].push(component.name);\n    }\n\n    // Create layer objects\n    const layerOrder = ['presentation', 'application', 'domain', 'infrastructure', 'shared'];\n\n    for (let i = 0; i < layerOrder.length; i++) {\n      const layerName = layerOrder[i];\n      if (layerComponents[layerName] && layerComponents[layerName].length > 0) {\n        const allowedDeps = layerOrder.slice(i + 1);\n        const actualDeps = this.findLayerDependencies(\n          components,\n          layerComponents[layerName],\n          layerComponents\n        );\n        const violations = actualDeps.filter(\n          d => !allowedDeps.includes(d) && d !== layerName\n        );\n\n        layers.push({\n          name: layerName,\n          level: i,\n          components: layerComponents[layerName],\n          allowedDependencies: allowedDeps,\n          actualDependencies: actualDeps,\n          violations,\n        });\n      }\n    }\n\n    return layers;\n  }\n\n  private inferLayer(filePath: string): string {\n    const lowerPath = filePath.toLowerCase();\n\n    for (const [layer, patterns] of Object.entries(this.layerDefinitions)) {\n      for (const pattern of patterns) {\n        if (lowerPath.includes(pattern)) {\n          return layer;\n        }\n      }\n    }\n\n    return 'shared';\n  }\n\n  private findLayerDependencies(\n    components: ArchitectureComponent[],\n    layerComponentNames: string[],\n    allLayerComponents: Record<string, string[]>\n  ): string[] {\n    const dependencies = new Set<string>();\n\n    for (const componentName of layerComponentNames) {\n      const component = components.find(c => c.name === componentName);\n      if (!component) continue;\n\n      for (const dep of component.dependencies) {\n        // Find which layer this dependency belongs to\n        for (const [layer, componentNames] of Object.entries(allLayerComponents)) {\n          if (componentNames.includes(dep)) {\n            dependencies.add(layer);\n          }\n        }\n      }\n    }\n\n    return [...dependencies];\n  }\n\n  // ==========================================================================\n  // Dependency Analysis\n  // ==========================================================================\n\n  private analyzeDependencies(components: ArchitectureComponent[]): DependencyAnalysis {\n    const graph = this.buildDependencyGraph(components);\n    const cycles = this.findCycles(components);\n    const orphans = this.findOrphans(components);\n    const hubs = this.findHubs(components);\n    const recommendations = this.generateDependencyRecommendations(cycles, orphans, hubs);\n\n    return {\n      graph,\n      cycles,\n      orphans,\n      hubs,\n      recommendations,\n    };\n  }\n\n  private buildDependencyGraph(components: ArchitectureComponent[]): DependencyNode[] {\n    return components.map(c => {\n      const fanIn = c.dependents.length;\n      const fanOut = c.dependencies.length;\n      const instability = fanOut / (fanIn + fanOut) || 0;\n\n      return {\n        id: c.name,\n        label: c.name,\n        type: c.type,\n        outgoing: c.dependencies,\n        incoming: c.dependents,\n        metrics: {\n          fanIn,\n          fanOut,\n          instability: Math.round(instability * 100) / 100,\n          abstractness: 0, // Would require interface detection\n        },\n      };\n    });\n  }\n\n  private findCycles(components: ArchitectureComponent[]): string[][] {\n    const cycles: string[][] = [];\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n    const path: string[] = [];\n\n    const dfs = (componentName: string): void => {\n      visited.add(componentName);\n      recursionStack.add(componentName);\n      path.push(componentName);\n\n      const component = components.find(c => c.name === componentName);\n      if (component) {\n        for (const dep of component.dependencies) {\n          const depComponent = components.find(c => c.name === dep);\n          if (!depComponent) continue;\n\n          if (!visited.has(dep)) {\n            dfs(dep);\n          } else if (recursionStack.has(dep)) {\n            // Found a cycle\n            const cycleStart = path.indexOf(dep);\n            if (cycleStart !== -1) {\n              cycles.push([...path.slice(cycleStart), dep]);\n            }\n          }\n        }\n      }\n\n      path.pop();\n      recursionStack.delete(componentName);\n    };\n\n    for (const component of components) {\n      if (!visited.has(component.name)) {\n        dfs(component.name);\n      }\n    }\n\n    return cycles;\n  }\n\n  private findOrphans(components: ArchitectureComponent[]): string[] {\n    return components\n      .filter(c => c.dependencies.length === 0 && c.dependents.length === 0)\n      .map(c => c.name);\n  }\n\n  private findHubs(components: ArchitectureComponent[]): Array<{ module: string; connections: number }> {\n    return components\n      .map(c => ({\n        module: c.name,\n        connections: c.dependencies.length + c.dependents.length,\n      }))\n      .filter(h => h.connections > 5)\n      .sort((a, b) => b.connections - a.connections);\n  }\n\n  private generateDependencyRecommendations(\n    cycles: string[][],\n    orphans: string[],\n    hubs: Array<{ module: string; connections: number }>\n  ): string[] {\n    const recommendations: string[] = [];\n\n    if (cycles.length > 0) {\n      recommendations.push(\n        `Found ${cycles.length} circular dependency(s) - consider using dependency inversion`\n      );\n    }\n\n    if (orphans.length > 0) {\n      recommendations.push(\n        `${orphans.length} orphan module(s) detected - consider removing or integrating`\n      );\n    }\n\n    const majorHubs = hubs.filter(h => h.connections > 10);\n    if (majorHubs.length > 0) {\n      recommendations.push(\n        `${majorHubs.length} highly-connected module(s) - consider splitting into smaller modules`\n      );\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('Dependency structure looks healthy');\n    }\n\n    return recommendations;\n  }\n\n  // ==========================================================================\n  // Design Decisions\n  // ==========================================================================\n\n  private generateDesignDecisions(\n    components: ArchitectureComponent[],\n    layers: ArchitectureLayer[],\n    dependencies: DependencyAnalysis\n  ): DesignDecision[] {\n    const decisions: DesignDecision[] = [];\n\n    // Check layer violations\n    const violatingLayers = layers.filter(l => l.violations.length > 0);\n    if (violatingLayers.length > 0) {\n      decisions.push({\n        title: 'Enforce Layer Boundaries',\n        category: 'structure',\n        description: 'Some layers have dependencies that violate the intended architecture',\n        rationale: 'Clean separation of concerns improves maintainability and testability',\n        pros: ['Better modularity', 'Easier testing', 'Clearer responsibilities'],\n        cons: ['Initial refactoring effort', 'May require interface introduction'],\n        priority: 'high',\n      });\n    }\n\n    // Check for circular dependencies\n    if (dependencies.cycles.length > 0) {\n      decisions.push({\n        title: 'Break Circular Dependencies',\n        category: 'structure',\n        description: `Found ${dependencies.cycles.length} circular dependency chain(s)`,\n        rationale: 'Circular dependencies make code harder to understand and test',\n        pros: ['Improved testability', 'Clearer module boundaries', 'Easier refactoring'],\n        cons: ['May require interface extraction', 'Some restructuring needed'],\n        alternatives: ['Dependency injection', 'Event-driven communication'],\n        priority: 'high',\n      });\n    }\n\n    // Check component complexity\n    const complexComponents = components.filter(c => c.complexity > 30);\n    if (complexComponents.length > 0) {\n      decisions.push({\n        title: 'Reduce Component Complexity',\n        category: 'pattern',\n        description: `${complexComponents.length} component(s) have high complexity`,\n        rationale: 'Lower complexity improves readability and reduces bug risk',\n        pros: ['Better maintainability', 'Easier testing', 'Reduced cognitive load'],\n        cons: ['May increase number of files', 'Refactoring effort'],\n        alternatives: ['Extract methods', 'Apply design patterns', 'Split responsibilities'],\n        priority: 'medium',\n      });\n    }\n\n    // Check for proper service layer\n    const services = components.filter(c => c.type === 'service');\n    if (services.length === 0 && components.length > 10) {\n      decisions.push({\n        title: 'Introduce Service Layer',\n        category: 'pattern',\n        description: 'Consider introducing a service layer for business logic',\n        rationale: 'Service layer provides clean separation between UI and business logic',\n        pros: ['Reusable business logic', 'Better testability', 'Cleaner controllers'],\n        cons: ['Additional abstraction layer', 'More files to manage'],\n        priority: 'medium',\n      });\n    }\n\n    return decisions;\n  }\n\n  // ==========================================================================\n  // Health Score\n  // ==========================================================================\n\n  private calculateHealthScore(\n    components: ArchitectureComponent[],\n    layers: ArchitectureLayer[],\n    dependencies: DependencyAnalysis\n  ): number {\n    let score = 100;\n\n    // Deduct for circular dependencies\n    score -= dependencies.cycles.length * 10;\n\n    // Deduct for layer violations\n    const totalViolations = layers.reduce((sum, l) => sum + l.violations.length, 0);\n    score -= totalViolations * 5;\n\n    // Deduct for high complexity\n    const complexComponents = components.filter(c => c.complexity > 30);\n    score -= complexComponents.length * 3;\n\n    // Deduct for too many orphans (might indicate dead code)\n    if (dependencies.orphans.length > 5) {\n      score -= (dependencies.orphans.length - 5) * 2;\n    }\n\n    // Deduct for hub components\n    const majorHubs = dependencies.hubs.filter(h => h.connections > 15);\n    score -= majorHubs.length * 5;\n\n    return Math.max(0, Math.min(100, Math.round(score)));\n  }\n\n  // ==========================================================================\n  // Helper Methods\n  // ==========================================================================\n\n  private extractDependencies(content: string): string[] {\n    const dependencies: string[] = [];\n\n    const importRegex = /import\\s+(?:.*?\\s+from\\s+)?['\"]([^'\"]+)['\"]/g;\n    let match;\n    while ((match = importRegex.exec(content)) !== null) {\n      const dep = match[1];\n      if (dep.startsWith('.')) {\n        // Extract just the module name\n        const name = path.basename(dep, path.extname(dep));\n        dependencies.push(name);\n      }\n    }\n\n    const requireRegex = /require\\s*\\(['\"]([^'\"]+)['\"]\\)/g;\n    while ((match = requireRegex.exec(content)) !== null) {\n      const dep = match[1];\n      if (dep.startsWith('.')) {\n        const name = path.basename(dep, path.extname(dep));\n        dependencies.push(name);\n      }\n    }\n\n    return [...new Set(dependencies)];\n  }\n\n  private extractExports(content: string): string[] {\n    const exports: string[] = [];\n\n    const namedExportRegex = /export\\s+(?:const|let|var|function|class)\\s+(\\w+)/g;\n    let match;\n    while ((match = namedExportRegex.exec(content)) !== null) {\n      exports.push(match[1]);\n    }\n\n    const exportDeclRegex = /export\\s*\\{([^}]+)\\}/g;\n    while ((match = exportDeclRegex.exec(content)) !== null) {\n      const names = match[1].split(',').map(n => n.trim().split(/\\s+as\\s+/)[0]);\n      exports.push(...names);\n    }\n\n    return [...new Set(exports.filter(e => e))];\n  }\n\n  private calculateComplexity(content: string): number {\n    let complexity = 1;\n\n    const patterns = [\n      /\\bif\\s*\\(/g,\n      /\\belse\\s+if\\s*\\(/g,\n      /\\bfor\\s*\\(/g,\n      /\\bwhile\\s*\\(/g,\n      /\\bcase\\s+/g,\n      /\\bcatch\\s*\\(/g,\n      /\\?\\s*[^:]+\\s*:/g,\n      /&&/g,\n      /\\|\\|/g,\n    ];\n\n    for (const pattern of patterns) {\n      const matches = content.match(pattern);\n      if (matches) {\n        complexity += matches.length;\n      }\n    }\n\n    return complexity;\n  }\n\n  private async findFiles(dir: string): Promise<string[]> {\n    const files: string[] = [];\n\n    try {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n\n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n\n        if (\n          entry.name === 'node_modules' ||\n          entry.name === '.git' ||\n          entry.name === 'dist' ||\n          entry.name === 'build' ||\n          entry.name.startsWith('.')\n        ) {\n          continue;\n        }\n\n        if (entry.isDirectory()) {\n          const subFiles = await this.findFiles(fullPath);\n          files.push(...subFiles);\n        } else if (entry.isFile()) {\n          const ext = path.extname(entry.name);\n          if (this.codePatterns.includes(ext)) {\n            files.push(fullPath);\n          }\n        }\n      }\n    } catch {\n      // Directory doesn't exist or can't be read\n    }\n\n    return files;\n  }\n}\n\n"],"names":["exports","path"],"mappings":"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"}