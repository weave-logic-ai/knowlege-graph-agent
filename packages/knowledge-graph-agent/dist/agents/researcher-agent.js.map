{"version":3,"file":"researcher-agent.js","sources":["../../src/agents/researcher-agent.ts"],"sourcesContent":["/**\n * Researcher Agent\n *\n * Specialized agent for codebase research, pattern analysis, and documentation research.\n * Extends BaseAgent with research-specific capabilities and knowledge graph integration.\n *\n * @module agents/researcher-agent\n */\n\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseAgent } from './base-agent.js';\nimport {\n  AgentType,\n  TaskPriority,\n  type AgentTask,\n  type AgentResult,\n  type ResearcherAgentConfig,\n  type ResultArtifact,\n} from './types.js';\nimport { KnowledgeGraphManager } from '../core/graph.js';\nimport type { KnowledgeNode } from '../core/types.js';\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Research query type\n */\nexport type ResearchQueryType =\n  | 'codebase'\n  | 'pattern'\n  | 'documentation'\n  | 'reference'\n  | 'general';\n\n/**\n * Research query input\n */\nexport interface ResearchQuery {\n  /** Query string */\n  query: string;\n  /** Type of research */\n  type: ResearchQueryType;\n  /** Scope of research (file paths, directories, or patterns) */\n  scope?: string[];\n  /** Include code snippets in results */\n  includeCode?: boolean;\n  /** Maximum results to return */\n  maxResults?: number;\n}\n\n/**\n * Code reference found during research\n */\nexport interface CodeReference {\n  /** File path */\n  file: string;\n  /** Line number */\n  line: number;\n  /** Code snippet */\n  code: string;\n  /** Context around the reference */\n  context?: string;\n  /** Relevance score (0-1) */\n  relevance: number;\n}\n\n/**\n * Detected pattern\n */\nexport interface DetectedPattern {\n  /** Pattern name */\n  name: string;\n  /** Pattern category */\n  category: string;\n  /** Description of the pattern */\n  description: string;\n  /** Files where pattern is found */\n  locations: string[];\n  /** Frequency/occurrence count */\n  frequency: number;\n  /** Whether this is a recommended pattern */\n  recommended: boolean;\n  /** Related patterns */\n  relatedPatterns?: string[];\n}\n\n/**\n * Research finding\n */\nexport interface ResearchFinding {\n  /** Finding title */\n  title: string;\n  /** Finding description */\n  description: string;\n  /** Relevance score (0-1) */\n  relevance: number;\n  /** Source of the finding */\n  source: 'code' | 'documentation' | 'knowledge-graph';\n  /** Related code references */\n  references?: CodeReference[];\n  /** Related patterns */\n  patterns?: DetectedPattern[];\n  /** Related knowledge nodes */\n  relatedNodes?: string[];\n}\n\n/**\n * Research result data\n */\nexport interface ResearchResultData {\n  /** Query that was executed */\n  query: ResearchQuery;\n  /** Findings from the research */\n  findings: ResearchFinding[];\n  /** Summary of findings */\n  summary: string;\n  /** Total files analyzed */\n  filesAnalyzed: number;\n  /** Patterns detected */\n  patterns: DetectedPattern[];\n  /** Recommendations */\n  recommendations: string[];\n}\n\n// ============================================================================\n// Researcher Agent\n// ============================================================================\n\n/**\n * Researcher Agent\n *\n * Capabilities:\n * - Codebase research and exploration\n * - Pattern detection and analysis\n * - Documentation research\n * - Reference finding across the codebase\n *\n * @example\n * ```typescript\n * const researcher = new ResearcherAgent({\n *   name: 'research-agent',\n *   type: AgentType.RESEARCHER,\n * });\n *\n * const result = await researcher.execute({\n *   id: 'task-1',\n *   description: 'Research authentication patterns',\n *   priority: TaskPriority.MEDIUM,\n *   input: {\n *     data: {\n *       query: 'authentication',\n *       type: 'pattern',\n *       scope: ['src/auth']\n *     }\n *   },\n *   createdAt: new Date()\n * });\n * ```\n */\nexport class ResearcherAgent extends BaseAgent {\n  /** File type patterns for analysis */\n  private readonly codePatterns = [\n    '**/*.ts',\n    '**/*.tsx',\n    '**/*.js',\n    '**/*.jsx',\n    '**/*.mts',\n    '**/*.mjs',\n  ];\n\n  /** Documentation patterns */\n  private readonly docPatterns = ['**/*.md', '**/*.mdx', '**/*.txt'];\n\n  /** Knowledge graph reference */\n  private knowledgeGraph: KnowledgeGraphManager | null = null;\n\n  constructor(config: Partial<ResearcherAgentConfig> & { name: string }) {\n    super({\n      type: AgentType.RESEARCHER,\n      taskTimeout: 120000, // 2 minutes\n      capabilities: ['research', 'pattern-analysis', 'documentation'],\n      ...config,\n    });\n  }\n\n  // ==========================================================================\n  // Knowledge Graph Integration\n  // ==========================================================================\n\n  /**\n   * Set knowledge graph for context-aware research\n   */\n  setKnowledgeGraph(graph: KnowledgeGraphManager): void {\n    this.knowledgeGraph = graph;\n    this.logger.debug('Knowledge graph attached', {\n      nodeCount: graph.getMetadata().nodeCount,\n    });\n  }\n\n  // ==========================================================================\n  // Task Execution\n  // ==========================================================================\n\n  /**\n   * Execute research task\n   */\n  protected async executeTask(task: AgentTask): Promise<AgentResult<ResearchResultData>> {\n    const startTime = new Date();\n    const input = task.input?.data as ResearchQuery | undefined;\n\n    if (!input?.query) {\n      return this.createErrorResult(\n        'VALIDATION_ERROR',\n        'Research query is required in task input.data',\n        startTime\n      ) as AgentResult<ResearchResultData>;\n    }\n\n    try {\n      const projectRoot = (task.input?.context?.projectRoot as string) || process.cwd();\n      const result = await this.research(input, projectRoot);\n\n      const artifacts: ResultArtifact[] = [{\n        type: 'report',\n        name: 'research-findings',\n        content: JSON.stringify(result, null, 2),\n        mimeType: 'application/json',\n      }];\n\n      return this.createSuccessResult(result, startTime, artifacts);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return this.createErrorResult('RESEARCH_ERROR', `Research failed: ${message}`, startTime) as AgentResult<ResearchResultData>;\n    }\n  }\n\n  // ==========================================================================\n  // Public Research Methods\n  // ==========================================================================\n\n  /**\n   * Perform research based on query\n   */\n  async research(query: ResearchQuery, projectRoot: string): Promise<ResearchResultData> {\n    this.logger.info('Starting research', { query: query.query, type: query.type });\n\n    const findings: ResearchFinding[] = [];\n    const patterns: DetectedPattern[] = [];\n    let filesAnalyzed = 0;\n\n    // Research from knowledge graph\n    const kgFindings = await this.researchKnowledgeGraph(query);\n    findings.push(...kgFindings);\n\n    // Research from codebase\n    const codeFindings = await this.researchCodebase(query, projectRoot);\n    findings.push(...codeFindings.findings);\n    patterns.push(...codeFindings.patterns);\n    filesAnalyzed = codeFindings.filesAnalyzed;\n\n    // Research documentation\n    if (query.type === 'documentation' || query.type === 'general') {\n      const docFindings = await this.researchDocumentation(query, projectRoot);\n      findings.push(...docFindings);\n    }\n\n    // Analyze patterns\n    if (query.type === 'pattern' || query.type === 'general') {\n      const detectedPatterns = await this.analyzePatterns(query.query, projectRoot);\n      patterns.push(...detectedPatterns);\n    }\n\n    // Sort findings by relevance\n    findings.sort((a, b) => b.relevance - a.relevance);\n\n    // Generate summary and recommendations\n    const summary = this.generateSummary(query, findings, patterns);\n    const recommendations = this.generateRecommendations(findings, patterns);\n\n    return {\n      query,\n      findings: findings.slice(0, query.maxResults || 20),\n      summary,\n      filesAnalyzed,\n      patterns,\n      recommendations,\n    };\n  }\n\n  /**\n   * Analyze patterns in the codebase\n   */\n  async analyzePatterns(query: string, projectRoot: string): Promise<DetectedPattern[]> {\n    this.logger.debug('Analyzing patterns', { query });\n\n    const patterns: DetectedPattern[] = [];\n\n    // Get patterns from knowledge graph\n    if (this.knowledgeGraph) {\n      const nodes = this.getRelevantNodes(query, 20);\n      const patternNodes = nodes.filter(n =>\n        n.type === 'technical' || n.tags.some(t => t.includes('pattern'))\n      );\n\n      for (const node of patternNodes) {\n        patterns.push({\n          name: node.title,\n          category: node.type,\n          description: (node.frontmatter.description as string) || `Pattern from ${node.path}`,\n          locations: [node.path],\n          frequency: 1,\n          recommended: node.status === 'active',\n          relatedPatterns: node.frontmatter.related as string[] | undefined,\n        });\n      }\n    }\n\n    // Detect common patterns from codebase\n    const detectedPatterns = await this.detectCodePatterns(projectRoot, query);\n    patterns.push(...detectedPatterns);\n\n    return patterns;\n  }\n\n  /**\n   * Find references across the codebase\n   */\n  async findReferences(\n    searchTerm: string,\n    projectRoot: string,\n    options?: { maxResults?: number; filePatterns?: string[] }\n  ): Promise<CodeReference[]> {\n    this.logger.debug('Finding references', { searchTerm, projectRoot });\n\n    const references: CodeReference[] = [];\n    const filePatterns = options?.filePatterns || this.codePatterns;\n    const maxResults = options?.maxResults || 50;\n\n    try {\n      const files = await this.findFiles(projectRoot, filePatterns);\n\n      for (const file of files) {\n        if (references.length >= maxResults) break;\n\n        try {\n          const content = await fs.readFile(file, 'utf-8');\n          const lines = content.split('\\n');\n\n          for (let i = 0; i < lines.length; i++) {\n            if (lines[i].toLowerCase().includes(searchTerm.toLowerCase())) {\n              references.push({\n                file: path.relative(projectRoot, file),\n                line: i + 1,\n                code: lines[i].trim(),\n                context: this.getContext(lines, i),\n                relevance: this.calculateRelevance(lines[i], searchTerm),\n              });\n            }\n          }\n        } catch {\n          // Skip files that can't be read\n        }\n      }\n    } catch (error) {\n      this.logger.warn('Error finding references', { error });\n    }\n\n    return references.sort((a, b) => b.relevance - a.relevance).slice(0, maxResults);\n  }\n\n  /**\n   * Summarize research findings\n   */\n  summarizeFindings(findings: ResearchFinding[]): string {\n    if (findings.length === 0) {\n      return 'No relevant findings were discovered.';\n    }\n\n    const bySource = {\n      code: findings.filter(f => f.source === 'code'),\n      documentation: findings.filter(f => f.source === 'documentation'),\n      'knowledge-graph': findings.filter(f => f.source === 'knowledge-graph'),\n    };\n\n    const parts: string[] = [\n      `Found ${findings.length} relevant findings:`,\n    ];\n\n    if (bySource.code.length > 0) {\n      parts.push(`- ${bySource.code.length} from codebase analysis`);\n    }\n    if (bySource.documentation.length > 0) {\n      parts.push(`- ${bySource.documentation.length} from documentation`);\n    }\n    if (bySource['knowledge-graph'].length > 0) {\n      parts.push(`- ${bySource['knowledge-graph'].length} from knowledge graph`);\n    }\n\n    // Top findings\n    const topFindings = findings.slice(0, 3);\n    if (topFindings.length > 0) {\n      parts.push('\\nTop findings:');\n      for (const finding of topFindings) {\n        parts.push(`- ${finding.title}: ${finding.description.slice(0, 100)}...`);\n      }\n    }\n\n    return parts.join('\\n');\n  }\n\n  // ==========================================================================\n  // Private Research Methods\n  // ==========================================================================\n\n  /**\n   * Get relevant nodes from knowledge graph\n   */\n  private getRelevantNodes(query: string, limit = 10): KnowledgeNode[] {\n    if (!this.knowledgeGraph) {\n      return [];\n    }\n\n    const allNodes = this.knowledgeGraph.getAllNodes();\n    const queryLower = query.toLowerCase();\n    const queryTerms = queryLower.split(/\\s+/);\n\n    const scored = allNodes.map(node => {\n      let score = 0;\n      const titleLower = node.title.toLowerCase();\n      const contentLower = node.content.toLowerCase();\n\n      for (const term of queryTerms) {\n        if (titleLower.includes(term)) score += 10;\n        if (node.tags.some(t => t.toLowerCase().includes(term))) score += 5;\n        if (contentLower.includes(term)) score += 1;\n      }\n\n      return { node, score };\n    });\n\n    return scored\n      .filter(s => s.score > 0)\n      .sort((a, b) => b.score - a.score)\n      .slice(0, limit)\n      .map(s => s.node);\n  }\n\n  /**\n   * Research from knowledge graph\n   */\n  private async researchKnowledgeGraph(query: ResearchQuery): Promise<ResearchFinding[]> {\n    const findings: ResearchFinding[] = [];\n\n    if (!this.knowledgeGraph) {\n      return findings;\n    }\n\n    const nodes = this.getRelevantNodes(query.query, 15);\n\n    for (const node of nodes) {\n      findings.push({\n        title: node.title,\n        description: (node.frontmatter.description as string) || node.content.slice(0, 200),\n        relevance: this.calculateNodeRelevance(node, query.query),\n        source: 'knowledge-graph',\n        relatedNodes: this.knowledgeGraph.findRelated(node.id, 1).map(n => n.title),\n      });\n    }\n\n    return findings;\n  }\n\n  /**\n   * Research from codebase\n   */\n  private async researchCodebase(\n    query: ResearchQuery,\n    projectRoot: string\n  ): Promise<{ findings: ResearchFinding[]; patterns: DetectedPattern[]; filesAnalyzed: number }> {\n    const findings: ResearchFinding[] = [];\n    const patterns: DetectedPattern[] = [];\n    let filesAnalyzed = 0;\n\n    try {\n      const scope = query.scope?.length\n        ? query.scope.map(s => path.join(projectRoot, s))\n        : [projectRoot];\n\n      for (const scopePath of scope) {\n        const files = await this.findFiles(scopePath, this.codePatterns);\n        filesAnalyzed += files.length;\n\n        for (const file of files) {\n          try {\n            const content = await fs.readFile(file, 'utf-8');\n            const relativePath = path.relative(projectRoot, file);\n\n            if (content.toLowerCase().includes(query.query.toLowerCase())) {\n              const references = query.includeCode\n                ? await this.findReferences(query.query, projectRoot, {\n                    maxResults: 5,\n                    filePatterns: [relativePath],\n                  })\n                : [];\n\n              findings.push({\n                title: `Match in ${path.basename(file)}`,\n                description: `Found relevant content in ${relativePath}`,\n                relevance: this.calculateContentRelevance(content, query.query),\n                source: 'code',\n                references,\n              });\n            }\n          } catch {\n            // Skip files that can't be read\n          }\n        }\n      }\n    } catch (error) {\n      this.logger.warn('Error researching codebase', { error });\n    }\n\n    return { findings, patterns, filesAnalyzed };\n  }\n\n  /**\n   * Research from documentation\n   */\n  private async researchDocumentation(\n    query: ResearchQuery,\n    projectRoot: string\n  ): Promise<ResearchFinding[]> {\n    const findings: ResearchFinding[] = [];\n\n    try {\n      const files = await this.findFiles(projectRoot, this.docPatterns);\n\n      for (const file of files) {\n        try {\n          const content = await fs.readFile(file, 'utf-8');\n          const relativePath = path.relative(projectRoot, file);\n\n          if (content.toLowerCase().includes(query.query.toLowerCase())) {\n            findings.push({\n              title: this.extractDocTitle(content) || path.basename(file),\n              description: this.extractDocDescription(content, query.query),\n              relevance: this.calculateContentRelevance(content, query.query),\n              source: 'documentation',\n            });\n          }\n        } catch {\n          // Skip files that can't be read\n        }\n      }\n    } catch (error) {\n      this.logger.warn('Error researching documentation', { error });\n    }\n\n    return findings;\n  }\n\n  /**\n   * Detect code patterns\n   */\n  private async detectCodePatterns(\n    projectRoot: string,\n    query: string\n  ): Promise<DetectedPattern[]> {\n    const patterns: DetectedPattern[] = [];\n    const patternCounts: Record<string, { locations: string[]; description: string }> = {};\n\n    const patternDetectors: Array<{\n      name: string;\n      regex: RegExp;\n      category: string;\n      description: string;\n    }> = [\n      {\n        name: 'Singleton Pattern',\n        regex: /getInstance\\s*\\(\\)|private\\s+static\\s+instance/,\n        category: 'creational',\n        description: 'Singleton pattern for single instance management',\n      },\n      {\n        name: 'Factory Pattern',\n        regex: /create[A-Z]\\w+\\s*\\(|factory\\s*[=:]/i,\n        category: 'creational',\n        description: 'Factory pattern for object creation',\n      },\n      {\n        name: 'Observer Pattern',\n        regex: /subscribe\\s*\\(|addEventListener|on[A-Z]\\w+\\s*\\(/,\n        category: 'behavioral',\n        description: 'Observer pattern for event handling',\n      },\n      {\n        name: 'Async/Await Pattern',\n        regex: /async\\s+\\w+.*\\{[\\s\\S]*?await\\s+/,\n        category: 'async',\n        description: 'Modern async/await pattern',\n      },\n      {\n        name: 'Error Handling Pattern',\n        regex: /try\\s*\\{[\\s\\S]*?\\}\\s*catch/,\n        category: 'error-handling',\n        description: 'Try-catch error handling pattern',\n      },\n      {\n        name: 'Dependency Injection',\n        regex: /constructor\\s*\\([^)]*private\\s+readonly|@Inject|@Injectable/,\n        category: 'structural',\n        description: 'Dependency injection pattern',\n      },\n    ];\n\n    try {\n      const files = await this.findFiles(projectRoot, this.codePatterns);\n\n      for (const file of files) {\n        try {\n          const content = await fs.readFile(file, 'utf-8');\n          const relativePath = path.relative(projectRoot, file);\n\n          for (const detector of patternDetectors) {\n            if (detector.regex.test(content)) {\n              if (!patternCounts[detector.name]) {\n                patternCounts[detector.name] = {\n                  locations: [],\n                  description: detector.description,\n                };\n              }\n              patternCounts[detector.name].locations.push(relativePath);\n            }\n          }\n        } catch {\n          // Skip files that can't be read\n        }\n      }\n    } catch (error) {\n      this.logger.warn('Error detecting patterns', { error });\n    }\n\n    for (const [name, data] of Object.entries(patternCounts)) {\n      if (data.locations.length > 0) {\n        patterns.push({\n          name,\n          category: 'detected',\n          description: data.description,\n          locations: data.locations,\n          frequency: data.locations.length,\n          recommended: true,\n        });\n      }\n    }\n\n    return patterns.sort((a, b) => b.frequency - a.frequency);\n  }\n\n  // ==========================================================================\n  // Utility Methods\n  // ==========================================================================\n\n  /**\n   * Find files matching patterns\n   */\n  private async findFiles(dir: string, patterns: string[]): Promise<string[]> {\n    const files: string[] = [];\n\n    try {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n\n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n\n        if (\n          entry.name === 'node_modules' ||\n          entry.name === '.git' ||\n          entry.name === 'dist' ||\n          entry.name === 'build' ||\n          entry.name.startsWith('.')\n        ) {\n          continue;\n        }\n\n        if (entry.isDirectory()) {\n          const subFiles = await this.findFiles(fullPath, patterns);\n          files.push(...subFiles);\n        } else if (entry.isFile()) {\n          for (const pattern of patterns) {\n            const ext = pattern.replace('**/*', '');\n            if (entry.name.endsWith(ext)) {\n              files.push(fullPath);\n              break;\n            }\n          }\n        }\n      }\n    } catch {\n      // Directory doesn't exist or can't be read\n    }\n\n    return files;\n  }\n\n  /**\n   * Get context around a line\n   */\n  private getContext(lines: string[], lineIndex: number, range = 2): string {\n    const start = Math.max(0, lineIndex - range);\n    const end = Math.min(lines.length, lineIndex + range + 1);\n    return lines.slice(start, end).join('\\n');\n  }\n\n  /**\n   * Calculate relevance of a match\n   */\n  private calculateRelevance(line: string, searchTerm: string): number {\n    const lineLower = line.toLowerCase();\n    const termLower = searchTerm.toLowerCase();\n\n    let score = 0.5;\n\n    if (lineLower.includes(termLower)) {\n      score += 0.2;\n    }\n\n    if (new RegExp(`\\\\b${termLower}\\\\b`, 'i').test(line)) {\n      score += 0.2;\n    }\n\n    if (/^(export\\s+)?(function|class|const|let|var|interface|type)\\s+/.test(line)) {\n      score += 0.1;\n    }\n\n    return Math.min(1, score);\n  }\n\n  /**\n   * Calculate node relevance\n   */\n  private calculateNodeRelevance(node: KnowledgeNode, query: string): number {\n    const queryLower = query.toLowerCase();\n    const terms = queryLower.split(/\\s+/);\n\n    let score = 0.3;\n\n    for (const term of terms) {\n      if (node.title.toLowerCase().includes(term)) score += 0.2;\n      if (node.tags.some(t => t.toLowerCase().includes(term))) score += 0.15;\n      if (node.content.toLowerCase().includes(term)) score += 0.05;\n    }\n\n    return Math.min(1, score);\n  }\n\n  /**\n   * Calculate content relevance\n   */\n  private calculateContentRelevance(content: string, query: string): number {\n    const queryLower = query.toLowerCase();\n    const terms = queryLower.split(/\\s+/);\n\n    let score = 0.3;\n    let matchCount = 0;\n\n    for (const term of terms) {\n      const regex = new RegExp(term, 'gi');\n      const matches = content.match(regex);\n      if (matches) {\n        matchCount += matches.length;\n      }\n    }\n\n    const density = matchCount / (content.length / 1000);\n    score += Math.min(0.5, density * 0.1);\n\n    return Math.min(1, score);\n  }\n\n  /**\n   * Extract title from documentation\n   */\n  private extractDocTitle(content: string): string | null {\n    const headingMatch = content.match(/^#\\s+(.+)$/m);\n    if (headingMatch) {\n      return headingMatch[1].trim();\n    }\n\n    const frontmatterMatch = content.match(/^---[\\s\\S]*?title:\\s*(.+?)[\\s\\n]/m);\n    if (frontmatterMatch) {\n      return frontmatterMatch[1].replace(/['\"]/g, '').trim();\n    }\n\n    return null;\n  }\n\n  /**\n   * Extract description from documentation\n   */\n  private extractDocDescription(content: string, query: string): string {\n    const queryLower = query.toLowerCase();\n\n    const paragraphs = content.split(/\\n\\n+/);\n    for (const para of paragraphs) {\n      if (para.toLowerCase().includes(queryLower) && !para.startsWith('#')) {\n        return para.slice(0, 200).trim() + (para.length > 200 ? '...' : '');\n      }\n    }\n\n    for (const para of paragraphs) {\n      if (!para.startsWith('#') && para.length > 20) {\n        return para.slice(0, 200).trim() + (para.length > 200 ? '...' : '');\n      }\n    }\n\n    return 'Documentation content';\n  }\n\n  /**\n   * Generate summary from findings\n   */\n  private generateSummary(\n    query: ResearchQuery,\n    findings: ResearchFinding[],\n    patterns: DetectedPattern[]\n  ): string {\n    const parts: string[] = [\n      `Research on \"${query.query}\" (${query.type}):`,\n    ];\n\n    if (findings.length === 0 && patterns.length === 0) {\n      return `No relevant findings for \"${query.query}\".`;\n    }\n\n    parts.push(`Found ${findings.length} relevant findings and ${patterns.length} patterns.`);\n\n    if (findings.length > 0) {\n      const topFinding = findings[0];\n      parts.push(`Top finding: ${topFinding.title} (${Math.round(topFinding.relevance * 100)}% relevance)`);\n    }\n\n    if (patterns.length > 0) {\n      const topPattern = patterns[0];\n      parts.push(`Most common pattern: ${topPattern.name} (${topPattern.frequency} occurrences)`);\n    }\n\n    return parts.join('\\n');\n  }\n\n  /**\n   * Generate recommendations from research\n   */\n  private generateRecommendations(\n    findings: ResearchFinding[],\n    patterns: DetectedPattern[]\n  ): string[] {\n    const recommendations: string[] = [];\n\n    const patternsByCategory: Record<string, DetectedPattern[]> = {};\n    for (const pattern of patterns) {\n      if (!patternsByCategory[pattern.category]) {\n        patternsByCategory[pattern.category] = [];\n      }\n      patternsByCategory[pattern.category].push(pattern);\n    }\n\n    if (patternsByCategory['error-handling']?.length) {\n      recommendations.push('Good error handling patterns detected. Consider standardizing across the codebase.');\n    }\n\n    if (patternsByCategory['async']?.length) {\n      recommendations.push('Modern async/await patterns in use. Ensure consistent error handling in async code.');\n    }\n\n    if (!patternsByCategory['structural']?.length) {\n      recommendations.push('Consider implementing dependency injection for better testability.');\n    }\n\n    const docFindings = findings.filter(f => f.source === 'documentation');\n    if (docFindings.length < findings.length * 0.2) {\n      recommendations.push('Consider improving documentation coverage for this topic.');\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('Review findings and patterns to identify improvement opportunities.');\n    }\n\n    return recommendations;\n  }\n}\n\n"],"names":[],"mappings":"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"}