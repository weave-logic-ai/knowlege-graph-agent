{"version":3,"file":"audit-chain.js","sources":["../../../src/audit/services/audit-chain.ts"],"sourcesContent":["/**\n * Audit Chain Service\n *\n * Implements deterministic logging with:\n * - DAG (Directed Acyclic Graph) structure for event ordering\n * - Hybrid Logical Clocks (HLC) for distributed ordering\n * - BLAKE3 hashing for event IDs\n * - Ed25519 signatures for authenticity\n *\n * @module audit/services/audit-chain\n */\n\nimport type {\n  Blake3Hash,\n  Ed25519Signature,\n  Did,\n  HybridLogicalClock,\n  KnowledgeGraphEventPayload,\n  EventEnvelope,\n  LedgerEvent,\n  Checkpoint,\n  MerkleProof,\n  EventQueryOptions,\n  EventQueryResult,\n  ChainStats,\n  EventValidation,\n} from '../types.js';\nimport type { AuditChainConfig } from '../config.js';\nimport {\n  createAuditChainConfig,\n  validateAuditChainConfig,\n} from '../config.js';\nimport { createLogger } from '../../utils/index.js';\n\nconst logger = createLogger('audit-chain');\n\n/**\n * Simple BLAKE3-like hash (in production, use actual BLAKE3)\n * This is a placeholder - real implementation would use @noble/hashes or similar\n *\n * @param data - Data to hash\n * @returns 64-character hex hash string\n */\nfunction blake3Hash(data: string): Blake3Hash {\n  // Simplified hash for demo - use real BLAKE3 in production\n  let hash = 0;\n  for (let i = 0; i < data.length; i++) {\n    const char = data.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16).padStart(64, '0');\n}\n\n/**\n * Simple Ed25519-like signature (in production, use actual Ed25519)\n * This is a placeholder - real implementation would use @noble/ed25519\n *\n * @param data - Data to sign\n * @param _privateKey - Private key for signing\n * @returns 128-character hex signature string\n */\nfunction signData(data: string, _privateKey?: string): Ed25519Signature {\n  // Simplified signature for demo - use real Ed25519 in production\n  const hash = blake3Hash(data + (_privateKey || 'default-key'));\n  return hash + hash.split('').reverse().join('');\n}\n\n/**\n * Verify signature (simplified)\n *\n * @param _data - Original data\n * @param _signature - Signature to verify\n * @param _publicKey - Public key for verification\n * @returns Whether signature is valid\n */\nfunction verifySignature(\n  _data: string,\n  _signature: Ed25519Signature,\n  _publicKey?: string\n): boolean {\n  // In production, use actual Ed25519 verification\n  return true;\n}\n\n/**\n * Canonical CBOR-like serialization (simplified JSON for demo)\n *\n * @param obj - Object to serialize\n * @returns Canonical string representation\n */\nfunction canonicalSerialize(obj: unknown): string {\n  return JSON.stringify(obj, Object.keys(obj as object).sort());\n}\n\n/**\n * Audit Chain class\n *\n * Provides:\n * - Event creation and signing\n * - DAG-based event storage\n * - HLC-based ordering\n * - Checkpoint creation\n * - Event querying with Merkle proofs\n *\n * @example\n * ```typescript\n * const chain = createAuditChain({ agentDid: 'did:key:abc123' });\n *\n * // Append an event\n * const event = await chain.appendEvent({\n *   type: 'NodeCreated',\n *   nodeId: 'node-1',\n *   nodeType: 'Document',\n *   properties: { title: 'My Doc' }\n * });\n *\n * // Query events\n * const result = await chain.queryEvents({ type: 'NodeCreated', limit: 10 });\n * ```\n */\nexport class AuditChain {\n  private config: AuditChainConfig;\n  private events: Map<Blake3Hash, LedgerEvent> = new Map();\n  private tips: Set<Blake3Hash> = new Set(); // Current DAG tips\n  private hlc: HybridLogicalClock;\n  private checkpoints: Checkpoint[] = [];\n  private eventsSinceCheckpoint: number = 0;\n\n  /**\n   * Create a new AuditChain instance\n   *\n   * @param config - Partial configuration (merged with defaults)\n   */\n  constructor(config?: Partial<AuditChainConfig>) {\n    const baseConfig = createAuditChainConfig();\n    this.config = { ...baseConfig, ...config };\n\n    const validation = validateAuditChainConfig(this.config);\n    if (!validation.valid) {\n      logger.warn('Invalid configuration', { errors: validation.errors });\n    }\n\n    // Initialize HLC\n    this.hlc = {\n      physicalMs: Date.now(),\n      logical: 0,\n    };\n\n    logger.info('Audit chain initialized', {\n      agentDid: this.config.agentDid,\n      backend: this.config.backend,\n    });\n  }\n\n  /**\n   * Tick the HLC and return new timestamp\n   *\n   * Implements the HLC tick algorithm:\n   * - If physical time has advanced, reset logical counter\n   * - Otherwise, increment logical counter\n   *\n   * @returns New HLC timestamp\n   */\n  private tickHLC(): HybridLogicalClock {\n    const now = Date.now();\n\n    if (now > this.hlc.physicalMs) {\n      this.hlc = { physicalMs: now, logical: 0 };\n    } else {\n      this.hlc = {\n        physicalMs: this.hlc.physicalMs,\n        logical: this.hlc.logical + 1,\n      };\n    }\n\n    return { ...this.hlc };\n  }\n\n  /**\n   * Update HLC based on received event\n   *\n   * Implements the HLC receive algorithm:\n   * - Take max of local, remote, and current time\n   * - Adjust logical counter appropriately\n   *\n   * @param received - HLC from received event\n   */\n  private updateHLC(received: HybridLogicalClock): void {\n    const now = Date.now();\n    const maxPhysical = Math.max(\n      now,\n      this.hlc.physicalMs,\n      received.physicalMs\n    );\n\n    if (\n      maxPhysical === this.hlc.physicalMs &&\n      maxPhysical === received.physicalMs\n    ) {\n      this.hlc = {\n        physicalMs: maxPhysical,\n        logical: Math.max(this.hlc.logical, received.logical) + 1,\n      };\n    } else if (maxPhysical === this.hlc.physicalMs) {\n      this.hlc = { physicalMs: maxPhysical, logical: this.hlc.logical + 1 };\n    } else if (maxPhysical === received.physicalMs) {\n      this.hlc = { physicalMs: maxPhysical, logical: received.logical + 1 };\n    } else {\n      this.hlc = { physicalMs: maxPhysical, logical: 0 };\n    }\n  }\n\n  /**\n   * Compare two HLCs\n   *\n   * @param a - First HLC\n   * @param b - Second HLC\n   * @returns Negative if a < b, positive if a > b, zero if equal\n   */\n  private compareHLC(a: HybridLogicalClock, b: HybridLogicalClock): number {\n    if (a.physicalMs !== b.physicalMs) {\n      return a.physicalMs - b.physicalMs;\n    }\n    return a.logical - b.logical;\n  }\n\n  /**\n   * Get current DAG tips (events with no children)\n   *\n   * Tips are the \"leaf\" events in the DAG that have not been\n   * referenced as parents by any other event.\n   *\n   * @returns Array of tip event IDs\n   */\n  getTips(): Blake3Hash[] {\n    return Array.from(this.tips);\n  }\n\n  /**\n   * Append an event to the chain\n   *\n   * Creates a new event with:\n   * - Current tips as parents (DAG structure)\n   * - New HLC timestamp\n   * - Signature for authenticity\n   *\n   * @param payload - Event payload to append\n   * @returns The created ledger event\n   *\n   * @example\n   * ```typescript\n   * const event = await chain.appendEvent({\n   *   type: 'NodeCreated',\n   *   nodeId: 'doc-1',\n   *   nodeType: 'Document',\n   *   properties: { title: 'README' }\n   * });\n   * console.log('Event ID:', event.id);\n   * ```\n   */\n  async appendEvent(\n    payload: KnowledgeGraphEventPayload\n  ): Promise<LedgerEvent> {\n    // Get current tips as parents\n    const parents = this.getTips();\n\n    // Tick HLC\n    const hlc = this.tickHLC();\n\n    // Create envelope\n    const envelope: EventEnvelope = {\n      parents,\n      hlc,\n      author: this.config.agentDid,\n      payload,\n    };\n\n    // Compute event ID (BLAKE3 hash of canonical envelope)\n    const serialized = canonicalSerialize(envelope);\n    const eventId = blake3Hash(serialized);\n\n    // Sign event ID\n    const signature = signData(eventId, this.config.privateKey);\n\n    // Create event\n    const event: LedgerEvent = {\n      id: eventId,\n      envelope,\n      signature,\n    };\n\n    // Store event\n    this.events.set(eventId, event);\n\n    // Update tips: remove parents from tips, add new event\n    for (const parent of parents) {\n      this.tips.delete(parent);\n    }\n    this.tips.add(eventId);\n\n    // Track events since checkpoint\n    this.eventsSinceCheckpoint++;\n\n    // Create checkpoint if needed\n    if (this.eventsSinceCheckpoint >= this.config.checkpointInterval) {\n      await this.createCheckpoint();\n    }\n\n    logger.debug('Appended event', {\n      eventId,\n      type: payload.type,\n      parents: parents.length,\n    });\n\n    return event;\n  }\n\n  /**\n   * Validate and insert an external event\n   *\n   * Performs validation:\n   * - Signature verification\n   * - Parent existence check\n   * - Causality verification (HLC ordering)\n   * - Event ID recomputation\n   *\n   * @param event - External event to validate and insert\n   * @returns Validation result with details\n   *\n   * @example\n   * ```typescript\n   * const validation = await chain.validateAndInsert(externalEvent);\n   * if (validation.valid) {\n   *   console.log('Event inserted successfully');\n   * } else {\n   *   console.error('Validation failed:', validation.errors);\n   * }\n   * ```\n   */\n  async validateAndInsert(event: LedgerEvent): Promise<EventValidation> {\n    const errors: string[] = [];\n\n    // Verify signature\n    const signatureValid = verifySignature(event.id, event.signature);\n    if (!signatureValid) {\n      errors.push('Invalid signature');\n    }\n\n    // Check parents exist\n    let parentsExist = true;\n    for (const parentId of event.envelope.parents) {\n      if (!this.events.has(parentId)) {\n        parentsExist = false;\n        errors.push(`Parent not found: ${parentId}`);\n      }\n    }\n\n    // Check causality (event HLC must be > all parent HLCs)\n    let causalityValid = true;\n    for (const parentId of event.envelope.parents) {\n      const parent = this.events.get(parentId);\n      if (\n        parent &&\n        this.compareHLC(event.envelope.hlc, parent.envelope.hlc) <= 0\n      ) {\n        causalityValid = false;\n        errors.push('Causality violation: event HLC not greater than parent');\n      }\n    }\n\n    // Recompute event ID\n    const serialized = canonicalSerialize(event.envelope);\n    const expectedId = blake3Hash(serialized);\n    if (event.id !== expectedId) {\n      errors.push('Event ID mismatch');\n    }\n\n    const validation: EventValidation = {\n      valid: errors.length === 0,\n      errors,\n      signatureValid,\n      causalityValid,\n      parentsExist,\n    };\n\n    // Insert if valid\n    if (validation.valid) {\n      this.events.set(event.id, event);\n      this.updateHLC(event.envelope.hlc);\n\n      // Update tips\n      for (const parent of event.envelope.parents) {\n        this.tips.delete(parent);\n      }\n      this.tips.add(event.id);\n\n      this.eventsSinceCheckpoint++;\n      logger.debug('Inserted external event', { eventId: event.id });\n    } else {\n      logger.warn('Rejected invalid event', { eventId: event.id, errors });\n    }\n\n    return validation;\n  }\n\n  /**\n   * Create a checkpoint\n   *\n   * Checkpoints provide:\n   * - Periodic state snapshots\n   * - Efficient verification of chain integrity\n   * - Recovery points for sync\n   *\n   * @returns The created checkpoint\n   */\n  async createCheckpoint(): Promise<Checkpoint> {\n    const height = this.checkpoints.length;\n\n    // Compute event root (simplified - real impl would use MMR)\n    const eventIds = Array.from(this.events.keys()).sort();\n    const eventRoot = blake3Hash(eventIds.join(':'));\n\n    // Compute state root (simplified)\n    const stateRoot = blake3Hash(JSON.stringify(this.getStats()));\n\n    const checkpoint: Checkpoint = {\n      height,\n      eventRoot,\n      stateRoot,\n      timestamp: new Date(),\n      validatorSignatures: [\n        {\n          validatorDid: this.config.agentDid,\n          signature: signData(eventRoot + stateRoot, this.config.privateKey),\n        },\n      ],\n    };\n\n    this.checkpoints.push(checkpoint);\n    this.eventsSinceCheckpoint = 0;\n\n    // Log checkpoint event\n    await this.appendEvent({\n      type: 'CheckpointCreated',\n      height,\n      eventRoot,\n      stateRoot,\n    });\n\n    logger.info('Created checkpoint', { height, eventCount: this.events.size });\n    return checkpoint;\n  }\n\n  /**\n   * Get the latest checkpoint\n   *\n   * @returns The most recent checkpoint, or null if none exist\n   */\n  getLatestCheckpoint(): Checkpoint | null {\n    return this.checkpoints[this.checkpoints.length - 1] || null;\n  }\n\n  /**\n   * Get an event by ID\n   *\n   * @param eventId - Event ID to look up\n   * @returns The event, or null if not found\n   */\n  getEvent(eventId: Blake3Hash): LedgerEvent | null {\n    return this.events.get(eventId) || null;\n  }\n\n  /**\n   * Query events\n   *\n   * Supports filtering by:\n   * - Event type\n   * - Author DID\n   * - Time range (HLC)\n   * - With optional Merkle proofs\n   *\n   * @param options - Query options\n   * @returns Query result with matching events\n   *\n   * @example\n   * ```typescript\n   * // Get all NodeCreated events\n   * const result = await chain.queryEvents({\n   *   type: 'NodeCreated',\n   *   limit: 50,\n   *   includeProof: true\n   * });\n   *\n   * for (const event of result.events) {\n   *   console.log(event.envelope.payload);\n   * }\n   * ```\n   */\n  async queryEvents(options: EventQueryOptions): Promise<EventQueryResult> {\n    let events = Array.from(this.events.values());\n\n    // Filter by type\n    if (options.type) {\n      events = events.filter((e) => e.envelope.payload.type === options.type);\n    }\n\n    // Filter by author\n    if (options.author) {\n      events = events.filter((e) => e.envelope.author === options.author);\n    }\n\n    // Filter by time range\n    if (options.since) {\n      events = events.filter(\n        (e) => this.compareHLC(e.envelope.hlc, options.since!) > 0\n      );\n    }\n    if (options.until) {\n      events = events.filter(\n        (e) => this.compareHLC(e.envelope.hlc, options.until!) < 0\n      );\n    }\n\n    // Sort by HLC\n    events.sort((a, b) => this.compareHLC(a.envelope.hlc, b.envelope.hlc));\n\n    const totalCount = events.length;\n    const limit = options.limit || 100;\n    const hasMore = totalCount > limit;\n    events = events.slice(0, limit);\n\n    // Generate proofs if requested\n    let proofs: Map<Blake3Hash, MerkleProof> | undefined;\n    if (options.includeProof) {\n      proofs = new Map();\n      for (const event of events) {\n        proofs.set(event.id, this.generateMerkleProof(event.id));\n      }\n    }\n\n    return {\n      events,\n      proofs,\n      totalCount,\n      hasMore,\n    };\n  }\n\n  /**\n   * Generate a Merkle proof for an event\n   *\n   * @param eventId - Event ID to generate proof for\n   * @returns Merkle proof structure\n   */\n  private generateMerkleProof(eventId: Blake3Hash): MerkleProof {\n    // Simplified proof - real impl would use proper Merkle tree\n    const eventIds = Array.from(this.events.keys()).sort();\n    const index = eventIds.indexOf(eventId);\n\n    const path: Blake3Hash[] = [];\n    const directions: ('left' | 'right')[] = [];\n\n    // Generate sibling hashes (simplified)\n    if (index > 0) {\n      path.push(blake3Hash(eventIds[index - 1]));\n      directions.push('left');\n    }\n    if (index < eventIds.length - 1) {\n      path.push(blake3Hash(eventIds[index + 1]));\n      directions.push('right');\n    }\n\n    const root = blake3Hash(eventIds.join(':'));\n\n    return { eventId, path, directions, root };\n  }\n\n  /**\n   * Verify a Merkle proof\n   *\n   * @param proof - Proof to verify\n   * @returns Whether the proof is valid\n   */\n  verifyMerkleProof(proof: MerkleProof): boolean {\n    // Simplified verification - real impl would recompute root\n    const checkpoint = this.getLatestCheckpoint();\n    return checkpoint ? proof.root === checkpoint.eventRoot : false;\n  }\n\n  /**\n   * Get chain statistics\n   *\n   * @returns Current chain statistics\n   */\n  getStats(): ChainStats {\n    const eventsByType: Record<string, number> = {};\n    const authors = new Set<Did>();\n    let lastEventTime: Date | undefined;\n\n    for (const event of this.events.values()) {\n      const type = event.envelope.payload.type;\n      eventsByType[type] = (eventsByType[type] || 0) + 1;\n      authors.add(event.envelope.author);\n\n      const eventTime = new Date(event.envelope.hlc.physicalMs);\n      if (!lastEventTime || eventTime > lastEventTime) {\n        lastEventTime = eventTime;\n      }\n    }\n\n    return {\n      totalEvents: this.events.size,\n      checkpointHeight: this.checkpoints.length,\n      uniqueAuthors: authors.size,\n      eventsByType,\n      lastEventTime,\n      status: 'healthy',\n    };\n  }\n\n  /**\n   * Get configuration\n   *\n   * @returns Current configuration (copy)\n   */\n  getConfig(): AuditChainConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Clear all events (for testing)\n   *\n   * Resets the chain to initial state.\n   */\n  clear(): void {\n    this.events.clear();\n    this.tips.clear();\n    this.checkpoints = [];\n    this.eventsSinceCheckpoint = 0;\n    this.hlc = { physicalMs: Date.now(), logical: 0 };\n    logger.info('Audit chain cleared');\n  }\n\n  /**\n   * Export chain data\n   *\n   * Exports all events, checkpoints, and tips for backup or sync.\n   *\n   * @returns Exported chain data\n   */\n  export(): {\n    events: LedgerEvent[];\n    checkpoints: Checkpoint[];\n    tips: Blake3Hash[];\n  } {\n    return {\n      events: Array.from(this.events.values()),\n      checkpoints: [...this.checkpoints],\n      tips: this.getTips(),\n    };\n  }\n\n  /**\n   * Import chain data\n   *\n   * Imports events from external source, validating each.\n   *\n   * @param data - Data to import\n   * @returns Import statistics\n   *\n   * @example\n   * ```typescript\n   * const exported = sourceChain.export();\n   * const { imported, rejected } = await targetChain.import(exported);\n   * console.log(`Imported ${imported} events, rejected ${rejected}`);\n   * ```\n   */\n  async import(data: {\n    events: LedgerEvent[];\n    checkpoints?: Checkpoint[];\n  }): Promise<{ imported: number; rejected: number }> {\n    let imported = 0;\n    let rejected = 0;\n\n    // Sort events by HLC\n    const sortedEvents = [...data.events].sort((a, b) =>\n      this.compareHLC(a.envelope.hlc, b.envelope.hlc)\n    );\n\n    for (const event of sortedEvents) {\n      const validation = await this.validateAndInsert(event);\n      if (validation.valid) {\n        imported++;\n      } else {\n        rejected++;\n      }\n    }\n\n    if (data.checkpoints) {\n      this.checkpoints = data.checkpoints;\n    }\n\n    logger.info('Imported chain data', { imported, rejected });\n    return { imported, rejected };\n  }\n}\n\n/**\n * Create an audit chain instance\n *\n * Factory function for creating AuditChain instances.\n *\n * @param config - Optional configuration overrides\n * @returns New AuditChain instance\n *\n * @example\n * ```typescript\n * // Create with defaults\n * const chain = createAuditChain();\n *\n * // Create with custom config\n * const chain = createAuditChain({\n *   agentDid: 'did:key:myagent',\n *   backend: 'sqlite',\n *   sqlitePath: './audit.db'\n * });\n * ```\n */\nexport function createAuditChain(\n  config?: Partial<AuditChainConfig>\n): AuditChain {\n  return new AuditChain(config);\n}\n"],"names":[],"mappings":"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"}