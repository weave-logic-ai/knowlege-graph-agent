{"version":3,"file":"find-connections.js","sources":["../../../../src/cli/commands/hive-mind/find-connections.ts"],"sourcesContent":["/**\n * Hive Mind - Connection Finder\n *\n * Uses TF-IDF similarity to find potential connections between documents.\n * Suggests links for orphan files to reconnect the knowledge graph.\n *\n * SPEC-003: Hive Mind Reconnection Tools\n */\n\nimport { Command } from 'commander';\nimport chalk from 'chalk';\nimport * as path from 'path';\nimport { readFile, writeFile } from 'fs/promises';\nimport { glob } from 'fast-glob';\nimport matter from 'gray-matter';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface FindConnectionsOptions {\n  threshold?: string;\n  suggest?: boolean;\n  limit?: string;\n  output?: string;\n  json?: boolean;\n  verbose?: boolean;\n}\n\nexport interface SimilarityMatch {\n  source: string;\n  target: string;\n  similarity: number;\n  sharedTerms: string[];\n}\n\nexport interface DocumentVector {\n  file: string;\n  terms: Map<string, number>;\n  magnitude: number;\n}\n\nexport interface ConnectionFinderResult {\n  totalDocuments: number;\n  suggestedConnections: SimilarityMatch[];\n  orphanConnections: SimilarityMatch[];\n  termCount: number;\n  averageSimilarity: number;\n}\n\n// ============================================================================\n// TF-IDF Implementation\n// ============================================================================\n\n/**\n * Simple tokenizer - splits text into words\n */\nfunction tokenize(text: string): string[] {\n  // Remove code blocks\n  const noCode = text.replace(/```[\\s\\S]*?```/g, '');\n  // Remove inline code\n  const noInline = noCode.replace(/`[^`]+`/g, '');\n  // Remove URLs\n  const noUrls = noInline.replace(/https?:\\/\\/[^\\s]+/g, '');\n  // Remove markdown links but keep text\n  const noLinks = noUrls.replace(/\\[([^\\]]+)\\]\\([^)]+\\)/g, '$1');\n  // Remove wiki links but keep text\n  const noWiki = noLinks.replace(/\\[\\[([^\\]|]+)(?:\\|[^\\]]+)?\\]\\]/g, '$1');\n  // Remove special characters and split\n  const words = noWiki\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s-]/g, ' ')\n    .split(/\\s+/)\n    .filter(word => word.length > 2 && word.length < 30);\n\n  return words;\n}\n\n/**\n * Stopwords to filter out\n */\nconst STOPWORDS = new Set([\n  'the', 'and', 'for', 'are', 'but', 'not', 'you', 'all', 'can', 'had', 'her',\n  'was', 'one', 'our', 'out', 'has', 'have', 'been', 'were', 'some', 'this',\n  'that', 'what', 'when', 'where', 'which', 'while', 'who', 'will', 'with',\n  'would', 'there', 'their', 'from', 'they', 'been', 'said', 'each', 'she',\n  'how', 'its', 'may', 'more', 'than', 'then', 'these', 'into', 'only',\n  'other', 'also', 'any', 'such', 'because', 'about', 'just', 'could', 'very',\n]);\n\n/**\n * Filter stopwords\n */\nfunction filterStopwords(words: string[]): string[] {\n  return words.filter(word => !STOPWORDS.has(word));\n}\n\n// ============================================================================\n// Connection Finder Class\n// ============================================================================\n\nexport class ConnectionFinder {\n  private documents: Map<string, string> = new Map();\n  private documentVectors: Map<string, DocumentVector> = new Map();\n  private documentFrequency: Map<string, number> = new Map();\n  private totalDocuments = 0;\n\n  /**\n   * Build TF-IDF index from vault\n   */\n  async buildIndex(vaultPath: string): Promise<void> {\n    const resolvedPath = path.resolve(vaultPath);\n\n    // Find all markdown files\n    const files = await glob('**/*.md', {\n      cwd: resolvedPath,\n      ignore: ['node_modules/**', '.git/**', 'dist/**'],\n      absolute: false,\n    });\n\n    if (files.length === 0) {\n      throw new Error(`No markdown files found in: ${resolvedPath}`);\n    }\n\n    this.documents.clear();\n    this.documentVectors.clear();\n    this.documentFrequency.clear();\n    this.totalDocuments = files.length;\n\n    // First pass: calculate document frequency\n    const termDocuments = new Map<string, Set<string>>();\n\n    for (const file of files) {\n      const filePath = path.join(resolvedPath, file);\n      const content = await readFile(filePath, 'utf-8');\n      const { content: bodyContent, data: frontmatter } = matter(content);\n\n      // Combine content with frontmatter fields\n      const fullText = [\n        frontmatter.title || '',\n        frontmatter.description || '',\n        Array.isArray(frontmatter.tags) ? frontmatter.tags.join(' ') : '',\n        Array.isArray(frontmatter.aliases) ? frontmatter.aliases.join(' ') : '',\n        bodyContent,\n      ].join(' ');\n\n      this.documents.set(file, fullText);\n\n      const tokens = filterStopwords(tokenize(fullText));\n      const uniqueTerms = new Set(tokens);\n\n      for (const term of uniqueTerms) {\n        if (!termDocuments.has(term)) {\n          termDocuments.set(term, new Set());\n        }\n        termDocuments.get(term)!.add(file);\n      }\n    }\n\n    // Store document frequency\n    for (const [term, docs] of termDocuments) {\n      this.documentFrequency.set(term, docs.size);\n    }\n\n    // Second pass: calculate TF-IDF vectors\n    for (const file of files) {\n      const content = this.documents.get(file)!;\n      const tokens = filterStopwords(tokenize(content));\n\n      // Calculate term frequency\n      const termFreq = new Map<string, number>();\n      for (const term of tokens) {\n        termFreq.set(term, (termFreq.get(term) || 0) + 1);\n      }\n\n      // Calculate TF-IDF\n      const tfidf = new Map<string, number>();\n      const maxFreq = Math.max(...termFreq.values(), 1);\n\n      for (const [term, freq] of termFreq) {\n        const tf = freq / maxFreq; // Normalized TF\n        const df = this.documentFrequency.get(term) || 1;\n        const idf = Math.log(this.totalDocuments / df);\n        tfidf.set(term, tf * idf);\n      }\n\n      // Calculate magnitude\n      let magnitude = 0;\n      for (const value of tfidf.values()) {\n        magnitude += value * value;\n      }\n      magnitude = Math.sqrt(magnitude);\n\n      this.documentVectors.set(file, {\n        file,\n        terms: tfidf,\n        magnitude,\n      });\n    }\n  }\n\n  /**\n   * Find similar documents to a source file\n   */\n  findSimilar(sourceFile: string, threshold = 0.3, limit = 10): SimilarityMatch[] {\n    const sourceVector = this.documentVectors.get(sourceFile);\n    if (!sourceVector) {\n      return [];\n    }\n\n    const matches: SimilarityMatch[] = [];\n\n    for (const [targetFile, targetVector] of this.documentVectors) {\n      if (targetFile === sourceFile) continue;\n\n      const similarity = this.cosineSimilarity(sourceVector, targetVector);\n\n      if (similarity >= threshold) {\n        const sharedTerms = this.findSharedTerms(sourceVector, targetVector);\n        matches.push({\n          source: sourceFile,\n          target: targetFile,\n          similarity: Math.round(similarity * 1000) / 1000,\n          sharedTerms: sharedTerms.slice(0, 5),\n        });\n      }\n    }\n\n    // Sort by similarity descending\n    matches.sort((a, b) => b.similarity - a.similarity);\n\n    return matches.slice(0, limit);\n  }\n\n  /**\n   * Calculate cosine similarity between two document vectors\n   */\n  private cosineSimilarity(a: DocumentVector, b: DocumentVector): number {\n    if (a.magnitude === 0 || b.magnitude === 0) return 0;\n\n    let dotProduct = 0;\n    for (const [term, aValue] of a.terms) {\n      const bValue = b.terms.get(term) || 0;\n      dotProduct += aValue * bValue;\n    }\n\n    return dotProduct / (a.magnitude * b.magnitude);\n  }\n\n  /**\n   * Find shared terms between two documents\n   */\n  private findSharedTerms(a: DocumentVector, b: DocumentVector): string[] {\n    const shared: Array<{ term: string; score: number }> = [];\n\n    for (const [term, aValue] of a.terms) {\n      const bValue = b.terms.get(term);\n      if (bValue && bValue > 0) {\n        shared.push({ term, score: aValue * bValue });\n      }\n    }\n\n    // Sort by combined score\n    shared.sort((a, b) => b.score - a.score);\n\n    return shared.map(s => s.term);\n  }\n\n  /**\n   * Suggest connections for orphan files\n   */\n  async suggestConnections(\n    vaultPath: string,\n    orphanFiles: string[],\n    threshold = 0.3,\n    limit = 5\n  ): Promise<SimilarityMatch[]> {\n    // Build index if not already built\n    if (this.documentVectors.size === 0) {\n      await this.buildIndex(vaultPath);\n    }\n\n    const suggestions: SimilarityMatch[] = [];\n\n    for (const orphan of orphanFiles) {\n      const similar = this.findSimilar(orphan, threshold, limit);\n      suggestions.push(...similar);\n    }\n\n    // Sort by similarity descending\n    suggestions.sort((a, b) => b.similarity - a.similarity);\n\n    return suggestions;\n  }\n\n  /**\n   * Find all potential connections above threshold\n   */\n  async findAllConnections(\n    vaultPath: string,\n    threshold = 0.3,\n    limit = 100\n  ): Promise<ConnectionFinderResult> {\n    // Build index if not already built\n    if (this.documentVectors.size === 0) {\n      await this.buildIndex(vaultPath);\n    }\n\n    const allConnections: SimilarityMatch[] = [];\n    const processed = new Set<string>();\n\n    for (const sourceFile of this.documentVectors.keys()) {\n      const similar = this.findSimilar(sourceFile, threshold, 10);\n      for (const match of similar) {\n        // Avoid duplicates (A-B and B-A)\n        const key = [match.source, match.target].sort().join('|');\n        if (!processed.has(key)) {\n          processed.add(key);\n          allConnections.push(match);\n        }\n      }\n    }\n\n    // Sort by similarity descending\n    allConnections.sort((a, b) => b.similarity - a.similarity);\n\n    const topConnections = allConnections.slice(0, limit);\n    const averageSimilarity = topConnections.length > 0\n      ? topConnections.reduce((sum, c) => sum + c.similarity, 0) / topConnections.length\n      : 0;\n\n    return {\n      totalDocuments: this.totalDocuments,\n      suggestedConnections: topConnections,\n      orphanConnections: [],\n      termCount: this.documentFrequency.size,\n      averageSimilarity: Math.round(averageSimilarity * 1000) / 1000,\n    };\n  }\n\n  /**\n   * Get index statistics\n   */\n  getStats(): { documents: number; terms: number } {\n    return {\n      documents: this.documentVectors.size,\n      terms: this.documentFrequency.size,\n    };\n  }\n}\n\n// ============================================================================\n// CLI Command\n// ============================================================================\n\nexport function createFindConnectionsCommand(): Command {\n  const command = new Command('find-connections')\n    .description('Find potential connections using TF-IDF similarity')\n    .argument('<vault-path>', 'Path to Obsidian vault or docs directory')\n    .option('-t, --threshold <number>', 'Similarity threshold (0-1)', '0.3')\n    .option('-l, --limit <number>', 'Maximum connections to return', '50')\n    .option('--suggest', 'Focus on orphan files')\n    .option('-o, --output <file>', 'Output file for results')\n    .option('--json', 'Output as JSON')\n    .option('-v, --verbose', 'Show detailed output')\n    .action(async (vaultPath: string, options: FindConnectionsOptions) => {\n      const finder = new ConnectionFinder();\n      const threshold = parseFloat(options.threshold || '0.3');\n      const limit = parseInt(options.limit || '50', 10);\n\n      console.log(chalk.cyan('\\nBuilding TF-IDF index...\\n'));\n\n      try {\n        await finder.buildIndex(vaultPath);\n        const stats = finder.getStats();\n\n        console.log(chalk.white(`  Documents indexed: ${stats.documents}`));\n        console.log(chalk.white(`  Unique terms:      ${stats.terms}`));\n        console.log('');\n\n        const result = await finder.findAllConnections(vaultPath, threshold, limit);\n\n        if (options.json) {\n          if (options.output) {\n            await writeFile(options.output, JSON.stringify(result, null, 2));\n            console.log(chalk.green(`Results written to: ${options.output}`));\n          } else {\n            console.log(JSON.stringify(result, null, 2));\n          }\n        } else {\n          console.log(chalk.bold('Potential Connections Found:\\n'));\n\n          if (result.suggestedConnections.length === 0) {\n            console.log(chalk.yellow('  No connections found above threshold.'));\n            console.log(chalk.gray('  Try lowering the threshold with -t option.\\n'));\n          } else {\n            for (const conn of result.suggestedConnections.slice(0, options.verbose ? 50 : 20)) {\n              const simColor = conn.similarity >= 0.5 ? chalk.green : conn.similarity >= 0.3 ? chalk.yellow : chalk.gray;\n              console.log(\n                simColor(`  [${(conn.similarity * 100).toFixed(1)}%]`),\n                chalk.white(conn.source),\n                chalk.gray('->'),\n                chalk.cyan(conn.target)\n              );\n              if (options.verbose && conn.sharedTerms.length > 0) {\n                console.log(chalk.gray(`          Terms: ${conn.sharedTerms.join(', ')}`));\n              }\n            }\n\n            if (result.suggestedConnections.length > (options.verbose ? 50 : 20)) {\n              console.log(\n                chalk.gray(`\\n  ... and ${result.suggestedConnections.length - (options.verbose ? 50 : 20)} more`)\n              );\n            }\n\n            console.log('');\n            console.log(chalk.bold('Summary:'));\n            console.log(chalk.white(`  Total Documents:   ${result.totalDocuments}`));\n            console.log(chalk.white(`  Connections Found: ${result.suggestedConnections.length}`));\n            console.log(chalk.white(`  Average Similarity: ${(result.averageSimilarity * 100).toFixed(1)}%`));\n            console.log('');\n          }\n\n          // Write to output file if specified\n          if (options.output) {\n            const reportLines = [\n              '# Connection Suggestions\\n',\n              `Generated: ${new Date().toISOString()}\\n`,\n              `Threshold: ${threshold}\\n`,\n              '',\n              '## Suggested Links\\n',\n            ];\n\n            for (const conn of result.suggestedConnections) {\n              reportLines.push(`- **${conn.source}** -> [[${conn.target}]]`);\n              reportLines.push(`  - Similarity: ${(conn.similarity * 100).toFixed(1)}%`);\n              if (conn.sharedTerms.length > 0) {\n                reportLines.push(`  - Shared terms: ${conn.sharedTerms.join(', ')}`);\n              }\n            }\n\n            await writeFile(options.output, reportLines.join('\\n'));\n            console.log(chalk.green(`Report written to: ${options.output}`));\n          }\n\n          // Show next steps\n          console.log(chalk.bold('Next Steps:'));\n          console.log(chalk.gray('  1. Review suggested connections'));\n          console.log(chalk.gray('  2. Add [[wiki-links]] to connect related documents'));\n          console.log(chalk.gray('  3. Run kg analyze-links to verify improvement'));\n          console.log('');\n        }\n      } catch (error) {\n        console.error(chalk.red('Error:'), error instanceof Error ? error.message : 'Unknown error');\n        process.exit(1);\n      }\n    });\n\n  return command;\n}\n\nexport default createFindConnectionsCommand;\n"],"names":["a","b"],"mappings":"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"}