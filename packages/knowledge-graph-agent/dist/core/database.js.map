{"version":3,"file":"database.js","sources":["../../src/core/database.ts"],"sourcesContent":["/**\n * Knowledge Graph Database\n *\n * SQLite database for persistent storage of knowledge graph data.\n * Compatible with claude-flow database patterns.\n */\n\nimport Database from 'better-sqlite3';\nimport { existsSync, mkdirSync } from 'fs';\nimport { dirname } from 'path';\nimport type {\n  KnowledgeNode,\n  GraphEdge,\n  GraphStats,\n  NodeType,\n  NodeStatus,\n} from './types.js';\n\n/**\n * Safely parse JSON with fallback\n * Prevents error leakage from malformed JSON\n */\nfunction safeJsonParse<T>(str: string | null | undefined, fallback: T): T {\n  if (!str) return fallback;\n  try {\n    return JSON.parse(str) as T;\n  } catch {\n    return fallback;\n  }\n}\n\nconst SCHEMA_SQL = `\n-- Knowledge Graph Schema v1.0\n\n-- Nodes table\nCREATE TABLE IF NOT EXISTS nodes (\n  id TEXT PRIMARY KEY,\n  path TEXT NOT NULL UNIQUE,\n  filename TEXT NOT NULL,\n  title TEXT NOT NULL,\n  type TEXT NOT NULL CHECK(type IN ('concept', 'technical', 'feature', 'primitive', 'service', 'guide', 'standard', 'integration')),\n  status TEXT NOT NULL DEFAULT 'active' CHECK(status IN ('draft', 'active', 'deprecated', 'archived')),\n  content TEXT,\n  frontmatter TEXT,\n  word_count INTEGER DEFAULT 0,\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\n-- Tags table\nCREATE TABLE IF NOT EXISTS tags (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  name TEXT NOT NULL UNIQUE\n);\n\n-- Node-Tags junction table\nCREATE TABLE IF NOT EXISTS node_tags (\n  node_id TEXT NOT NULL,\n  tag_id INTEGER NOT NULL,\n  PRIMARY KEY (node_id, tag_id),\n  FOREIGN KEY (node_id) REFERENCES nodes(id) ON DELETE CASCADE,\n  FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE\n);\n\n-- Edges table\nCREATE TABLE IF NOT EXISTS edges (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  source_id TEXT NOT NULL,\n  target_id TEXT NOT NULL,\n  type TEXT NOT NULL CHECK(type IN ('link', 'reference', 'parent', 'related')),\n  weight REAL DEFAULT 1.0,\n  context TEXT,\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  FOREIGN KEY (source_id) REFERENCES nodes(id) ON DELETE CASCADE\n);\n\n-- Metadata table\nCREATE TABLE IF NOT EXISTS metadata (\n  key TEXT PRIMARY KEY,\n  value TEXT,\n  updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\n-- Indexes for performance\nCREATE INDEX IF NOT EXISTS idx_nodes_type ON nodes(type);\nCREATE INDEX IF NOT EXISTS idx_nodes_status ON nodes(status);\nCREATE INDEX IF NOT EXISTS idx_nodes_path ON nodes(path);\nCREATE INDEX IF NOT EXISTS idx_edges_source ON edges(source_id);\nCREATE INDEX IF NOT EXISTS idx_edges_target ON edges(target_id);\nCREATE INDEX IF NOT EXISTS idx_node_tags_node ON node_tags(node_id);\nCREATE INDEX IF NOT EXISTS idx_node_tags_tag ON node_tags(tag_id);\n\n-- Full-text search\nCREATE VIRTUAL TABLE IF NOT EXISTS nodes_fts USING fts5(\n  title,\n  content,\n  content='nodes',\n  content_rowid='rowid'\n);\n\n-- Triggers for FTS sync\nCREATE TRIGGER IF NOT EXISTS nodes_ai AFTER INSERT ON nodes BEGIN\n  INSERT INTO nodes_fts(rowid, title, content) VALUES (NEW.rowid, NEW.title, NEW.content);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS nodes_ad AFTER DELETE ON nodes BEGIN\n  INSERT INTO nodes_fts(nodes_fts, rowid, title, content) VALUES('delete', OLD.rowid, OLD.title, OLD.content);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS nodes_au AFTER UPDATE ON nodes BEGIN\n  INSERT INTO nodes_fts(nodes_fts, rowid, title, content) VALUES('delete', OLD.rowid, OLD.title, OLD.content);\n  INSERT INTO nodes_fts(rowid, title, content) VALUES (NEW.rowid, NEW.title, NEW.content);\nEND;\n\n-- Initialize metadata\nINSERT OR IGNORE INTO metadata (key, value) VALUES ('version', '1.0.0');\nINSERT OR IGNORE INTO metadata (key, value) VALUES ('created', datetime('now'));\n`;\n\n/**\n * Knowledge Graph Database\n */\nexport class KnowledgeGraphDatabase {\n  private db: Database.Database;\n  private dbPath: string;\n\n  constructor(dbPath: string) {\n    this.dbPath = dbPath;\n\n    // Ensure directory exists\n    const dir = dirname(dbPath);\n    if (!existsSync(dir)) {\n      mkdirSync(dir, { recursive: true });\n    }\n\n    // Open database\n    this.db = new Database(dbPath);\n    this.db.pragma('journal_mode = WAL');\n    this.db.pragma('foreign_keys = ON');\n    this.db.pragma('busy_timeout = 5000');\n\n    // Initialize schema\n    this.db.exec(SCHEMA_SQL);\n  }\n\n  // ========================================================================\n  // Node Operations\n  // ========================================================================\n\n  /**\n   * Insert or update a node\n   */\n  upsertNode(node: KnowledgeNode): void {\n    const stmt = this.db.prepare(`\n      INSERT INTO nodes (id, path, filename, title, type, status, content, frontmatter, word_count, updated_at)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))\n      ON CONFLICT(id) DO UPDATE SET\n        path = excluded.path,\n        filename = excluded.filename,\n        title = excluded.title,\n        type = excluded.type,\n        status = excluded.status,\n        content = excluded.content,\n        frontmatter = excluded.frontmatter,\n        word_count = excluded.word_count,\n        updated_at = datetime('now')\n    `);\n\n    stmt.run(\n      node.id,\n      node.path,\n      node.filename,\n      node.title,\n      node.type,\n      node.status,\n      node.content,\n      JSON.stringify(node.frontmatter),\n      node.wordCount\n    );\n\n    // Update tags\n    this.updateNodeTags(node.id, node.tags);\n  }\n\n  /**\n   * Get node by ID\n   */\n  getNode(id: string): KnowledgeNode | null {\n    const stmt = this.db.prepare('SELECT * FROM nodes WHERE id = ?');\n    const row = stmt.get(id) as NodeRow | undefined;\n    if (!row) return null;\n    return this.rowToNode(row);\n  }\n\n  /**\n   * Get node by path\n   */\n  getNodeByPath(path: string): KnowledgeNode | null {\n    const stmt = this.db.prepare('SELECT * FROM nodes WHERE path = ?');\n    const row = stmt.get(path) as NodeRow | undefined;\n    if (!row) return null;\n    return this.rowToNode(row);\n  }\n\n  /**\n   * Get all nodes\n   */\n  getAllNodes(): KnowledgeNode[] {\n    const stmt = this.db.prepare('SELECT * FROM nodes ORDER BY title');\n    const rows = stmt.all() as NodeRow[];\n    return rows.map(row => this.rowToNode(row));\n  }\n\n  /**\n   * Get nodes by type\n   */\n  getNodesByType(type: NodeType): KnowledgeNode[] {\n    const stmt = this.db.prepare('SELECT * FROM nodes WHERE type = ? ORDER BY title');\n    const rows = stmt.all(type) as NodeRow[];\n    return rows.map(row => this.rowToNode(row));\n  }\n\n  /**\n   * Get nodes by status\n   */\n  getNodesByStatus(status: NodeStatus): KnowledgeNode[] {\n    const stmt = this.db.prepare('SELECT * FROM nodes WHERE status = ? ORDER BY title');\n    const rows = stmt.all(status) as NodeRow[];\n    return rows.map(row => this.rowToNode(row));\n  }\n\n  /**\n   * Get nodes by tag\n   */\n  getNodesByTag(tag: string): KnowledgeNode[] {\n    const stmt = this.db.prepare(`\n      SELECT n.* FROM nodes n\n      JOIN node_tags nt ON n.id = nt.node_id\n      JOIN tags t ON nt.tag_id = t.id\n      WHERE t.name = ?\n      ORDER BY n.title\n    `);\n    const rows = stmt.all(tag) as NodeRow[];\n    return rows.map(row => this.rowToNode(row));\n  }\n\n  /**\n   * Sanitize FTS5 query to prevent query injection\n   * Escapes special FTS5 operators and quotes terms\n   */\n  private sanitizeFtsQuery(query: string): string {\n    if (!query || typeof query !== 'string') return '';\n\n    // Remove FTS5 special operators: * \" ( ) : ^ - AND OR NOT NEAR\n    const sanitized = query\n      .replace(/[*\"():^\\-]/g, ' ')  // Remove special chars\n      .replace(/\\b(AND|OR|NOT|NEAR)\\b/gi, '') // Remove boolean operators\n      .trim()\n      .split(/\\s+/)\n      .filter(term => term.length > 0 && term.length < 100) // Limit term length\n      .slice(0, 20)  // Limit number of terms\n      .map(term => `\"${term.replace(/\"/g, '')}\"`)  // Quote each term safely\n      .join(' ');\n\n    return sanitized;\n  }\n\n  /**\n   * Search nodes by title or content\n   */\n  searchNodes(query: string, limit = 50): KnowledgeNode[] {\n    const sanitizedQuery = this.sanitizeFtsQuery(query);\n\n    // Return empty if no valid search terms\n    if (!sanitizedQuery) {\n      return [];\n    }\n\n    // Enforce reasonable limit\n    const safeLimit = Math.min(Math.max(1, limit), 100);\n\n    const stmt = this.db.prepare(`\n      SELECT n.* FROM nodes n\n      JOIN nodes_fts fts ON n.rowid = fts.rowid\n      WHERE nodes_fts MATCH ?\n      ORDER BY rank\n      LIMIT ?\n    `);\n    const rows = stmt.all(sanitizedQuery, safeLimit) as NodeRow[];\n    return rows.map(row => this.rowToNode(row));\n  }\n\n  /**\n   * Delete node\n   */\n  deleteNode(id: string): boolean {\n    const stmt = this.db.prepare('DELETE FROM nodes WHERE id = ?');\n    const result = stmt.run(id);\n    return result.changes > 0;\n  }\n\n  // ========================================================================\n  // Tag Operations\n  // ========================================================================\n\n  /**\n   * Update tags for a node\n   */\n  private updateNodeTags(nodeId: string, tags: string[]): void {\n    // Remove existing tags\n    this.db.prepare('DELETE FROM node_tags WHERE node_id = ?').run(nodeId);\n\n    // Insert new tags\n    const getOrCreateTag = this.db.prepare(`\n      INSERT INTO tags (name) VALUES (?)\n      ON CONFLICT(name) DO UPDATE SET name = excluded.name\n      RETURNING id\n    `);\n\n    const insertNodeTag = this.db.prepare(\n      'INSERT OR IGNORE INTO node_tags (node_id, tag_id) VALUES (?, ?)'\n    );\n\n    for (const tag of tags) {\n      const result = getOrCreateTag.get(tag) as { id: number };\n      insertNodeTag.run(nodeId, result.id);\n    }\n  }\n\n  /**\n   * Get tags for a node\n   */\n  getNodeTags(nodeId: string): string[] {\n    const stmt = this.db.prepare(`\n      SELECT t.name FROM tags t\n      JOIN node_tags nt ON t.id = nt.tag_id\n      WHERE nt.node_id = ?\n      ORDER BY t.name\n    `);\n    const rows = stmt.all(nodeId) as Array<{ name: string }>;\n    return rows.map(r => r.name);\n  }\n\n  /**\n   * Get all tags with counts\n   */\n  getAllTags(): Array<{ name: string; count: number }> {\n    const stmt = this.db.prepare(`\n      SELECT t.name, COUNT(nt.node_id) as count\n      FROM tags t\n      LEFT JOIN node_tags nt ON t.id = nt.tag_id\n      GROUP BY t.id\n      ORDER BY count DESC, t.name\n    `);\n    return stmt.all() as Array<{ name: string; count: number }>;\n  }\n\n  // ========================================================================\n  // Edge Operations\n  // ========================================================================\n\n  /**\n   * Add edge\n   */\n  addEdge(edge: GraphEdge): void {\n    const stmt = this.db.prepare(`\n      INSERT INTO edges (source_id, target_id, type, weight, context)\n      VALUES (?, ?, ?, ?, ?)\n    `);\n    stmt.run(edge.source, edge.target, edge.type, edge.weight, edge.context);\n  }\n\n  /**\n   * Get outgoing edges for a node\n   */\n  getOutgoingEdges(nodeId: string): GraphEdge[] {\n    const stmt = this.db.prepare('SELECT * FROM edges WHERE source_id = ?');\n    const rows = stmt.all(nodeId) as EdgeRow[];\n    return rows.map(row => this.rowToEdge(row));\n  }\n\n  /**\n   * Get incoming edges for a node\n   */\n  getIncomingEdges(nodeId: string): GraphEdge[] {\n    const stmt = this.db.prepare('SELECT * FROM edges WHERE target_id = ?');\n    const rows = stmt.all(nodeId) as EdgeRow[];\n    return rows.map(row => this.rowToEdge(row));\n  }\n\n  /**\n   * Delete edges for a node\n   */\n  deleteNodeEdges(nodeId: string): void {\n    this.db.prepare('DELETE FROM edges WHERE source_id = ?').run(nodeId);\n  }\n\n  // ========================================================================\n  // Statistics\n  // ========================================================================\n\n  /**\n   * Get graph statistics\n   */\n  getStats(): GraphStats {\n    const totalNodes = (this.db.prepare('SELECT COUNT(*) as count FROM nodes').get() as { count: number }).count;\n    const totalEdges = (this.db.prepare('SELECT COUNT(*) as count FROM edges').get() as { count: number }).count;\n\n    const typeStats = this.db.prepare(`\n      SELECT type, COUNT(*) as count FROM nodes GROUP BY type\n    `).all() as Array<{ type: NodeType; count: number }>;\n\n    const statusStats = this.db.prepare(`\n      SELECT status, COUNT(*) as count FROM nodes GROUP BY status\n    `).all() as Array<{ status: NodeStatus; count: number }>;\n\n    const nodesByType: Record<NodeType, number> = {\n      concept: 0, technical: 0, feature: 0, primitive: 0,\n      service: 0, guide: 0, standard: 0, integration: 0,\n    };\n    for (const { type, count } of typeStats) {\n      nodesByType[type] = count;\n    }\n\n    const nodesByStatus: Record<NodeStatus, number> = {\n      draft: 0, active: 0, deprecated: 0, archived: 0,\n    };\n    for (const { status, count } of statusStats) {\n      nodesByStatus[status] = count;\n    }\n\n    const orphanNodes = (this.db.prepare(`\n      SELECT COUNT(*) as count FROM nodes n\n      WHERE NOT EXISTS (SELECT 1 FROM edges e WHERE e.source_id = n.id OR e.target_id = n.id)\n    `).get() as { count: number }).count;\n\n    const avgLinksPerNode = totalNodes > 0 ? totalEdges / totalNodes : 0;\n\n    const mostConnected = this.db.prepare(`\n      SELECT n.id, (\n        (SELECT COUNT(*) FROM edges WHERE source_id = n.id) +\n        (SELECT COUNT(*) FROM edges WHERE target_id = n.id)\n      ) as connections\n      FROM nodes n\n      ORDER BY connections DESC\n      LIMIT 5\n    `).all() as Array<{ id: string; connections: number }>;\n\n    return {\n      totalNodes,\n      totalEdges,\n      nodesByType,\n      nodesByStatus,\n      orphanNodes,\n      avgLinksPerNode: Math.round(avgLinksPerNode * 100) / 100,\n      mostConnected,\n    };\n  }\n\n  // ========================================================================\n  // Metadata Operations\n  // ========================================================================\n\n  /**\n   * Get metadata value\n   */\n  getMetadata(key: string): string | null {\n    const stmt = this.db.prepare('SELECT value FROM metadata WHERE key = ?');\n    const row = stmt.get(key) as { value: string } | undefined;\n    return row?.value ?? null;\n  }\n\n  /**\n   * Set metadata value\n   */\n  setMetadata(key: string, value: string): void {\n    const stmt = this.db.prepare(`\n      INSERT INTO metadata (key, value, updated_at) VALUES (?, ?, datetime('now'))\n      ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = datetime('now')\n    `);\n    stmt.run(key, value);\n  }\n\n  // ========================================================================\n  // Utilities\n  // ========================================================================\n\n  /**\n   * Convert database row to KnowledgeNode\n   */\n  private rowToNode(row: NodeRow): KnowledgeNode {\n    const tags = this.getNodeTags(row.id);\n    const outgoingEdges = this.getOutgoingEdges(row.id);\n    const incomingEdges = this.getIncomingEdges(row.id);\n\n    return {\n      id: row.id,\n      path: row.path,\n      filename: row.filename,\n      title: row.title,\n      type: row.type as NodeType,\n      status: row.status as NodeStatus,\n      content: row.content || '',\n      frontmatter: safeJsonParse(row.frontmatter, {}),\n      tags,\n      outgoingLinks: outgoingEdges.map(e => ({\n        target: e.target,\n        type: 'wikilink' as const,\n        context: e.context,\n      })),\n      incomingLinks: incomingEdges.map(e => ({\n        target: e.source,\n        type: 'backlink' as const,\n        context: e.context,\n      })),\n      wordCount: row.word_count,\n      lastModified: new Date(row.updated_at),\n    };\n  }\n\n  /**\n   * Convert database row to GraphEdge\n   */\n  private rowToEdge(row: EdgeRow): GraphEdge {\n    return {\n      source: row.source_id,\n      target: row.target_id,\n      type: row.type as GraphEdge['type'],\n      weight: row.weight,\n      context: row.context ?? undefined,\n    };\n  }\n\n  /**\n   * Close database connection\n   */\n  close(): void {\n    this.db.close();\n  }\n\n  /**\n   * Get raw database instance\n   */\n  getDatabase(): Database.Database {\n    return this.db;\n  }\n}\n\n// Row types for database queries\ninterface NodeRow {\n  id: string;\n  path: string;\n  filename: string;\n  title: string;\n  type: string;\n  status: string;\n  content: string | null;\n  frontmatter: string | null;\n  word_count: number;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface EdgeRow {\n  id: number;\n  source_id: string;\n  target_id: string;\n  type: string;\n  weight: number;\n  context: string | null;\n  created_at: string;\n}\n\n/**\n * Create knowledge graph database instance\n */\nexport function createDatabase(dbPath: string): KnowledgeGraphDatabase {\n  return new KnowledgeGraphDatabase(dbPath);\n}\n"],"names":[],"mappings":"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"}