{"version":3,"file":"deep-analyzer.js","sources":["../../src/cultivation/deep-analyzer.ts"],"sourcesContent":["/**\n * DeepAnalyzer - Claude-Flow Integration for Deep Codebase Analysis\n *\n * Uses claude-flow agents for comprehensive codebase analysis:\n * - Pattern detection and architectural insights\n * - Documentation gap analysis\n * - Standards compliance checking\n *\n * @module cultivation/deep-analyzer\n */\n\nimport { execFileSync, spawn } from 'child_process';\nimport { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';\nimport { join, resolve } from 'path';\nimport { createLogger } from '../utils/index.js';\n\nconst logger = createLogger('deep-analyzer');\n\n/**\n * Valid agent types for security validation\n */\nconst VALID_AGENT_TYPES = new Set([\n  'researcher',\n  'architect',\n  'analyst',\n  'coder',\n  'tester',\n  'reviewer',\n  'documenter',\n]);\n\n/**\n * Deep analyzer options\n */\nexport interface DeepAnalyzerOptions {\n  /** Project root directory */\n  projectRoot: string;\n  /** Documentation path (relative to project root) */\n  docsPath?: string;\n  /** Output directory for analysis results */\n  outputDir?: string;\n  /** Enable verbose logging */\n  verbose?: boolean;\n  /** Maximum agents to spawn */\n  maxAgents?: number;\n  /** Agent execution mode */\n  agentMode?: 'sequential' | 'parallel' | 'adaptive';\n  /** Timeout for each agent (ms) */\n  agentTimeout?: number;\n}\n\n/**\n * Analysis result from an agent\n */\nexport interface AgentResult {\n  name: string;\n  type: string;\n  success: boolean;\n  insights: string[];\n  documents: Array<{ path: string; title: string }>;\n  duration: number;\n  error?: string;\n}\n\n/**\n * Deep analysis result\n */\nexport interface DeepAnalysisResult {\n  success: boolean;\n  agentsSpawned: number;\n  insightsCount: number;\n  documentsCreated: number;\n  results: AgentResult[];\n  duration: number;\n  errors: string[];\n}\n\n/**\n * Agent configuration\n */\ninterface AgentConfig {\n  name: string;\n  type: 'researcher' | 'analyst' | 'coder' | 'tester' | 'reviewer';\n  task: string;\n  outputFile: string;\n}\n\n/**\n * DeepAnalyzer - Uses claude-flow for deep codebase analysis\n *\n * @example\n * ```typescript\n * const analyzer = new DeepAnalyzer({\n *   projectRoot: '/my/project',\n *   docsPath: 'docs',\n * });\n *\n * const result = await analyzer.analyze();\n * console.log(`Generated ${result.insightsCount} insights`);\n * ```\n */\nexport class DeepAnalyzer {\n  private projectRoot: string;\n  private docsPath: string;\n  private outputDir: string;\n  private verbose: boolean;\n  private maxAgents: number;\n  private agentMode: 'sequential' | 'parallel' | 'adaptive';\n  private agentTimeout: number;\n\n  constructor(options: DeepAnalyzerOptions) {\n    this.projectRoot = resolve(options.projectRoot);\n    this.docsPath = options.docsPath || 'docs';\n    this.outputDir = options.outputDir || join(this.projectRoot, this.docsPath, 'analysis');\n    this.verbose = options.verbose || false;\n    this.maxAgents = options.maxAgents || 5;\n    this.agentMode = options.agentMode || 'adaptive';\n    // Default timeout of 60 seconds (configurable via agentTimeout option)\n    this.agentTimeout = options.agentTimeout || 60000;\n  }\n\n  /**\n   * Check if claude-flow is available\n   */\n  async isAvailable(): Promise<boolean> {\n    try {\n      // SECURITY: execFileSync does not spawn a shell by default, preventing shell injection\n      // Using npx with explicit arguments avoids shell metacharacter interpretation\n      execFileSync('npx', ['claude-flow@alpha', '--version'], {\n        stdio: 'pipe',\n        timeout: 5000,\n        windowsHide: true,\n      });\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Run deep analysis\n   */\n  async analyze(): Promise<DeepAnalysisResult> {\n    const startTime = Date.now();\n\n    const result: DeepAnalysisResult = {\n      success: false,\n      agentsSpawned: 0,\n      insightsCount: 0,\n      documentsCreated: 0,\n      results: [],\n      duration: 0,\n      errors: [],\n    };\n\n    // Check availability\n    if (!(await this.isAvailable())) {\n      result.errors.push('claude-flow is not available');\n      result.duration = Date.now() - startTime;\n      return result;\n    }\n\n    // Ensure output directory exists\n    if (!existsSync(this.outputDir)) {\n      mkdirSync(this.outputDir, { recursive: true });\n    }\n\n    // Define agents\n    const agents: AgentConfig[] = [\n      {\n        name: 'Pattern Researcher',\n        type: 'researcher',\n        task: 'Analyze codebase architecture, patterns, and design decisions',\n        outputFile: 'architecture-patterns.md',\n      },\n      {\n        name: 'Code Analyst',\n        type: 'analyst',\n        task: 'Identify code quality issues, complexity hotspots, and improvement opportunities',\n        outputFile: 'code-analysis.md',\n      },\n      {\n        name: 'Implementation Reviewer',\n        type: 'coder',\n        task: 'Review implementation patterns, naming conventions, and code style',\n        outputFile: 'implementation-review.md',\n      },\n      {\n        name: 'Test Analyzer',\n        type: 'tester',\n        task: 'Analyze test coverage, testing patterns, and testing gaps',\n        outputFile: 'testing-analysis.md',\n      },\n    ];\n\n    logger.info('Starting deep analysis', { agents: agents.length, mode: this.agentMode });\n\n    // Execute agents based on mode\n    if (this.agentMode === 'parallel') {\n      result.results = await this.executeParallel(agents);\n    } else if (this.agentMode === 'sequential') {\n      result.results = await this.executeSequential(agents);\n    } else {\n      // Adaptive: start with 2, scale based on success\n      result.results = await this.executeAdaptive(agents);\n    }\n\n    // Calculate totals\n    result.agentsSpawned = result.results.length;\n    result.insightsCount = result.results.reduce((sum, r) => sum + r.insights.length, 0);\n    result.documentsCreated = result.results.reduce((sum, r) => sum + r.documents.length, 0);\n    result.success = result.results.every(r => r.success);\n    result.duration = Date.now() - startTime;\n\n    // Collect errors\n    for (const agentResult of result.results) {\n      if (agentResult.error) {\n        result.errors.push(`${agentResult.name}: ${agentResult.error}`);\n      }\n    }\n\n    logger.info('Deep analysis complete', {\n      success: result.success,\n      insights: result.insightsCount,\n      documents: result.documentsCreated,\n      duration: result.duration,\n    });\n\n    return result;\n  }\n\n  /**\n   * Execute agents in parallel\n   */\n  private async executeParallel(agents: AgentConfig[]): Promise<AgentResult[]> {\n    const promises = agents.map(agent => this.executeAgent(agent));\n    return Promise.all(promises);\n  }\n\n  /**\n   * Execute agents sequentially\n   */\n  private async executeSequential(agents: AgentConfig[]): Promise<AgentResult[]> {\n    const results: AgentResult[] = [];\n    for (const agent of agents) {\n      results.push(await this.executeAgent(agent));\n    }\n    return results;\n  }\n\n  /**\n   * Execute agents adaptively (start with 2, scale based on success)\n   */\n  private async executeAdaptive(agents: AgentConfig[]): Promise<AgentResult[]> {\n    const results: AgentResult[] = [];\n\n    // First batch: 2 agents\n    const firstBatch = agents.slice(0, 2);\n    const firstResults = await Promise.all(firstBatch.map(a => this.executeAgent(a)));\n    results.push(...firstResults);\n\n    // Check success rate\n    const successRate = firstResults.filter(r => r.success).length / firstResults.length;\n\n    if (successRate >= 0.5 && agents.length > 2) {\n      // Continue with remaining agents in parallel\n      const remaining = agents.slice(2);\n      const remainingResults = await Promise.all(remaining.map(a => this.executeAgent(a)));\n      results.push(...remainingResults);\n    } else if (agents.length > 2) {\n      // Fall back to sequential\n      logger.warn('Low success rate, switching to sequential mode');\n      for (const agent of agents.slice(2)) {\n        results.push(await this.executeAgent(agent));\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Execute a single agent\n   */\n  private async executeAgent(agent: AgentConfig): Promise<AgentResult> {\n    const startTime = Date.now();\n    const outputPath = join(this.outputDir, agent.outputFile);\n\n    const result: AgentResult = {\n      name: agent.name,\n      type: agent.type,\n      success: false,\n      insights: [],\n      documents: [],\n      duration: 0,\n    };\n\n    try {\n      logger.info(`Spawning agent: ${agent.name}`, { type: agent.type });\n\n      const prompt = this.buildPrompt(agent);\n\n      // Execute claude-flow agent\n      const output = await this.runClaudeFlowAgent(agent.type, prompt);\n\n      // Parse output for insights\n      result.insights = this.extractInsights(output);\n\n      // Write output to file\n      writeFileSync(outputPath, this.formatOutput(agent, output));\n      result.documents.push({ path: outputPath, title: agent.name });\n\n      result.success = true;\n\n      if (this.verbose) {\n        logger.debug(`Agent completed: ${agent.name}`, { insights: result.insights.length });\n      }\n    } catch (error) {\n      result.error = error instanceof Error ? error.message : String(error);\n      logger.error(`Agent failed: ${agent.name}`, error instanceof Error ? error : new Error(String(error)));\n    }\n\n    result.duration = Date.now() - startTime;\n    return result;\n  }\n\n  /**\n   * Build prompt for agent\n   */\n  private buildPrompt(agent: AgentConfig): string {\n    return `You are a ${agent.name} analyzing the project at ${this.projectRoot}.\n\n**OBJECTIVE**: ${agent.task}\n\n**COORDINATION PROTOCOL**:\n\\`\\`\\`bash\nnpx claude-flow@alpha hooks pre-task --description \"${agent.task}\"\n\\`\\`\\`\n\n**YOUR TASKS**:\n1. Analyze the codebase at ${this.projectRoot}\n2. Identify key patterns and conventions\n3. Document your findings with specific examples\n4. Provide actionable recommendations\n5. Generate comprehensive markdown documentation\n\n**OUTPUT REQUIREMENTS**:\n- Use clear markdown formatting\n- Include code examples from the project\n- Organize findings by category\n- Prioritize actionable insights\n\nAfter completing:\n\\`\\`\\`bash\nnpx claude-flow@alpha hooks post-task --task-id \"${agent.type}-analysis\"\n\\`\\`\\`\n`;\n  }\n\n  /**\n   * Run claude-flow agent\n   */\n  private async runClaudeFlowAgent(type: string, prompt: string): Promise<string> {\n    // Security: Validate agent type against allowlist to prevent command injection\n    if (!VALID_AGENT_TYPES.has(type)) {\n      throw new Error(`Invalid agent type: ${type}. Valid types: ${[...VALID_AGENT_TYPES].join(', ')}`);\n    }\n\n    // Security: Sanitize prompt to prevent injection via shell metacharacters\n    const sanitizedPrompt = prompt.replace(/[`$\\\\]/g, '');\n\n    return new Promise((resolve, reject) => {\n      const args = ['claude-flow@alpha', 'agent', 'execute', type, sanitizedPrompt, '--json'];\n\n      const proc = spawn('npx', args, {\n        cwd: this.projectRoot,\n        shell: false, // Security: Disable shell to prevent command injection\n        timeout: this.agentTimeout,\n      });\n\n      let stdout = '';\n      let stderr = '';\n\n      proc.stdout?.on('data', (data) => {\n        stdout += data.toString();\n      });\n\n      proc.stderr?.on('data', (data) => {\n        stderr += data.toString();\n      });\n\n      proc.on('close', (code) => {\n        if (code === 0) {\n          resolve(stdout);\n        } else {\n          reject(new Error(stderr || `Agent exited with code ${code}`));\n        }\n      });\n\n      proc.on('error', (error) => {\n        reject(error);\n      });\n    });\n  }\n\n  /**\n   * Extract insights from agent output\n   */\n  private extractInsights(output: string): string[] {\n    const insights: string[] = [];\n\n    // Look for patterns like \"- Insight:\" or \"## Finding:\"\n    const patterns = [\n      /[-*]\\s*(?:insight|finding|observation|recommendation):\\s*(.+)/gi,\n      /##\\s*(?:insight|finding|observation|recommendation):\\s*(.+)/gi,\n      /(?:key\\s+)?(?:insight|finding|observation|recommendation):\\s*(.+)/gi,\n    ];\n\n    for (const pattern of patterns) {\n      const matches = output.matchAll(pattern);\n      for (const match of matches) {\n        if (match[1]) {\n          insights.push(match[1].trim());\n        }\n      }\n    }\n\n    // Deduplicate\n    return [...new Set(insights)];\n  }\n\n  /**\n   * Format output for documentation\n   */\n  private formatOutput(agent: AgentConfig, output: string): string {\n    const timestamp = new Date().toISOString();\n\n    return `---\ntitle: \"${agent.name} Analysis\"\ntype: analysis\ngenerator: deep-analyzer\nagent: ${agent.type}\ncreated: ${timestamp}\n---\n\n# ${agent.name} Analysis\n\n> Generated by DeepAnalyzer using claude-flow\n\n## Overview\n\n${agent.task}\n\n## Analysis\n\n${output}\n\n---\n\n*Generated on ${new Date().toLocaleString()}*\n`;\n  }\n}\n\n/**\n * Create a deep analyzer instance\n */\nexport function createDeepAnalyzer(options: DeepAnalyzerOptions): DeepAnalyzer {\n  return new DeepAnalyzer(options);\n}\n\n/**\n * Run deep analysis on a project\n */\nexport async function analyzeDeep(\n  projectRoot: string,\n  docsPath?: string\n): Promise<DeepAnalysisResult> {\n  const analyzer = new DeepAnalyzer({ projectRoot, docsPath });\n  return analyzer.analyze();\n}\n"],"names":["resolve"],"mappings":"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"}