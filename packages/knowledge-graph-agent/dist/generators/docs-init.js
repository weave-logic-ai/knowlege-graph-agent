import { existsSync, mkdirSync, writeFileSync, readFileSync } from "fs";
import { join, basename } from "path";
import Handlebars from "handlebars";
const DEFAULT_STRUCTURE = {
  directories: [
    // Core concepts
    "concepts",
    "concepts/architecture",
    "concepts/patterns",
    // Components
    "components",
    "components/ui",
    "components/utilities",
    // Services
    "services",
    "services/api",
    "services/workers",
    // Features
    "features",
    "features/core",
    "features/advanced",
    // Integrations
    "integrations",
    "integrations/databases",
    "integrations/auth-providers",
    "integrations/storage",
    "integrations/monitoring",
    // Standards
    "standards",
    "standards/coding-standards",
    "standards/programming-languages",
    "standards/build-tools",
    // Guides
    "guides",
    "guides/getting-started",
    "guides/testing",
    "guides/deployment",
    // References
    "references",
    "references/api",
    "references/cli",
    // Meta
    "_templates",
    "_attachments"
  ],
  files: {
    "README.md": "readme",
    "PRIMITIVES.md": "primitives",
    "MOC.md": "moc",
    "_templates/concept.md": "template-concept",
    "_templates/technical.md": "template-technical",
    "_templates/feature.md": "template-feature",
    "_templates/service.md": "template-service",
    "_templates/guide.md": "template-guide"
  }
};
const TEMPLATES = {
  readme: `# {{projectName}} Documentation

Welcome to the {{projectName}} knowledge base.

## Quick Navigation

- [[MOC|Map of Content]] - Overview of all documentation
- [[PRIMITIVES|Primitives]] - Core building blocks and technologies

## Structure

This documentation follows the Weave-NN knowledge graph methodology:

\`\`\`
docs/
├── concepts/       # Abstract concepts and ideas
├── components/     # Reusable components and utilities
├── services/       # Backend services and APIs
├── features/       # Product features and capabilities
├── integrations/   # External integrations
├── standards/      # Coding standards and conventions
├── guides/         # How-to guides and tutorials
└── references/     # API and CLI references
\`\`\`

## Getting Started

1. Browse the [[MOC|Map of Content]] for an overview
2. Check [[PRIMITIVES]] for technology decisions
3. Read [[guides/getting-started/index|Getting Started Guide]]

---
*Generated by @weave-nn/knowledge-graph-agent*
`,
  primitives: `# Primitives

Core building blocks and technology decisions for {{projectName}}.

## Overview

Primitives are the foundational technologies that power this project. Each primitive represents a key technology choice with its rationale and usage patterns.

## Categories

### Languages
{{#each languages}}
- [[standards/programming-languages/{{this}}|{{this}}]]
{{/each}}

### Frameworks
{{#each frameworks}}
- [[{{category}}/{{slug}}|{{name}}]]
{{/each}}

### Key Dependencies
{{#each dependencies}}
- [[{{category}}/{{slug}}|{{name}}]] - {{description}}
{{/each}}

## Technology Decisions

| Category | Choice | Rationale |
|----------|--------|-----------|
| Runtime | Node.js | Modern JavaScript runtime |
| Language | TypeScript | Type safety and DX |
| Package Manager | npm/bun | Fast, reliable |

---
*Generated by @weave-nn/knowledge-graph-agent*
`,
  moc: `# Map of Content

Central navigation hub for {{projectName}} documentation.

## Core Concepts
{{#each concepts}}
- [[concepts/{{this}}]]
{{/each}}
{{#unless concepts}}
- *No concepts documented yet*
{{/unless}}

## Components
{{#each components}}
- [[components/{{this}}]]
{{/each}}
{{#unless components}}
- *No components documented yet*
{{/unless}}

## Services
{{#each services}}
- [[services/{{this}}]]
{{/each}}
{{#unless services}}
- *No services documented yet*
{{/unless}}

## Features
{{#each features}}
- [[features/{{this}}]]
{{/each}}
{{#unless features}}
- *No features documented yet*
{{/unless}}

## Guides
- [[guides/getting-started/index|Getting Started]]
- [[guides/testing/index|Testing Guide]]
- [[guides/deployment/index|Deployment Guide]]

## References
- [[references/api/index|API Reference]]
- [[references/cli/index|CLI Reference]]

---
*Last updated: {{date}}*
`,
  "template-concept": `---
title: {{title}}
type: concept
status: draft
tags: [concept]
created: {{date}}
updated: {{date}}
---

# {{title}}

## Overview

Brief description of this concept.

## Key Ideas

- Point 1
- Point 2
- Point 3

## Related Concepts

- [[related-concept-1]]
- [[related-concept-2]]

## References

- External reference 1
- External reference 2
`,
  "template-technical": `---
title: {{title}}
type: technical
status: draft
tags: [technical]
created: {{date}}
updated: {{date}}
---

# {{title}}

## Overview

Brief description of this technical component.

## Implementation

\`\`\`typescript
// Code example
\`\`\`

## Usage

How to use this component.

## Configuration

Available configuration options.

## Related

- [[related-technical-1]]
`,
  "template-feature": `---
title: {{title}}
type: feature
status: draft
tags: [feature]
created: {{date}}
updated: {{date}}
---

# {{title}}

## Overview

Brief description of this feature.

## User Story

As a [user type], I want [goal] so that [benefit].

## Acceptance Criteria

- [ ] Criterion 1
- [ ] Criterion 2
- [ ] Criterion 3

## Technical Implementation

How this feature is implemented.

## Related Features

- [[related-feature-1]]
`,
  "template-service": `---
title: {{title}}
type: service
status: draft
tags: [service, api]
created: {{date}}
updated: {{date}}
---

# {{title}}

## Overview

Brief description of this service.

## Endpoints

| Method | Path | Description |
|--------|------|-------------|
| GET | /api/... | Description |
| POST | /api/... | Description |

## Configuration

Environment variables and configuration options.

## Dependencies

- [[dependency-1]]
- [[dependency-2]]

## Deployment

Deployment instructions.
`,
  "template-guide": `---
title: {{title}}
type: guide
status: draft
tags: [guide, tutorial]
created: {{date}}
updated: {{date}}
---

# {{title}}

## Prerequisites

- Prerequisite 1
- Prerequisite 2

## Steps

### Step 1: Title

Instructions for step 1.

### Step 2: Title

Instructions for step 2.

### Step 3: Title

Instructions for step 3.

## Troubleshooting

Common issues and solutions.

## Next Steps

- [[next-guide-1]]
- [[next-guide-2]]
`
};
async function initDocs(options) {
  const result = {
    success: true,
    docsPath: "",
    filesCreated: [],
    errors: []
  };
  try {
    const { projectRoot, docsPath = "docs", includeExamples = true, detectFramework = true } = options;
    const fullDocsPath = join(projectRoot, docsPath);
    result.docsPath = fullDocsPath;
    const projectName = await detectProjectName(projectRoot);
    const frameworks = detectFramework ? await detectFrameworks(projectRoot) : [];
    const languages = detectFramework ? await detectLanguages(projectRoot) : [];
    const dependencies = detectFramework ? await detectDependencies(projectRoot) : [];
    const context = {
      projectName,
      date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
      frameworks,
      languages,
      dependencies,
      concepts: [],
      components: [],
      services: [],
      features: []
    };
    for (const dir of DEFAULT_STRUCTURE.directories) {
      const dirPath = join(fullDocsPath, dir);
      if (!existsSync(dirPath)) {
        mkdirSync(dirPath, { recursive: true });
        result.filesCreated.push(dirPath);
      }
    }
    for (const [filePath, templateName] of Object.entries(DEFAULT_STRUCTURE.files)) {
      const fullPath = join(fullDocsPath, filePath);
      if (existsSync(fullPath)) {
        continue;
      }
      const template = TEMPLATES[templateName];
      if (!template) {
        result.errors.push(`Template not found: ${templateName}`);
        continue;
      }
      try {
        const compiled = Handlebars.compile(template);
        const content = compiled(context);
        writeFileSync(fullPath, content, "utf-8");
        result.filesCreated.push(fullPath);
      } catch (error) {
        result.errors.push(`Failed to create ${filePath}: ${error}`);
      }
    }
    if (includeExamples) {
      await createExampleFiles(fullDocsPath, context, result);
    }
    const obsidianPath = join(fullDocsPath, ".obsidian");
    if (!existsSync(obsidianPath)) {
      mkdirSync(obsidianPath, { recursive: true });
      const appJson = {
        "legacyEditor": false,
        "livePreview": true
      };
      writeFileSync(join(obsidianPath, "app.json"), JSON.stringify(appJson, null, 2));
      result.filesCreated.push(obsidianPath);
    }
    result.success = result.errors.length === 0;
  } catch (error) {
    result.success = false;
    result.errors.push(`Init failed: ${error}`);
  }
  return result;
}
async function detectProjectName(projectRoot) {
  try {
    const pkgPath = join(projectRoot, "package.json");
    if (existsSync(pkgPath)) {
      const pkg = JSON.parse(readFileSync(pkgPath, "utf-8"));
      if (pkg.name) {
        return pkg.name.replace(/^@[^/]+\//, "");
      }
    }
  } catch {
  }
  return basename(projectRoot);
}
async function detectFrameworks(projectRoot) {
  const frameworks = [];
  try {
    const pkgPath = join(projectRoot, "package.json");
    if (existsSync(pkgPath)) {
      const pkg = JSON.parse(readFileSync(pkgPath, "utf-8"));
      const deps = { ...pkg.dependencies, ...pkg.devDependencies };
      const patterns = [
        { name: "React", packages: ["react"], category: "components/ui" },
        { name: "Next.js", packages: ["next"], category: "services/api" },
        { name: "Vue", packages: ["vue"], category: "components/ui" },
        { name: "Express", packages: ["express"], category: "services/api" },
        { name: "Fastify", packages: ["fastify"], category: "services/api" },
        { name: "Prisma", packages: ["@prisma/client", "prisma"], category: "integrations/databases" },
        { name: "TypeORM", packages: ["typeorm"], category: "integrations/databases" },
        { name: "Jest", packages: ["jest"], category: "guides/testing" },
        { name: "Vitest", packages: ["vitest"], category: "guides/testing" },
        { name: "Vite", packages: ["vite"], category: "standards/build-tools" },
        { name: "Webpack", packages: ["webpack"], category: "standards/build-tools" }
      ];
      for (const pattern of patterns) {
        for (const pkg2 of pattern.packages) {
          if (deps[pkg2]) {
            frameworks.push({
              name: pattern.name,
              slug: pattern.name.toLowerCase().replace(/[^a-z0-9]+/g, "-"),
              category: pattern.category,
              version: deps[pkg2]
            });
            break;
          }
        }
      }
    }
  } catch {
  }
  return frameworks;
}
async function detectLanguages(projectRoot) {
  const languages = /* @__PURE__ */ new Set();
  try {
    if (existsSync(join(projectRoot, "tsconfig.json"))) {
      languages.add("typescript");
    }
    if (existsSync(join(projectRoot, "package.json"))) {
      languages.add("javascript");
    }
    if (existsSync(join(projectRoot, "requirements.txt")) || existsSync(join(projectRoot, "pyproject.toml"))) {
      languages.add("python");
    }
    if (existsSync(join(projectRoot, "Cargo.toml"))) {
      languages.add("rust");
    }
    if (existsSync(join(projectRoot, "go.mod"))) {
      languages.add("go");
    }
  } catch {
  }
  return Array.from(languages);
}
async function detectDependencies(projectRoot) {
  const deps = [];
  try {
    const pkgPath = join(projectRoot, "package.json");
    if (existsSync(pkgPath)) {
      const pkg = JSON.parse(readFileSync(pkgPath, "utf-8"));
      const allDeps = { ...pkg.dependencies };
      const topDeps = Object.keys(allDeps).slice(0, 10);
      for (const dep of topDeps) {
        deps.push({
          name: dep,
          slug: dep.replace(/^@/, "").replace(/[^a-z0-9]+/g, "-"),
          category: "components/utilities",
          description: `Version ${allDeps[dep]}`
        });
      }
    }
  } catch {
  }
  return deps;
}
async function createExampleFiles(docsPath, context, result) {
  const examples = [
    {
      path: "guides/getting-started/index.md",
      content: `---
title: Getting Started
type: guide
status: active
tags: [guide, getting-started]
created: ${context.date}
updated: ${context.date}
---

# Getting Started with ${context.projectName}

Welcome! This guide will help you get up and running.

## Prerequisites

- Node.js 20+
- npm or bun

## Installation

\`\`\`bash
npm install
\`\`\`

## Quick Start

1. Clone the repository
2. Install dependencies
3. Run the development server

## Next Steps

- Explore the [[MOC|Map of Content]]
- Review [[PRIMITIVES|Technology Primitives]]
`
    },
    {
      path: "concepts/architecture/index.md",
      content: `---
title: Architecture Overview
type: concept
status: active
tags: [architecture, concept]
created: ${context.date}
updated: ${context.date}
---

# Architecture Overview

High-level architecture of ${context.projectName}.

## System Diagram

\`\`\`
┌──────────────┐     ┌──────────────┐
│   Frontend   │────▶│   Backend    │
└──────────────┘     └──────────────┘
                            │
                     ┌──────▼──────┐
                     │   Database  │
                     └─────────────┘
\`\`\`

## Key Components

- **Frontend**: User interface
- **Backend**: API and business logic
- **Database**: Data persistence

## Design Principles

1. Separation of concerns
2. Single responsibility
3. Dependency injection
`
    }
  ];
  for (const example of examples) {
    const fullPath = join(docsPath, example.path);
    if (!existsSync(fullPath)) {
      const dir = join(fullPath, "..");
      if (!existsSync(dir)) {
        mkdirSync(dir, { recursive: true });
      }
      writeFileSync(fullPath, example.content, "utf-8");
      result.filesCreated.push(fullPath);
    }
  }
}
function docsExist(projectRoot, docsPath = "docs") {
  return existsSync(join(projectRoot, docsPath));
}
function getDocsPath(projectRoot) {
  const possiblePaths = ["docs", "documentation", "doc", "wiki"];
  for (const path of possiblePaths) {
    const fullPath = join(projectRoot, path);
    if (existsSync(fullPath)) {
      return fullPath;
    }
  }
  return null;
}
export {
  docsExist,
  getDocsPath,
  initDocs
};
//# sourceMappingURL=docs-init.js.map
