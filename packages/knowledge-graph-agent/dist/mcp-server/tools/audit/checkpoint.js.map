{"version":3,"file":"checkpoint.js","sources":["../../../../src/mcp-server/tools/audit/checkpoint.ts"],"sourcesContent":["/**\n * Audit Checkpoint Tool\n *\n * MCP tool for creating checkpoints in the audit chain.\n * Checkpoints provide periodic state snapshots for efficient\n * verification and sync recovery.\n *\n * @module mcp-server/tools/audit/checkpoint\n */\n\nimport type { Tool } from '@modelcontextprotocol/sdk/types.js';\nimport type { ToolHandler, ToolResult } from '../../types/index.js';\nimport type { AuditChain } from '../../../audit/services/audit-chain.js';\n\n/**\n * Audit checkpoint tool definition\n *\n * Creates a checkpoint in the audit chain with optional\n * name and tags for identification.\n */\nexport const auditCheckpointTool: Tool = {\n  name: 'kg_audit_checkpoint',\n  description: 'Create a checkpoint in the audit chain. Checkpoints provide periodic state snapshots for efficient verification and sync recovery points.',\n  inputSchema: {\n    type: 'object' as const,\n    properties: {\n      name: {\n        type: 'string',\n        description: 'Optional name for the checkpoint (for reference purposes)',\n      },\n      tags: {\n        type: 'array',\n        description: 'Optional tags for categorizing the checkpoint',\n        items: {\n          type: 'string',\n        },\n      },\n    },\n  },\n};\n\n/**\n * Parameters for the audit checkpoint tool\n */\nexport interface AuditCheckpointParams {\n  /** Optional checkpoint name */\n  name?: string;\n  /** Optional tags for the checkpoint */\n  tags?: string[];\n}\n\n/**\n * Create audit checkpoint handler\n *\n * Factory function that creates a tool handler for checkpoint creation.\n *\n * @param auditChain - The audit chain instance\n * @returns Tool handler function\n *\n * @example\n * ```typescript\n * const auditChain = createAuditChain({ agentDid: 'did:exo:agent-1' });\n * const handler = createAuditCheckpointHandler(auditChain);\n *\n * const result = await handler({\n *   name: 'pre-migration',\n *   tags: ['migration', 'backup']\n * });\n * ```\n */\nexport function createAuditCheckpointHandler(auditChain?: AuditChain): ToolHandler {\n  return async (params: Record<string, unknown>): Promise<ToolResult> => {\n    const startTime = Date.now();\n    const { name, tags } = params as AuditCheckpointParams;\n\n    try {\n      // Check audit chain availability\n      if (!auditChain) {\n        return {\n          success: false,\n          error: 'Audit chain not initialized. The exochain audit system is not available.',\n          metadata: { executionTime: Date.now() - startTime },\n        };\n      }\n\n      // Get current stats before checkpoint\n      const statsBefore = auditChain.getStats();\n      const previousCheckpoint = auditChain.getLatestCheckpoint();\n\n      // Create checkpoint\n      const checkpoint = await auditChain.createCheckpoint();\n\n      // Get stats after checkpoint\n      const statsAfter = auditChain.getStats();\n\n      // Format response\n      const checkpointData = {\n        height: checkpoint.height,\n        eventRoot: checkpoint.eventRoot,\n        stateRoot: checkpoint.stateRoot,\n        timestamp: checkpoint.timestamp.toISOString(),\n        validatorCount: checkpoint.validatorSignatures.length,\n        metadata: {\n          name: name || null,\n          tags: tags || [],\n        },\n        stats: {\n          totalEventsAtCheckpoint: statsAfter.totalEvents,\n          eventsSincePreviousCheckpoint: previousCheckpoint\n            ? statsAfter.totalEvents - statsBefore.totalEvents\n            : statsAfter.totalEvents,\n          previousCheckpointHeight: previousCheckpoint?.height ?? null,\n        },\n      };\n\n      return {\n        success: true,\n        data: checkpointData,\n        metadata: {\n          executionTime: Date.now() - startTime,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: { executionTime: Date.now() - startTime },\n      };\n    }\n  };\n}\n\n/**\n * Get the latest checkpoint from the audit chain\n *\n * Utility function to retrieve the most recent checkpoint.\n *\n * @param auditChain - The audit chain instance\n * @returns The latest checkpoint or null if none exist\n */\nexport function getLatestCheckpoint(auditChain: AuditChain) {\n  return auditChain.getLatestCheckpoint();\n}\n"],"names":[],"mappings":"AAoBO,MAAM,sBAA4B;AAAA,EACvC,MAAM;AAAA,EACN,aAAa;AAAA,EACb,aAAa;AAAA,IACX,MAAM;AAAA,IACN,YAAY;AAAA,MACV,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,MAAA;AAAA,MAEf,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,QACb,OAAO;AAAA,UACL,MAAM;AAAA,QAAA;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEJ;AA+BO,SAAS,6BAA6B,YAAsC;AACjF,SAAO,OAAO,WAAyD;AACrE,UAAM,YAAY,KAAK,IAAA;AACvB,UAAM,EAAE,MAAM,KAAA,IAAS;AAEvB,QAAI;AAEF,UAAI,CAAC,YAAY;AACf,eAAO;AAAA,UACL,SAAS;AAAA,UACT,OAAO;AAAA,UACP,UAAU,EAAE,eAAe,KAAK,IAAA,IAAQ,UAAA;AAAA,QAAU;AAAA,MAEtD;AAGA,YAAM,cAAc,WAAW,SAAA;AAC/B,YAAM,qBAAqB,WAAW,oBAAA;AAGtC,YAAM,aAAa,MAAM,WAAW,iBAAA;AAGpC,YAAM,aAAa,WAAW,SAAA;AAG9B,YAAM,iBAAiB;AAAA,QACrB,QAAQ,WAAW;AAAA,QACnB,WAAW,WAAW;AAAA,QACtB,WAAW,WAAW;AAAA,QACtB,WAAW,WAAW,UAAU,YAAA;AAAA,QAChC,gBAAgB,WAAW,oBAAoB;AAAA,QAC/C,UAAU;AAAA,UACR,MAAM,QAAQ;AAAA,UACd,MAAM,QAAQ,CAAA;AAAA,QAAC;AAAA,QAEjB,OAAO;AAAA,UACL,yBAAyB,WAAW;AAAA,UACpC,+BAA+B,qBAC3B,WAAW,cAAc,YAAY,cACrC,WAAW;AAAA,UACf,0BAA0B,oBAAoB,UAAU;AAAA,QAAA;AAAA,MAC1D;AAGF,aAAO;AAAA,QACL,SAAS;AAAA,QACT,MAAM;AAAA,QACN,UAAU;AAAA,UACR,eAAe,KAAK,QAAQ;AAAA,QAAA;AAAA,MAC9B;AAAA,IAEJ,SAAS,OAAO;AACd,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,QAC5D,UAAU,EAAE,eAAe,KAAK,IAAA,IAAQ,UAAA;AAAA,MAAU;AAAA,IAEtD;AAAA,EACF;AACF;"}