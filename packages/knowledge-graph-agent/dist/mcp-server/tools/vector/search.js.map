{"version":3,"file":"search.js","sources":["../../../../src/mcp-server/tools/vector/search.ts"],"sourcesContent":["/**\n * Vector Search Tool\n *\n * MCP tool for semantic vector search in the knowledge graph.\n * Supports both pure vector similarity search and hybrid search\n * combining vector similarity with keyword matching.\n *\n * @module mcp-server/tools/vector/search\n */\n\nimport type { Tool } from '@modelcontextprotocol/sdk/types.js';\nimport type { ToolHandler, ToolResult } from '../../types/index.js';\nimport type { EnhancedVectorStore } from '../../../vector/services/vector-store.js';\nimport type { SearchResult, HybridSearchResult } from '../../../vector/types.js';\n\n/**\n * Vector search tool definition\n *\n * Provides semantic vector search capabilities with optional hybrid search\n * combining vector similarity with keyword matching.\n */\nexport const vectorSearchTool: Tool = {\n  name: 'kg_vector_search',\n  description:\n    'Perform semantic vector search on the knowledge graph. Supports pure vector similarity search and hybrid search combining vector similarity with keyword matching for more precise results.',\n  inputSchema: {\n    type: 'object' as const,\n    properties: {\n      query: {\n        type: 'string',\n        description:\n          'Search query string. Will be converted to an embedding vector for similarity search.',\n      },\n      k: {\n        type: 'number',\n        description: 'Number of results to return (default: 10, max: 100)',\n        default: 10,\n        minimum: 1,\n        maximum: 100,\n      },\n      type: {\n        type: 'string',\n        description: 'Filter results by node type',\n        enum: [\n          'concept',\n          'technical',\n          'feature',\n          'primitive',\n          'service',\n          'guide',\n          'standard',\n          'integration',\n        ],\n      },\n      hybrid: {\n        type: 'boolean',\n        description:\n          'Enable hybrid search combining vector similarity with keyword matching (default: false)',\n        default: false,\n      },\n      minScore: {\n        type: 'number',\n        description: 'Minimum similarity score threshold (0-1, default: 0)',\n        default: 0,\n        minimum: 0,\n        maximum: 1,\n      },\n      includeVectors: {\n        type: 'boolean',\n        description: 'Include raw vector data in results (default: false)',\n        default: false,\n      },\n      namespace: {\n        type: 'string',\n        description: 'Filter by vector namespace',\n      },\n    },\n    required: ['query'],\n  },\n};\n\n/**\n * Parameters for vector search\n */\ninterface VectorSearchParams {\n  /** Search query string */\n  query: string;\n  /** Number of results to return */\n  k?: number;\n  /** Filter by node type */\n  type?: string;\n  /** Enable hybrid search */\n  hybrid?: boolean;\n  /** Minimum similarity score */\n  minScore?: number;\n  /** Include vectors in results */\n  includeVectors?: boolean;\n  /** Namespace filter */\n  namespace?: string;\n}\n\n/**\n * Simple text-to-vector conversion for demonstration\n *\n * In production, this would call an embedding service (OpenAI, Anthropic, etc.)\n * For now, generates a deterministic pseudo-embedding from text.\n *\n * @param text - Text to convert\n * @param dimensions - Vector dimensions (default: 1536 for OpenAI compatibility)\n * @returns Pseudo-embedding vector\n * @internal\n */\nfunction textToVector(text: string, dimensions: number = 1536): number[] {\n  const vector: number[] = new Array(dimensions).fill(0);\n  const normalized = text.toLowerCase().trim();\n\n  // Generate deterministic values based on character codes\n  for (let i = 0; i < normalized.length; i++) {\n    const charCode = normalized.charCodeAt(i);\n    const idx = (charCode * (i + 1)) % dimensions;\n    vector[idx] += Math.sin(charCode * (i + 1)) * 0.1;\n  }\n\n  // Normalize to unit vector\n  const magnitude = Math.sqrt(vector.reduce((sum, v) => sum + v * v, 0));\n  if (magnitude > 0) {\n    for (let i = 0; i < vector.length; i++) {\n      vector[i] /= magnitude;\n    }\n  }\n\n  return vector;\n}\n\n/**\n * Perform keyword matching for hybrid search\n *\n * Scores results based on keyword overlap with the query.\n *\n * @param query - Search query\n * @param metadata - Result metadata to search\n * @returns Keyword match score (0-1)\n * @internal\n */\nfunction calculateKeywordScore(\n  query: string,\n  metadata: Record<string, unknown>\n): number {\n  const queryTerms = query\n    .toLowerCase()\n    .split(/\\s+/)\n    .filter((t) => t.length > 2);\n  if (queryTerms.length === 0) return 0;\n\n  let matchCount = 0;\n  const searchableFields = ['title', 'content', 'description', 'tags'];\n\n  for (const field of searchableFields) {\n    const value = metadata[field];\n    if (typeof value === 'string') {\n      const fieldLower = value.toLowerCase();\n      for (const term of queryTerms) {\n        if (fieldLower.includes(term)) {\n          matchCount++;\n        }\n      }\n    } else if (Array.isArray(value)) {\n      const fieldValues = value.join(' ').toLowerCase();\n      for (const term of queryTerms) {\n        if (fieldValues.includes(term)) {\n          matchCount++;\n        }\n      }\n    }\n  }\n\n  return Math.min(1, matchCount / (queryTerms.length * searchableFields.length));\n}\n\n/**\n * Create vector search handler\n *\n * Creates a handler function that performs semantic vector search\n * on the knowledge graph. Supports both pure vector search and\n * hybrid search combining vector similarity with keyword matching.\n *\n * @param vectorStore - Vector store instance for search operations\n * @returns Tool handler function\n *\n * @example\n * ```typescript\n * const handler = createVectorSearchHandler(vectorStore);\n * const result = await handler({\n *   query: 'neural network architecture',\n *   k: 10,\n *   hybrid: true,\n * });\n * ```\n */\nexport function createVectorSearchHandler(\n  vectorStore?: EnhancedVectorStore\n): ToolHandler {\n  return async (params: Record<string, unknown>): Promise<ToolResult> => {\n    const startTime = Date.now();\n    const typedParams = params as unknown as VectorSearchParams;\n    const {\n      query,\n      k = 10,\n      type,\n      hybrid = false,\n      minScore = 0,\n      includeVectors = false,\n      namespace,\n    } = typedParams;\n\n    try {\n      // Validate required parameters\n      if (!query || typeof query !== 'string') {\n        return {\n          success: false,\n          error: 'Query parameter is required and must be a string',\n          metadata: { executionTime: Date.now() - startTime },\n        };\n      }\n\n      // Check vector store availability\n      if (!vectorStore) {\n        return {\n          success: false,\n          error: 'Vector store not initialized. Configure vector storage first.',\n          metadata: { executionTime: Date.now() - startTime },\n        };\n      }\n\n      // Ensure vector store is ready\n      if (!vectorStore.isReady()) {\n        await vectorStore.initialize();\n      }\n\n      // Enforce limits\n      const safeK = Math.min(Math.max(1, Number(k) || 10), 100);\n\n      // Convert query to vector\n      const queryVector = textToVector(query, vectorStore.getConfig().index.dimensions);\n\n      // Build filter\n      const filter: Record<string, unknown> = {};\n      if (type && typeof type === 'string') {\n        filter.type = type;\n      }\n      if (namespace && typeof namespace === 'string') {\n        filter.namespace = namespace;\n      }\n\n      let results: SearchResult[] | HybridSearchResult[];\n\n      if (hybrid) {\n        // Hybrid search: combine vector + keyword\n        const hybridResults = await vectorStore.hybridSearch({\n          embedding: queryVector,\n          limit: safeK * 2, // Get extra for re-ranking\n          filters: Object.keys(filter).length > 0 ? filter : undefined,\n          minScore: minScore > 0 ? minScore : undefined,\n          includeVectors,\n          namespace,\n        });\n\n        // Re-rank with keyword scores\n        const reranked = hybridResults.map((result) => {\n          const keywordScore = calculateKeywordScore(query, result.metadata);\n          const combinedScore = result.score * 0.7 + keywordScore * 0.3;\n          return {\n            ...result,\n            keywordScore,\n            combinedScore,\n            source: 'merged' as const,\n          };\n        });\n\n        // Sort by combined score and take top k\n        reranked.sort((a, b) => b.combinedScore - a.combinedScore);\n        results = reranked.slice(0, safeK);\n      } else {\n        // Pure vector search\n        results = await vectorStore.search({\n          vector: queryVector,\n          k: safeK,\n          filter: Object.keys(filter).length > 0 ? filter : undefined,\n          minScore: minScore > 0 ? minScore : undefined,\n        });\n      }\n\n      // Format results\n      const formattedResults = results.map((result) => {\n        const formatted: Record<string, unknown> = {\n          id: result.id,\n          score: Math.round(result.score * 10000) / 10000,\n          metadata: result.metadata,\n        };\n\n        if (includeVectors && result.vector) {\n          formatted.vector = result.vector;\n        }\n\n        // Handle hybrid search results with combined/keyword scores\n        const resultWithScores = result as unknown as Record<string, unknown>;\n        if ('combinedScore' in resultWithScores && typeof resultWithScores.combinedScore === 'number') {\n          formatted.combinedScore = Math.round(resultWithScores.combinedScore * 10000) / 10000;\n        }\n        if ('keywordScore' in resultWithScores && typeof resultWithScores.keywordScore === 'number') {\n          formatted.keywordScore = Math.round(resultWithScores.keywordScore * 10000) / 10000;\n        }\n        if ('source' in result) {\n          formatted.source = (result as HybridSearchResult).source;\n        }\n\n        return formatted;\n      });\n\n      // Get stats for metadata\n      const stats = vectorStore.getStats();\n\n      return {\n        success: true,\n        data: {\n          results: formattedResults,\n          count: formattedResults.length,\n          query,\n          searchMode: hybrid ? 'hybrid' : 'vector',\n          filters: {\n            type: type || null,\n            minScore: minScore || null,\n            namespace: namespace || null,\n          },\n        },\n        metadata: {\n          executionTime: Date.now() - startTime,\n          totalVectors: stats.totalVectors,\n          indexType: stats.indexType,\n          cached: false,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: { executionTime: Date.now() - startTime },\n      };\n    }\n  };\n}\n"],"names":[],"mappings":"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"}