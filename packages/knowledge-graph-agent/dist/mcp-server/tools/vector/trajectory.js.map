{"version":3,"file":"trajectory.js","sources":["../../../../src/mcp-server/tools/vector/trajectory.ts"],"sourcesContent":["/**\n * Trajectory List Tool\n *\n * MCP tool for listing agent trajectories from the trajectory tracker.\n * Provides access to agent operation history for analysis and learning.\n *\n * @module mcp-server/tools/vector/trajectory\n */\n\nimport type { Tool } from '@modelcontextprotocol/sdk/types.js';\nimport type { ToolHandler, ToolResult } from '../../types/index.js';\nimport type { TrajectoryTracker } from '../../../vector/services/trajectory-tracker.js';\nimport type { AgentTrajectory, TrajectoryStep } from '../../../vector/types.js';\n\n/**\n * Trajectory list tool definition\n *\n * Lists agent trajectories with optional filtering by agent ID\n * and control over included detail level.\n */\nexport const trajectoryListTool: Tool = {\n  name: 'kg_trajectory_list',\n  description:\n    'List agent operation trajectories from the trajectory tracker. Trajectories record agent actions for pattern learning and optimization.',\n  inputSchema: {\n    type: 'object' as const,\n    properties: {\n      agentId: {\n        type: 'string',\n        description: 'Filter trajectories by specific agent ID',\n      },\n      limit: {\n        type: 'number',\n        description: 'Maximum number of trajectories to return (default: 20, max: 100)',\n        default: 20,\n        minimum: 1,\n        maximum: 100,\n      },\n      includeSteps: {\n        type: 'boolean',\n        description: 'Include detailed step information for each trajectory (default: false)',\n        default: false,\n      },\n      workflowId: {\n        type: 'string',\n        description: 'Filter trajectories by workflow ID',\n      },\n      successOnly: {\n        type: 'boolean',\n        description: 'Only include successful trajectories (default: false)',\n        default: false,\n      },\n      includeStats: {\n        type: 'boolean',\n        description: 'Include aggregate statistics about trajectories (default: true)',\n        default: true,\n      },\n    },\n  },\n};\n\n/**\n * Parameters for trajectory list\n */\ninterface TrajectoryListParams {\n  /** Filter by agent ID */\n  agentId?: string;\n  /** Maximum results */\n  limit?: number;\n  /** Include step details */\n  includeSteps?: boolean;\n  /** Filter by workflow */\n  workflowId?: string;\n  /** Only successful trajectories */\n  successOnly?: boolean;\n  /** Include statistics */\n  includeStats?: boolean;\n}\n\n/**\n * Format a trajectory step for output\n *\n * Formats step data for API response, including duration formatting.\n *\n * @param step - Trajectory step to format\n * @returns Formatted step object\n * @internal\n */\nfunction formatStep(step: TrajectoryStep): Record<string, unknown> {\n  return {\n    action: step.action,\n    outcome: step.outcome,\n    duration: step.duration,\n    durationFormatted: formatDuration(step.duration),\n    timestamp: step.timestamp.toISOString(),\n    state: step.state,\n    ...(step.metadata ? { metadata: step.metadata } : {}),\n  };\n}\n\n/**\n * Format duration in human-readable form\n *\n * @param ms - Duration in milliseconds\n * @returns Formatted string\n * @internal\n */\nfunction formatDuration(ms: number): string {\n  if (ms < 1000) {\n    return `${ms}ms`;\n  }\n  if (ms < 60000) {\n    return `${(ms / 1000).toFixed(2)}s`;\n  }\n  const minutes = Math.floor(ms / 60000);\n  const seconds = ((ms % 60000) / 1000).toFixed(1);\n  return `${minutes}m ${seconds}s`;\n}\n\n/**\n * Format a trajectory for output\n *\n * Creates a formatted trajectory object suitable for API response.\n *\n * @param trajectory - Trajectory to format\n * @param includeSteps - Whether to include detailed steps\n * @returns Formatted trajectory object\n * @internal\n */\nfunction formatTrajectory(\n  trajectory: AgentTrajectory,\n  includeSteps: boolean\n): Record<string, unknown> {\n  const formatted: Record<string, unknown> = {\n    id: trajectory.id,\n    agentId: trajectory.agentId,\n    success: trajectory.success,\n    stepCount: trajectory.steps.length,\n    totalDuration: trajectory.totalDuration,\n    totalDurationFormatted: formatDuration(trajectory.totalDuration),\n    startedAt: trajectory.startedAt.toISOString(),\n  };\n\n  if (trajectory.workflowId) {\n    formatted.workflowId = trajectory.workflowId;\n  }\n\n  if (trajectory.completedAt) {\n    formatted.completedAt = trajectory.completedAt.toISOString();\n  }\n\n  if (trajectory.metadata && Object.keys(trajectory.metadata).length > 0) {\n    formatted.metadata = trajectory.metadata;\n  }\n\n  if (includeSteps) {\n    formatted.steps = trajectory.steps.map(formatStep);\n  } else {\n    // Include just action summary when steps not requested\n    formatted.actionSummary = trajectory.steps.map((s) => s.action);\n  }\n\n  return formatted;\n}\n\n/**\n * Create trajectory list handler\n *\n * Creates a handler function that lists agent trajectories from the\n * trajectory tracker. Supports filtering and pagination.\n *\n * @param trajectoryTracker - Trajectory tracker instance\n * @returns Tool handler function\n *\n * @example\n * ```typescript\n * const handler = createTrajectoryListHandler(tracker);\n * const result = await handler({\n *   agentId: 'researcher-1',\n *   limit: 10,\n *   includeSteps: true,\n * });\n * ```\n */\nexport function createTrajectoryListHandler(\n  trajectoryTracker?: TrajectoryTracker\n): ToolHandler {\n  return async (params: Record<string, unknown>): Promise<ToolResult> => {\n    const startTime = Date.now();\n    const {\n      agentId,\n      limit = 20,\n      includeSteps = false,\n      workflowId,\n      successOnly = false,\n      includeStats = true,\n    } = params as TrajectoryListParams;\n\n    try {\n      // Check trajectory tracker availability\n      if (!trajectoryTracker) {\n        return {\n          success: false,\n          error: 'Trajectory tracker not initialized. Configure trajectory tracking first.',\n          metadata: { executionTime: Date.now() - startTime },\n        };\n      }\n\n      // Enforce limits\n      const safeLimit = Math.min(Math.max(1, Number(limit) || 20), 100);\n\n      // Get trajectories based on filters\n      let trajectories: AgentTrajectory[];\n\n      if (agentId && typeof agentId === 'string') {\n        trajectories = trajectoryTracker.getAgentTrajectories(agentId);\n      } else if (workflowId && typeof workflowId === 'string') {\n        trajectories = trajectoryTracker.getWorkflowTrajectories(workflowId);\n      } else {\n        // Get all trajectories via stats (no direct getAllTrajectories method)\n        // Use export to get all trajectories\n        const exported = trajectoryTracker.export();\n        trajectories = exported.trajectories;\n      }\n\n      // Apply success filter\n      if (successOnly) {\n        trajectories = trajectories.filter((t) => t.success);\n      }\n\n      // Sort by start time (most recent first)\n      trajectories.sort(\n        (a, b) => b.startedAt.getTime() - a.startedAt.getTime()\n      );\n\n      // Apply limit\n      trajectories = trajectories.slice(0, safeLimit);\n\n      // Format trajectories\n      const formattedTrajectories = trajectories.map((t) =>\n        formatTrajectory(t, includeSteps)\n      );\n\n      // Build response data\n      const responseData: Record<string, unknown> = {\n        trajectories: formattedTrajectories,\n        count: formattedTrajectories.length,\n        filters: {\n          agentId: agentId || null,\n          workflowId: workflowId || null,\n          successOnly,\n        },\n      };\n\n      // Include stats if requested\n      if (includeStats) {\n        const stats = trajectoryTracker.getStats();\n        responseData.stats = {\n          totalTrajectories: stats.completedTrajectories,\n          activeTrajectories: stats.activeTrajectories,\n          successRate: Math.round(stats.successRate * 10000) / 100, // percentage\n          avgDuration: Math.round(stats.avgDuration),\n          avgDurationFormatted: formatDuration(Math.round(stats.avgDuration)),\n          detectedPatterns: stats.detectedPatterns,\n          learningRecords: stats.learningRecords,\n        };\n      }\n\n      return {\n        success: true,\n        data: responseData,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          includeSteps,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: { executionTime: Date.now() - startTime },\n      };\n    }\n  };\n}\n"],"names":[],"mappings":"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"}