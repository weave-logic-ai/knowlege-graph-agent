{"version":3,"file":"claude-flow-memory-client.js","sources":["../../../src/mcp/clients/claude-flow-memory-client.ts"],"sourcesContent":["/**\n * Claude-Flow Memory Client\n *\n * High-level memory client that wraps McpClientAdapter with\n * knowledge-graph-specific functionality and type safety.\n *\n * @module mcp/clients/claude-flow-memory-client\n */\n\nimport { createLogger } from '../../utils/index.js';\nimport { McpClientAdapter, createMcpClientAdapter, type McpClientConfig } from './mcp-client-adapter.js';\n\nconst logger = createLogger('claude-flow-memory-client');\n\n/**\n * Memory node entry for knowledge graph\n */\nexport interface MemoryNodeEntry {\n  id: string;\n  title: string;\n  type: string;\n  status: string;\n  path: string;\n  tags: string[];\n  outgoingLinks: string[];\n  incomingLinks: string[];\n  summary: string;\n  contentHash: string;\n  lastModified: string;\n  syncedAt: string;\n}\n\n/**\n * Memory index entry\n */\nexport interface MemoryIndexEntry {\n  id: string;\n  title: string;\n  type: string;\n  path: string;\n}\n\n/**\n * Memory metadata\n */\nexport interface MemoryMetadata {\n  lastSync: string;\n  nodeCount: number;\n  namespace: string;\n  version?: string;\n}\n\n/**\n * Graph stats stored in memory\n */\nexport interface MemoryGraphStats {\n  totalNodes: number;\n  totalEdges: number;\n  nodesByType: Record<string, number>;\n  nodesByStatus: Record<string, number>;\n  averageLinksPerNode: number;\n  orphanNodes: number;\n}\n\n/**\n * Client configuration\n */\nexport interface ClaudeFlowMemoryClientConfig extends Partial<McpClientConfig> {\n  /** Memory namespace for knowledge graph (default: 'knowledge-graph') */\n  namespace?: string;\n\n  /** Key prefix for nodes (default: 'node/') */\n  nodeKeyPrefix?: string;\n\n  /** Key prefix for indexes (default: 'index/') */\n  indexKeyPrefix?: string;\n}\n\n/**\n * Batch operation result\n */\nexport interface BatchOperationResult {\n  total: number;\n  succeeded: number;\n  failed: number;\n  errors: Array<{ key: string; error: string }>;\n}\n\n/**\n * Claude-Flow Memory Client\n *\n * Provides high-level memory operations for the knowledge graph agent\n * with proper typing and batch operations support.\n *\n * @example\n * ```typescript\n * const client = new ClaudeFlowMemoryClient({\n *   namespace: 'my-project-kg',\n * });\n *\n * // Store a node\n * await client.storeNode({\n *   id: 'abc123',\n *   title: 'My Node',\n *   type: 'document',\n *   // ...\n * });\n *\n * // Retrieve a node\n * const node = await client.getNode('abc123');\n * ```\n */\nexport class ClaudeFlowMemoryClient {\n  private adapter: McpClientAdapter;\n  private namespace: string;\n  private nodeKeyPrefix: string;\n  private indexKeyPrefix: string;\n\n  constructor(config: ClaudeFlowMemoryClientConfig = {}) {\n    this.adapter = createMcpClientAdapter({\n      maxRetries: config.maxRetries,\n      retryDelayMs: config.retryDelayMs,\n      timeoutMs: config.timeoutMs,\n      fallbackEnabled: config.fallbackEnabled,\n      cliCommand: config.cliCommand,\n    });\n    this.namespace = config.namespace ?? 'knowledge-graph';\n    this.nodeKeyPrefix = config.nodeKeyPrefix ?? 'node/';\n    this.indexKeyPrefix = config.indexKeyPrefix ?? 'index/';\n  }\n\n  /**\n   * Store a knowledge node in memory\n   *\n   * @param node - The node to store\n   * @param ttl - Optional TTL in seconds\n   * @returns Whether the operation succeeded\n   */\n  async storeNode(node: MemoryNodeEntry, ttl?: number): Promise<boolean> {\n    const key = `${this.nodeKeyPrefix}${node.id}`;\n    const success = await this.adapter.memoryStore(key, node, this.namespace, ttl);\n\n    if (success) {\n      logger.debug('Stored node in memory', { nodeId: node.id });\n    } else {\n      logger.error('Failed to store node in memory', undefined, { nodeId: node.id });\n    }\n\n    return success;\n  }\n\n  /**\n   * Retrieve a knowledge node from memory\n   *\n   * @param nodeId - The node ID\n   * @returns The node or null if not found\n   */\n  async getNode(nodeId: string): Promise<MemoryNodeEntry | null> {\n    const key = `${this.nodeKeyPrefix}${nodeId}`;\n    const value = await this.adapter.memoryRetrieve(key, this.namespace);\n\n    if (!value) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(value) as MemoryNodeEntry;\n    } catch {\n      logger.warn('Failed to parse node from memory', { nodeId, value: value.substring(0, 100) });\n      return null;\n    }\n  }\n\n  /**\n   * Delete a knowledge node from memory\n   *\n   * @param nodeId - The node ID to delete\n   * @returns Whether the operation succeeded\n   */\n  async deleteNode(nodeId: string): Promise<boolean> {\n    const key = `${this.nodeKeyPrefix}${nodeId}`;\n    return this.adapter.memoryDelete(key, this.namespace);\n  }\n\n  /**\n   * Store multiple nodes in batch\n   *\n   * @param nodes - Array of nodes to store\n   * @param ttl - Optional TTL in seconds\n   * @returns Batch operation result\n   */\n  async storeNodesBatch(nodes: MemoryNodeEntry[], ttl?: number): Promise<BatchOperationResult> {\n    const result: BatchOperationResult = {\n      total: nodes.length,\n      succeeded: 0,\n      failed: 0,\n      errors: [],\n    };\n\n    // Process in batches to avoid overwhelming the CLI\n    const batchSize = 10;\n    for (let i = 0; i < nodes.length; i += batchSize) {\n      const batch = nodes.slice(i, i + batchSize);\n      const promises = batch.map(async (node) => {\n        const success = await this.storeNode(node, ttl);\n        if (success) {\n          result.succeeded++;\n        } else {\n          result.failed++;\n          result.errors.push({ key: node.id, error: 'Failed to store' });\n        }\n      });\n      await Promise.all(promises);\n    }\n\n    return result;\n  }\n\n  /**\n   * Search for nodes by pattern\n   *\n   * @param pattern - Search pattern (e.g., 'node/*', 'node/abc*')\n   * @param limit - Maximum results\n   * @returns Array of matching node keys\n   */\n  async searchNodes(pattern: string, limit: number = 100): Promise<string[]> {\n    const fullPattern = pattern.startsWith(this.nodeKeyPrefix)\n      ? pattern\n      : `${this.nodeKeyPrefix}${pattern}`;\n\n    return this.adapter.memorySearch(fullPattern, this.namespace, limit);\n  }\n\n  /**\n   * Store the node index\n   *\n   * @param entries - Index entries\n   * @returns Whether the operation succeeded\n   */\n  async storeNodeIndex(entries: MemoryIndexEntry[]): Promise<boolean> {\n    const key = `${this.indexKeyPrefix}nodes`;\n    return this.adapter.memoryStore(key, entries, this.namespace);\n  }\n\n  /**\n   * Retrieve the node index\n   *\n   * @returns Array of index entries or null\n   */\n  async getNodeIndex(): Promise<MemoryIndexEntry[] | null> {\n    const key = `${this.indexKeyPrefix}nodes`;\n    const value = await this.adapter.memoryRetrieve(key, this.namespace);\n\n    if (!value) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(value) as MemoryIndexEntry[];\n    } catch {\n      logger.warn('Failed to parse node index from memory');\n      return null;\n    }\n  }\n\n  /**\n   * Store the tag index\n   *\n   * @param tagIndex - Map of tags to node IDs\n   * @returns Whether the operation succeeded\n   */\n  async storeTagIndex(tagIndex: Record<string, string[]>): Promise<boolean> {\n    const key = `${this.indexKeyPrefix}tags`;\n    return this.adapter.memoryStore(key, tagIndex, this.namespace);\n  }\n\n  /**\n   * Retrieve the tag index\n   *\n   * @returns Tag index or null\n   */\n  async getTagIndex(): Promise<Record<string, string[]> | null> {\n    const key = `${this.indexKeyPrefix}tags`;\n    const value = await this.adapter.memoryRetrieve(key, this.namespace);\n\n    if (!value) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(value) as Record<string, string[]>;\n    } catch {\n      logger.warn('Failed to parse tag index from memory');\n      return null;\n    }\n  }\n\n  /**\n   * Store graph statistics\n   *\n   * @param stats - Graph stats\n   * @returns Whether the operation succeeded\n   */\n  async storeStats(stats: MemoryGraphStats): Promise<boolean> {\n    return this.adapter.memoryStore('stats', stats, this.namespace);\n  }\n\n  /**\n   * Retrieve graph statistics\n   *\n   * @returns Graph stats or null\n   */\n  async getStats(): Promise<MemoryGraphStats | null> {\n    const value = await this.adapter.memoryRetrieve('stats', this.namespace);\n\n    if (!value) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(value) as MemoryGraphStats;\n    } catch {\n      logger.warn('Failed to parse stats from memory');\n      return null;\n    }\n  }\n\n  /**\n   * Store metadata\n   *\n   * @param metadata - Metadata to store\n   * @returns Whether the operation succeeded\n   */\n  async storeMetadata(metadata: MemoryMetadata): Promise<boolean> {\n    return this.adapter.memoryStore('metadata', metadata, this.namespace);\n  }\n\n  /**\n   * Retrieve metadata\n   *\n   * @returns Metadata or null\n   */\n  async getMetadata(): Promise<MemoryMetadata | null> {\n    const value = await this.adapter.memoryRetrieve('metadata', this.namespace);\n\n    if (!value) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(value) as MemoryMetadata;\n    } catch {\n      logger.warn('Failed to parse metadata from memory');\n      return null;\n    }\n  }\n\n  /**\n   * Store a custom key-value pair\n   *\n   * @param key - Storage key\n   * @param value - Value to store\n   * @param ttl - Optional TTL in seconds\n   * @returns Whether the operation succeeded\n   */\n  async store(key: string, value: unknown, ttl?: number): Promise<boolean> {\n    return this.adapter.memoryStore(key, value as object, this.namespace, ttl);\n  }\n\n  /**\n   * Retrieve a custom key\n   *\n   * @param key - Storage key\n   * @returns Value or null\n   */\n  async retrieve<T = unknown>(key: string): Promise<T | null> {\n    const value = await this.adapter.memoryRetrieve(key, this.namespace);\n\n    if (!value) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(value) as T;\n    } catch {\n      return value as unknown as T;\n    }\n  }\n\n  /**\n   * Delete a custom key\n   *\n   * @param key - Storage key\n   * @returns Whether the operation succeeded\n   */\n  async delete(key: string): Promise<boolean> {\n    return this.adapter.memoryDelete(key, this.namespace);\n  }\n\n  /**\n   * Search for keys by pattern\n   *\n   * @param pattern - Search pattern\n   * @param limit - Maximum results\n   * @returns Array of matching keys\n   */\n  async search(pattern: string, limit: number = 100): Promise<string[]> {\n    return this.adapter.memorySearch(pattern, this.namespace, limit);\n  }\n\n  /**\n   * List all keys in the namespace\n   *\n   * @returns Array of keys\n   */\n  async listKeys(): Promise<string[]> {\n    return this.adapter.memoryList(this.namespace);\n  }\n\n  /**\n   * Check if CLI is available\n   *\n   * @returns Whether CLI is available\n   */\n  async isCliAvailable(): Promise<boolean> {\n    return this.adapter.isCliAvailable();\n  }\n\n  /**\n   * Get the configured namespace\n   */\n  getNamespace(): string {\n    return this.namespace;\n  }\n\n  /**\n   * Get the underlying adapter (for advanced usage)\n   */\n  getAdapter(): McpClientAdapter {\n    return this.adapter;\n  }\n\n  /**\n   * Clear all fallback storage\n   */\n  clearFallback(): void {\n    this.adapter.clearFallback(this.namespace);\n  }\n}\n\n/**\n * Create a configured Claude-Flow memory client\n */\nexport function createClaudeFlowMemoryClient(\n  config?: ClaudeFlowMemoryClientConfig\n): ClaudeFlowMemoryClient {\n  return new ClaudeFlowMemoryClient(config);\n}\n"],"names":[],"mappings":"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"}