{"version":3,"file":"analyzer.js","sources":["../../../../src/plugins/analyzers/code-complexity/analyzer.ts"],"sourcesContent":["/**\n * Code Complexity Analyzer\n *\n * Parses TypeScript/JavaScript files using typescript-estree and\n * analyzes complexity metrics for functions, methods, and files.\n *\n * @module plugins/analyzers/code-complexity/analyzer\n */\n\nimport { parse, type TSESTree } from '@typescript-eslint/typescript-estree';\nimport { readFile } from 'fs/promises';\nimport { extname, relative, basename } from 'path';\nimport fastGlob from 'fast-glob';\nimport { createLogger } from '../../../utils/logger.js';\nimport {\n  calculateCyclomaticComplexity,\n  calculateCognitiveComplexity,\n  calculateMaxNestingDepth,\n  calculateLinesOfCode,\n  countReturnStatements,\n  calculateMaintainabilityIndex,\n  aggregateFileComplexity,\n  classifyComplexityLevel,\n  detectComplexityIssues,\n  generateRecommendations,\n} from './metrics.js';\nimport type {\n  AnalyzerConfig,\n  FileAnalysis,\n  FunctionAnalysis,\n  FunctionKind,\n  ProjectAnalysis,\n  ProjectMetrics,\n  ComplexityScore,\n  ComplexityLevel,\n  DEFAULT_CONFIG,\n} from './types.js';\nimport { DEFAULT_THRESHOLDS } from './types.js';\n\nconst logger = createLogger('code-complexity-analyzer');\n\n// ============================================================================\n// Code Complexity Analyzer Class\n// ============================================================================\n\n/**\n * Analyzes TypeScript/JavaScript code for complexity metrics\n *\n * @example\n * ```typescript\n * const analyzer = new CodeComplexityAnalyzer({\n *   projectRoot: '/my/project',\n *   patterns: { include: ['src/** /*.ts'], exclude: ['** /*.test.ts'] }\n * });\n *\n * const result = await analyzer.analyzeProject();\n * console.log(`Found ${result.complexFunctions.length} complex functions`);\n * ```\n */\nexport class CodeComplexityAnalyzer {\n  private config: AnalyzerConfig;\n  private sourceCache: Map<string, string> = new Map();\n\n  constructor(config: Partial<AnalyzerConfig> = {}) {\n    // Merge with defaults\n    this.config = {\n      projectRoot: config.projectRoot ?? '.',\n      patterns: config.patterns ?? {\n        include: ['**/*.ts', '**/*.tsx', '**/*.js', '**/*.jsx'],\n        exclude: [\n          '**/node_modules/**',\n          '**/dist/**',\n          '**/build/**',\n          '**/*.d.ts',\n          '**/*.min.js',\n          '**/coverage/**',\n        ],\n      },\n      thresholds: { ...DEFAULT_THRESHOLDS, ...config.thresholds },\n      maxFiles: config.maxFiles,\n      includeNodeModules: config.includeNodeModules ?? false,\n      includeTests: config.includeTests ?? true,\n      generateGraphNodes: config.generateGraphNodes ?? true,\n      minComplexityToReport: config.minComplexityToReport ?? 0,\n      verbose: config.verbose ?? false,\n    };\n  }\n\n  // ==========================================================================\n  // Project Analysis\n  // ==========================================================================\n\n  /**\n   * Analyze entire project for complexity\n   */\n  async analyzeProject(): Promise<ProjectAnalysis> {\n    const startedAt = new Date();\n\n    logger.info('Starting project complexity analysis', {\n      projectRoot: this.config.projectRoot,\n    });\n\n    // Find files to analyze\n    const files = await this.findFiles();\n\n    if (this.config.verbose) {\n      logger.debug(`Found ${files.length} files to analyze`);\n    }\n\n    // Analyze each file\n    const fileAnalyses: FileAnalysis[] = [];\n    const errors: string[] = [];\n\n    for (const filePath of files) {\n      try {\n        const analysis = await this.analyzeFile(filePath);\n        if (analysis) {\n          fileAnalyses.push(analysis);\n        }\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        errors.push(`${filePath}: ${message}`);\n        if (this.config.verbose) {\n          logger.warn(`Failed to analyze ${filePath}`, { error: message });\n        }\n      }\n    }\n\n    // Calculate project metrics\n    const metrics = this.calculateProjectMetrics(fileAnalyses);\n\n    // Identify hotspots\n    const hotspots = fileAnalyses\n      .filter((f) => f.level === 'high' || f.level === 'critical')\n      .sort((a, b) => b.complexity.cyclomatic - a.complexity.cyclomatic);\n\n    // Collect complex functions\n    const complexFunctions = fileAnalyses\n      .flatMap((f) => f.complexFunctions)\n      .sort((a, b) => b.complexity.cyclomatic - a.complexity.cyclomatic);\n\n    const completedAt = new Date();\n\n    const result: ProjectAnalysis = {\n      projectRoot: this.config.projectRoot,\n      files: fileAnalyses,\n      metrics,\n      hotspots,\n      complexFunctions,\n      config: this.config,\n      timing: {\n        startedAt,\n        completedAt,\n        durationMs: completedAt.getTime() - startedAt.getTime(),\n      },\n    };\n\n    logger.info('Project analysis complete', {\n      files: fileAnalyses.length,\n      functions: metrics.totalFunctions,\n      hotspots: hotspots.length,\n      duration: result.timing.durationMs,\n    });\n\n    return result;\n  }\n\n  // ==========================================================================\n  // File Analysis\n  // ==========================================================================\n\n  /**\n   * Analyze a single file for complexity\n   */\n  async analyzeFile(filePath: string): Promise<FileAnalysis | null> {\n    const extension = extname(filePath).toLowerCase();\n\n    // Only process TypeScript/JavaScript files\n    if (!['.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs'].includes(extension)) {\n      return null;\n    }\n\n    // Read source code\n    const sourceCode = await this.getSourceCode(filePath);\n    if (!sourceCode) return null;\n\n    // Parse AST\n    const ast = this.parseFile(filePath, sourceCode);\n    if (!ast) return null;\n\n    // Extract functions\n    const functions = this.extractFunctions(ast, filePath, sourceCode);\n\n    // Calculate file-level metrics\n    const { loc, totalLines } = calculateLinesOfCode(sourceCode, 1, sourceCode.split('\\n').length);\n\n    // Count imports and exports\n    const importCount = this.countImports(ast);\n    const exportCount = this.countExports(ast);\n    const classCount = this.countClasses(ast);\n\n    // Aggregate file complexity\n    const complexity = aggregateFileComplexity(functions, loc, totalLines);\n\n    // Classify file complexity level\n    const level = classifyComplexityLevel(complexity, this.config.thresholds);\n\n    // Find complex functions\n    const complexFunctions = functions.filter(\n      (f) => f.level === 'high' || f.level === 'critical'\n    );\n\n    return {\n      filePath,\n      relativePath: relative(this.config.projectRoot, filePath),\n      extension,\n      complexity,\n      functions,\n      classCount,\n      importCount,\n      exportCount,\n      analyzedAt: new Date(),\n      parseErrors: [],\n      complexFunctions,\n      level,\n    };\n  }\n\n  // ==========================================================================\n  // AST Parsing\n  // ==========================================================================\n\n  /**\n   * Parse source file to AST\n   */\n  private parseFile(filePath: string, sourceCode: string): TSESTree.Program | null {\n    const extension = extname(filePath).toLowerCase();\n    const isTypeScript = extension === '.ts' || extension === '.tsx';\n    const isJsx = extension === '.tsx' || extension === '.jsx';\n\n    try {\n      return parse(sourceCode, {\n        loc: true,\n        range: true,\n        tokens: false,\n        comment: false,\n        jsx: isJsx,\n        // Use looser parsing for JavaScript\n        ...(isTypeScript ? {} : { allowInvalidAST: true }),\n      });\n    } catch (error) {\n      if (this.config.verbose) {\n        logger.debug(`Parse error in ${filePath}`, {\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n      return null;\n    }\n  }\n\n  // ==========================================================================\n  // Function Extraction\n  // ==========================================================================\n\n  /**\n   * Extract all functions from AST\n   */\n  private extractFunctions(\n    ast: TSESTree.Program,\n    filePath: string,\n    sourceCode: string\n  ): FunctionAnalysis[] {\n    const functions: FunctionAnalysis[] = [];\n\n    const traverse = (node: TSESTree.Node, parentName?: string): void => {\n      // Check for function-like nodes\n      const functionInfo = this.getFunctionInfo(node, parentName);\n      if (functionInfo) {\n        const analysis = this.analyzeFunctionNode(\n          functionInfo.node,\n          functionInfo.name,\n          functionInfo.kind,\n          filePath,\n          sourceCode,\n          functionInfo.isAsync,\n          functionInfo.isExported,\n          functionInfo.parentName\n        );\n        functions.push(analysis);\n      }\n\n      // Track class names for methods\n      let newParentName = parentName;\n      if (node.type === 'ClassDeclaration' || node.type === 'ClassExpression') {\n        const classNode = node as TSESTree.ClassDeclaration;\n        newParentName = classNode.id?.name ?? 'AnonymousClass';\n      }\n\n      // Traverse children\n      for (const key of Object.keys(node)) {\n        if (key === 'parent') continue;\n        const child = (node as unknown as Record<string, unknown>)[key];\n        if (child && typeof child === 'object') {\n          if (Array.isArray(child)) {\n            for (const item of child) {\n              if (item && typeof item === 'object' && 'type' in item) {\n                traverse(item as TSESTree.Node, newParentName);\n              }\n            }\n          } else if ('type' in child) {\n            traverse(child as TSESTree.Node, newParentName);\n          }\n        }\n      }\n    };\n\n    traverse(ast);\n    return functions;\n  }\n\n  /**\n   * Get function information from node\n   */\n  private getFunctionInfo(\n    node: TSESTree.Node,\n    parentName?: string\n  ): {\n    node: TSESTree.Node;\n    name: string;\n    kind: FunctionKind;\n    isAsync: boolean;\n    isExported: boolean;\n    parentName?: string;\n  } | null {\n    switch (node.type) {\n      case 'FunctionDeclaration': {\n        const fn = node as TSESTree.FunctionDeclaration;\n        return {\n          node: fn,\n          name: fn.id?.name ?? 'anonymous',\n          kind: fn.generator ? 'generator' : 'function',\n          isAsync: fn.async,\n          isExported: false,\n          parentName,\n        };\n      }\n\n      case 'FunctionExpression': {\n        const fn = node as TSESTree.FunctionExpression;\n        return {\n          node: fn,\n          name: fn.id?.name ?? 'anonymous',\n          kind: fn.generator ? 'generator' : 'function',\n          isAsync: fn.async,\n          isExported: false,\n          parentName,\n        };\n      }\n\n      case 'ArrowFunctionExpression': {\n        const fn = node as TSESTree.ArrowFunctionExpression;\n        // Try to get name from variable declaration\n        const name = this.getArrowFunctionName(node) ?? 'arrow';\n        return {\n          node: fn,\n          name,\n          kind: 'arrow',\n          isAsync: fn.async,\n          isExported: false,\n          parentName,\n        };\n      }\n\n      case 'MethodDefinition': {\n        const method = node as TSESTree.MethodDefinition;\n        const methodName = this.getPropertyName(method.key) ?? 'method';\n        let kind: FunctionKind;\n        if (method.kind === 'constructor') {\n          kind = 'constructor';\n        } else if (method.kind === 'get') {\n          kind = 'getter';\n        } else if (method.kind === 'set') {\n          kind = 'setter';\n        } else {\n          kind = 'method';\n        }\n        const fn = method.value as TSESTree.FunctionExpression;\n        return {\n          node: method.value,\n          name: methodName,\n          kind,\n          isAsync: fn.async,\n          isExported: false,\n          parentName,\n        };\n      }\n\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Analyze a single function node\n   */\n  private analyzeFunctionNode(\n    node: TSESTree.Node,\n    name: string,\n    kind: FunctionKind,\n    filePath: string,\n    sourceCode: string,\n    isAsync: boolean,\n    isExported: boolean,\n    parentName?: string\n  ): FunctionAnalysis {\n    const startLine = node.loc?.start.line ?? 1;\n    const endLine = node.loc?.end.line ?? 1;\n\n    // Calculate complexity metrics\n    const cyclomatic = calculateCyclomaticComplexity(node);\n    const cognitive = calculateCognitiveComplexity(node);\n    const maxNestingDepth = calculateMaxNestingDepth(node);\n    const { loc, totalLines } = calculateLinesOfCode(sourceCode, startLine, endLine);\n    const returnCount = countReturnStatements(node);\n\n    // Get parameter count\n    const parameterCount = this.getParameterCount(node);\n\n    const complexity: ComplexityScore = {\n      cyclomatic,\n      cognitive,\n      loc,\n      totalLines,\n      maxNestingDepth,\n      parameterCount,\n      returnCount,\n    };\n\n    // Classify complexity level\n    const level = classifyComplexityLevel(complexity, this.config.thresholds);\n\n    // Detect issues\n    const issues = detectComplexityIssues(complexity, this.config.thresholds, name);\n\n    // Generate recommendations\n    const recommendations = generateRecommendations(complexity, this.config.thresholds, level);\n\n    return {\n      name,\n      filePath,\n      startLine,\n      endLine,\n      kind,\n      complexity,\n      level,\n      parentName,\n      isAsync,\n      isExported,\n      issues,\n      recommendations,\n    };\n  }\n\n  // ==========================================================================\n  // Helper Methods\n  // ==========================================================================\n\n  /**\n   * Find files matching patterns\n   */\n  private async findFiles(): Promise<string[]> {\n    const patterns = this.config.patterns.include.map((p) =>\n      p.startsWith('/') ? p : `${this.config.projectRoot}/${p}`\n    );\n\n    const ignore = [...this.config.patterns.exclude];\n    if (!this.config.includeNodeModules) {\n      ignore.push('**/node_modules/**');\n    }\n    if (!this.config.includeTests) {\n      ignore.push('**/*.test.*', '**/*.spec.*', '**/__tests__/**');\n    }\n\n    let files = await fastGlob(patterns, {\n      ignore,\n      absolute: true,\n      onlyFiles: true,\n    });\n\n    // Limit files if configured\n    if (this.config.maxFiles && files.length > this.config.maxFiles) {\n      files = files.slice(0, this.config.maxFiles);\n    }\n\n    return files;\n  }\n\n  /**\n   * Get source code for file (with caching)\n   */\n  private async getSourceCode(filePath: string): Promise<string | null> {\n    if (this.sourceCache.has(filePath)) {\n      return this.sourceCache.get(filePath)!;\n    }\n\n    try {\n      const content = await readFile(filePath, 'utf-8');\n      this.sourceCache.set(filePath, content);\n      return content;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Get arrow function name from parent\n   */\n  private getArrowFunctionName(node: TSESTree.Node): string | null {\n    // This would require parent tracking in the AST\n    // For now, return null and we'll use 'arrow' as default\n    return null;\n  }\n\n  /**\n   * Get property name from key\n   */\n  private getPropertyName(key: TSESTree.Node): string | null {\n    if (key.type === 'Identifier') {\n      return (key as TSESTree.Identifier).name;\n    }\n    if (key.type === 'Literal') {\n      return String((key as TSESTree.Literal).value);\n    }\n    return null;\n  }\n\n  /**\n   * Get parameter count from function\n   */\n  private getParameterCount(node: TSESTree.Node): number {\n    if ('params' in node && Array.isArray(node.params)) {\n      return node.params.length;\n    }\n    return 0;\n  }\n\n  /**\n   * Count imports in AST\n   */\n  private countImports(ast: TSESTree.Program): number {\n    return ast.body.filter((n) => n.type === 'ImportDeclaration').length;\n  }\n\n  /**\n   * Count exports in AST\n   */\n  private countExports(ast: TSESTree.Program): number {\n    return ast.body.filter(\n      (n) =>\n        n.type === 'ExportDefaultDeclaration' ||\n        n.type === 'ExportNamedDeclaration' ||\n        n.type === 'ExportAllDeclaration'\n    ).length;\n  }\n\n  /**\n   * Count classes in AST\n   */\n  private countClasses(ast: TSESTree.Program): number {\n    let count = 0;\n    const traverse = (node: TSESTree.Node): void => {\n      if (node.type === 'ClassDeclaration' || node.type === 'ClassExpression') {\n        count++;\n      }\n      for (const key of Object.keys(node)) {\n        if (key === 'parent') continue;\n        const child = (node as unknown as Record<string, unknown>)[key];\n        if (child && typeof child === 'object') {\n          if (Array.isArray(child)) {\n            for (const item of child) {\n              if (item && typeof item === 'object' && 'type' in item) {\n                traverse(item as TSESTree.Node);\n              }\n            }\n          } else if ('type' in child) {\n            traverse(child as TSESTree.Node);\n          }\n        }\n      }\n    };\n    traverse(ast);\n    return count;\n  }\n\n  /**\n   * Calculate project-wide metrics\n   */\n  private calculateProjectMetrics(files: FileAnalysis[]): ProjectMetrics {\n    if (files.length === 0) {\n      return {\n        totalFiles: 0,\n        totalFunctions: 0,\n        totalLoc: 0,\n        avgCyclomatic: 0,\n        avgCognitive: 0,\n        avgMaintainability: 100,\n        complexityDistribution: { low: 0, moderate: 0, high: 0, critical: 0 },\n        filesByLevel: { low: 0, moderate: 0, high: 0, critical: 0 },\n        topComplexFiles: [],\n        topComplexFunctions: [],\n      };\n    }\n\n    const allFunctions = files.flatMap((f) => f.functions);\n    const totalFunctions = allFunctions.length;\n    const totalLoc = files.reduce((sum, f) => sum + f.complexity.loc, 0);\n\n    // Calculate averages\n    const avgCyclomatic = totalFunctions > 0\n      ? allFunctions.reduce((sum, f) => sum + f.complexity.cyclomatic, 0) / totalFunctions\n      : 0;\n\n    const avgCognitive = totalFunctions > 0\n      ? allFunctions.reduce((sum, f) => sum + f.complexity.cognitive, 0) / totalFunctions\n      : 0;\n\n    const avgMaintainability = files.length > 0\n      ? files.reduce((sum, f) => sum + f.complexity.maintainabilityIndex, 0) / files.length\n      : 100;\n\n    // Distribution\n    const complexityDistribution: Record<ComplexityLevel, number> = {\n      low: 0,\n      moderate: 0,\n      high: 0,\n      critical: 0,\n    };\n    for (const fn of allFunctions) {\n      complexityDistribution[fn.level]++;\n    }\n\n    const filesByLevel: Record<ComplexityLevel, number> = {\n      low: 0,\n      moderate: 0,\n      high: 0,\n      critical: 0,\n    };\n    for (const file of files) {\n      filesByLevel[file.level]++;\n    }\n\n    // Top complex files\n    const topComplexFiles = files\n      .sort((a, b) => b.complexity.cyclomatic - a.complexity.cyclomatic)\n      .slice(0, 10)\n      .map((f) => ({ path: f.relativePath, score: f.complexity.cyclomatic }));\n\n    // Top complex functions\n    const topComplexFunctions = allFunctions\n      .sort((a, b) => b.complexity.cyclomatic - a.complexity.cyclomatic)\n      .slice(0, 10)\n      .map((f) => ({\n        name: f.parentName ? `${f.parentName}.${f.name}` : f.name,\n        file: relative(this.config.projectRoot, f.filePath),\n        score: f.complexity.cyclomatic,\n      }));\n\n    return {\n      totalFiles: files.length,\n      totalFunctions,\n      totalLoc,\n      avgCyclomatic: Math.round(avgCyclomatic * 100) / 100,\n      avgCognitive: Math.round(avgCognitive * 100) / 100,\n      avgMaintainability: Math.round(avgMaintainability * 100) / 100,\n      complexityDistribution,\n      filesByLevel,\n      topComplexFiles,\n      topComplexFunctions,\n    };\n  }\n\n  /**\n   * Clear source cache\n   */\n  clearCache(): void {\n    this.sourceCache.clear();\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\n/**\n * Create a code complexity analyzer\n */\nexport function createComplexityAnalyzer(\n  config?: Partial<AnalyzerConfig>\n): CodeComplexityAnalyzer {\n  return new CodeComplexityAnalyzer(config);\n}\n\n/**\n * Analyze a single file for complexity\n */\nexport async function analyzeFileComplexity(\n  filePath: string,\n  projectRoot?: string\n): Promise<FileAnalysis | null> {\n  const analyzer = new CodeComplexityAnalyzer({\n    projectRoot: projectRoot ?? '.',\n  });\n  return analyzer.analyzeFile(filePath);\n}\n\n/**\n * Analyze a project for complexity\n */\nexport async function analyzeProjectComplexity(\n  projectRoot: string,\n  options?: Partial<AnalyzerConfig>\n): Promise<ProjectAnalysis> {\n  const analyzer = new CodeComplexityAnalyzer({\n    ...options,\n    projectRoot,\n  });\n  return analyzer.analyzeProject();\n}\n"],"names":["parse","fastGlob"],"mappings":"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"}