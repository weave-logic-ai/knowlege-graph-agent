{"version":3,"file":"metrics.js","sources":["../../../../src/plugins/analyzers/code-complexity/metrics.ts"],"sourcesContent":["/**\n * Code Complexity Metrics Calculator\n *\n * Implements complexity metric calculations:\n * - Cyclomatic Complexity (McCabe)\n * - Cognitive Complexity (SonarSource)\n * - Maintainability Index\n *\n * @module plugins/analyzers/code-complexity/metrics\n */\n\nimport type { TSESTree } from '@typescript-eslint/typescript-estree';\nimport type {\n  ComplexityScore,\n  ComplexityThresholds,\n  ComplexityLevel,\n  FileComplexityScore,\n  HalsteadMetrics,\n  DEFAULT_THRESHOLDS,\n} from './types.js';\nimport { EMPTY_HALSTEAD_METRICS } from './types.js';\n\n// ============================================================================\n// Cyclomatic Complexity Calculator\n// ============================================================================\n\n/**\n * Node types that contribute to cyclomatic complexity\n */\nconst CYCLOMATIC_NODES = new Set([\n  'IfStatement',\n  'ConditionalExpression',\n  'SwitchCase',\n  'ForStatement',\n  'ForInStatement',\n  'ForOfStatement',\n  'WhileStatement',\n  'DoWhileStatement',\n  'CatchClause',\n  'LogicalExpression', // && and || add branching paths\n]);\n\n/**\n * Calculate cyclomatic complexity for an AST node\n *\n * Cyclomatic complexity = E - N + 2P\n * Simplified: Count decision points + 1\n */\nexport function calculateCyclomaticComplexity(node: TSESTree.Node): number {\n  let complexity = 1; // Base complexity\n\n  function traverse(current: TSESTree.Node): void {\n    if (CYCLOMATIC_NODES.has(current.type)) {\n      // Special handling for switch cases - only count non-default cases\n      if (current.type === 'SwitchCase') {\n        const switchCase = current as TSESTree.SwitchCase;\n        if (switchCase.test !== null) {\n          complexity++;\n        }\n      }\n      // Logical expressions add complexity for each operator\n      else if (current.type === 'LogicalExpression') {\n        const logical = current as TSESTree.LogicalExpression;\n        if (logical.operator === '&&' || logical.operator === '||') {\n          complexity++;\n        }\n      }\n      // All other decision nodes\n      else {\n        complexity++;\n      }\n    }\n\n    // Traverse child nodes\n    for (const key of Object.keys(current)) {\n      const child = (current as unknown as Record<string, unknown>)[key];\n      if (child && typeof child === 'object') {\n        if (Array.isArray(child)) {\n          for (const item of child) {\n            if (item && typeof item === 'object' && 'type' in item) {\n              traverse(item as TSESTree.Node);\n            }\n          }\n        } else if ('type' in child) {\n          traverse(child as TSESTree.Node);\n        }\n      }\n    }\n  }\n\n  traverse(node);\n  return complexity;\n}\n\n// ============================================================================\n// Cognitive Complexity Calculator\n// ============================================================================\n\n/**\n * Calculate cognitive complexity for an AST node\n *\n * Based on SonarSource's cognitive complexity:\n * - Increments for breaks in linear flow\n * - Nesting increases increment value\n * - Recursion and logical operators add complexity\n */\nexport function calculateCognitiveComplexity(node: TSESTree.Node): number {\n  let complexity = 0;\n\n  function traverse(current: TSESTree.Node, nestingLevel: number): void {\n    const increment = nestingLevel + 1;\n\n    switch (current.type) {\n      // Control flow structures - add base + nesting\n      case 'IfStatement':\n      case 'ConditionalExpression':\n        complexity += increment;\n        // Check for else if chain (doesn't add nesting)\n        if (current.type === 'IfStatement') {\n          const ifStmt = current as TSESTree.IfStatement;\n          traverseChildren(ifStmt.test, nestingLevel);\n          traverseChildren(ifStmt.consequent, nestingLevel + 1);\n          if (ifStmt.alternate) {\n            if (ifStmt.alternate.type === 'IfStatement') {\n              // else if - no nesting increase\n              complexity += 1;\n              traverse(ifStmt.alternate, nestingLevel);\n            } else {\n              complexity += 1; // else\n              traverseChildren(ifStmt.alternate, nestingLevel + 1);\n            }\n          }\n          return; // Already handled children\n        }\n        break;\n\n      case 'SwitchStatement':\n        complexity += increment;\n        break;\n\n      case 'ForStatement':\n      case 'ForInStatement':\n      case 'ForOfStatement':\n      case 'WhileStatement':\n      case 'DoWhileStatement':\n        complexity += increment;\n        break;\n\n      case 'CatchClause':\n        complexity += increment;\n        break;\n\n      // Logical operators - flat increment\n      case 'LogicalExpression': {\n        const logical = current as TSESTree.LogicalExpression;\n        if (logical.operator === '&&' || logical.operator === '||' || logical.operator === '??') {\n          complexity += 1;\n        }\n        break;\n      }\n\n      // Break/continue with label - extra complexity\n      case 'BreakStatement':\n      case 'ContinueStatement': {\n        const stmt = current as TSESTree.BreakStatement | TSESTree.ContinueStatement;\n        if (stmt.label) {\n          complexity += 1;\n        }\n        break;\n      }\n\n      // Recursion detection would go here\n      // For now, we track call expressions within same function\n\n      default:\n        break;\n    }\n\n    // Determine if this node increases nesting\n    const increasesNesting =\n      current.type === 'IfStatement' ||\n      current.type === 'SwitchStatement' ||\n      current.type === 'ForStatement' ||\n      current.type === 'ForInStatement' ||\n      current.type === 'ForOfStatement' ||\n      current.type === 'WhileStatement' ||\n      current.type === 'DoWhileStatement' ||\n      current.type === 'CatchClause' ||\n      current.type === 'ConditionalExpression';\n\n    const newNesting = increasesNesting ? nestingLevel + 1 : nestingLevel;\n    traverseChildren(current, newNesting);\n  }\n\n  function traverseChildren(current: TSESTree.Node, nestingLevel: number): void {\n    for (const key of Object.keys(current)) {\n      if (key === 'parent') continue; // Skip parent reference\n      const child = (current as unknown as Record<string, unknown>)[key];\n      if (child && typeof child === 'object') {\n        if (Array.isArray(child)) {\n          for (const item of child) {\n            if (item && typeof item === 'object' && 'type' in item) {\n              traverse(item as TSESTree.Node, nestingLevel);\n            }\n          }\n        } else if ('type' in child) {\n          traverse(child as TSESTree.Node, nestingLevel);\n        }\n      }\n    }\n  }\n\n  traverse(node, 0);\n  return complexity;\n}\n\n// ============================================================================\n// Nesting Depth Calculator\n// ============================================================================\n\n/**\n * Calculate maximum nesting depth\n */\nexport function calculateMaxNestingDepth(node: TSESTree.Node): number {\n  let maxDepth = 0;\n\n  function traverse(current: TSESTree.Node, depth: number): void {\n    maxDepth = Math.max(maxDepth, depth);\n\n    // Nodes that increase nesting\n    const nestingNodes = new Set([\n      'IfStatement',\n      'ForStatement',\n      'ForInStatement',\n      'ForOfStatement',\n      'WhileStatement',\n      'DoWhileStatement',\n      'SwitchStatement',\n      'TryStatement',\n      'FunctionDeclaration',\n      'FunctionExpression',\n      'ArrowFunctionExpression',\n      'ClassDeclaration',\n      'ClassExpression',\n    ]);\n\n    const newDepth = nestingNodes.has(current.type) ? depth + 1 : depth;\n\n    for (const key of Object.keys(current)) {\n      if (key === 'parent') continue;\n      const child = (current as unknown as Record<string, unknown>)[key];\n      if (child && typeof child === 'object') {\n        if (Array.isArray(child)) {\n          for (const item of child) {\n            if (item && typeof item === 'object' && 'type' in item) {\n              traverse(item as TSESTree.Node, newDepth);\n            }\n          }\n        } else if ('type' in child) {\n          traverse(child as TSESTree.Node, newDepth);\n        }\n      }\n    }\n  }\n\n  traverse(node, 0);\n  return maxDepth;\n}\n\n// ============================================================================\n// Lines of Code Calculator\n// ============================================================================\n\n/**\n * Calculate lines of code metrics\n */\nexport function calculateLinesOfCode(\n  sourceCode: string,\n  startLine: number,\n  endLine: number\n): { loc: number; totalLines: number } {\n  const lines = sourceCode.split('\\n').slice(startLine - 1, endLine);\n  const totalLines = lines.length;\n\n  // Count non-empty, non-comment lines\n  let loc = 0;\n  let inBlockComment = false;\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n\n    // Handle block comments\n    if (inBlockComment) {\n      if (trimmed.includes('*/')) {\n        inBlockComment = false;\n      }\n      continue;\n    }\n\n    if (trimmed.startsWith('/*')) {\n      inBlockComment = true;\n      if (trimmed.includes('*/')) {\n        inBlockComment = false;\n      }\n      continue;\n    }\n\n    // Skip empty lines and single-line comments\n    if (trimmed === '' || trimmed.startsWith('//')) {\n      continue;\n    }\n\n    loc++;\n  }\n\n  return { loc, totalLines };\n}\n\n// ============================================================================\n// Return Statement Counter\n// ============================================================================\n\n/**\n * Count return statements in a function\n */\nexport function countReturnStatements(node: TSESTree.Node): number {\n  let count = 0;\n\n  function traverse(current: TSESTree.Node): void {\n    if (current.type === 'ReturnStatement') {\n      count++;\n    }\n\n    // Don't traverse into nested functions\n    if (\n      current.type === 'FunctionDeclaration' ||\n      current.type === 'FunctionExpression' ||\n      current.type === 'ArrowFunctionExpression'\n    ) {\n      if (current !== node) return;\n    }\n\n    for (const key of Object.keys(current)) {\n      if (key === 'parent') continue;\n      const child = (current as unknown as Record<string, unknown>)[key];\n      if (child && typeof child === 'object') {\n        if (Array.isArray(child)) {\n          for (const item of child) {\n            if (item && typeof item === 'object' && 'type' in item) {\n              traverse(item as TSESTree.Node);\n            }\n          }\n        } else if ('type' in child) {\n          traverse(child as TSESTree.Node);\n        }\n      }\n    }\n  }\n\n  traverse(node);\n  return count;\n}\n\n// ============================================================================\n// Maintainability Index Calculator\n// ============================================================================\n\n/**\n * Calculate maintainability index (Microsoft variant)\n *\n * MI = MAX(0, (171 - 5.2 * ln(Halstead Volume) - 0.23 * Cyclomatic - 16.2 * ln(LOC)) * 100 / 171)\n *\n * Simplified version using available metrics\n */\nexport function calculateMaintainabilityIndex(\n  cyclomatic: number,\n  loc: number,\n  cognitive: number\n): number {\n  if (loc === 0) return 100;\n\n  // Simplified calculation without Halstead volume\n  // Uses cognitive complexity as a proxy for code understanding difficulty\n  const lnLoc = Math.log(Math.max(1, loc));\n  const lnCognitive = Math.log(Math.max(1, cognitive));\n\n  // Base MI calculation (adapted)\n  const mi = 171 - 0.23 * cyclomatic - 16.2 * lnLoc - 5.2 * lnCognitive;\n\n  // Normalize to 0-100 scale\n  const normalizedMI = Math.max(0, (mi * 100) / 171);\n\n  return Math.round(normalizedMI * 100) / 100;\n}\n\n// ============================================================================\n// Halstead Metrics Calculator\n// ============================================================================\n\n/**\n * Operators in JavaScript/TypeScript that contribute to Halstead metrics\n */\nconst HALSTEAD_OPERATORS = new Set([\n  // Arithmetic\n  '+', '-', '*', '/', '%', '**',\n  // Assignment\n  '=', '+=', '-=', '*=', '/=', '%=', '**=', '&=', '|=', '^=', '<<=', '>>=', '>>>=', '&&=', '||=', '??=',\n  // Comparison\n  '==', '===', '!=', '!==', '<', '>', '<=', '>=',\n  // Logical\n  '&&', '||', '!', '??',\n  // Bitwise\n  '&', '|', '^', '~', '<<', '>>', '>>>',\n  // Unary\n  '++', '--', 'typeof', 'void', 'delete', 'await',\n  // Ternary\n  '?', ':',\n  // Member access\n  '.', '?.', '[', ']',\n  // Function/control\n  '(', ')', '{', '}', ',', ';',\n  'function', 'return', 'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'default', 'break', 'continue',\n  'try', 'catch', 'finally', 'throw', 'new', 'class', 'extends', 'import', 'export', 'const', 'let', 'var',\n  'async', 'yield', '=>',\n]);\n\n/**\n * Calculate Halstead metrics from an AST node\n *\n * @param node - AST node to analyze\n * @returns Halstead metrics\n */\nexport function calculateHalsteadMetrics(node: TSESTree.Node): HalsteadMetrics {\n  const operators = new Map<string, number>();\n  const operands = new Map<string, number>();\n\n  function addOperator(op: string): void {\n    operators.set(op, (operators.get(op) || 0) + 1);\n  }\n\n  function addOperand(op: string): void {\n    operands.set(op, (operands.get(op) || 0) + 1);\n  }\n\n  function traverse(current: TSESTree.Node): void {\n    switch (current.type) {\n      // Operators from expressions\n      case 'BinaryExpression':\n      case 'LogicalExpression':\n      case 'AssignmentExpression': {\n        const expr = current as TSESTree.BinaryExpression | TSESTree.LogicalExpression | TSESTree.AssignmentExpression;\n        addOperator(expr.operator);\n        break;\n      }\n\n      case 'UnaryExpression':\n      case 'UpdateExpression': {\n        const expr = current as TSESTree.UnaryExpression | TSESTree.UpdateExpression;\n        addOperator(expr.operator);\n        break;\n      }\n\n      case 'ConditionalExpression':\n        addOperator('?:');\n        break;\n\n      case 'MemberExpression': {\n        const expr = current as TSESTree.MemberExpression;\n        addOperator(expr.optional ? '?.' : '.');\n        break;\n      }\n\n      case 'CallExpression':\n        addOperator('()');\n        break;\n\n      case 'NewExpression':\n        addOperator('new');\n        break;\n\n      case 'ArrowFunctionExpression':\n        addOperator('=>');\n        break;\n\n      case 'FunctionDeclaration':\n      case 'FunctionExpression':\n        addOperator('function');\n        break;\n\n      case 'AwaitExpression':\n        addOperator('await');\n        break;\n\n      case 'YieldExpression':\n        addOperator('yield');\n        break;\n\n      // Control flow operators\n      case 'IfStatement':\n        addOperator('if');\n        break;\n\n      case 'ForStatement':\n      case 'ForInStatement':\n      case 'ForOfStatement':\n        addOperator('for');\n        break;\n\n      case 'WhileStatement':\n        addOperator('while');\n        break;\n\n      case 'DoWhileStatement':\n        addOperator('do');\n        addOperator('while');\n        break;\n\n      case 'SwitchStatement':\n        addOperator('switch');\n        break;\n\n      case 'SwitchCase': {\n        const switchCase = current as TSESTree.SwitchCase;\n        addOperator(switchCase.test ? 'case' : 'default');\n        break;\n      }\n\n      case 'TryStatement':\n        addOperator('try');\n        break;\n\n      case 'CatchClause':\n        addOperator('catch');\n        break;\n\n      case 'ThrowStatement':\n        addOperator('throw');\n        break;\n\n      case 'ReturnStatement':\n        addOperator('return');\n        break;\n\n      case 'BreakStatement':\n        addOperator('break');\n        break;\n\n      case 'ContinueStatement':\n        addOperator('continue');\n        break;\n\n      // Operands\n      case 'Identifier': {\n        const id = current as TSESTree.Identifier;\n        addOperand(id.name);\n        break;\n      }\n\n      case 'Literal': {\n        const lit = current as TSESTree.Literal;\n        addOperand(String(lit.value));\n        break;\n      }\n\n      case 'TemplateLiteral':\n        addOperand('template');\n        break;\n\n      default:\n        break;\n    }\n\n    // Traverse children\n    for (const key of Object.keys(current)) {\n      if (key === 'parent') continue;\n      const child = (current as unknown as Record<string, unknown>)[key];\n      if (child && typeof child === 'object') {\n        if (Array.isArray(child)) {\n          for (const item of child) {\n            if (item && typeof item === 'object' && 'type' in item) {\n              traverse(item as TSESTree.Node);\n            }\n          }\n        } else if ('type' in child) {\n          traverse(child as TSESTree.Node);\n        }\n      }\n    }\n  }\n\n  traverse(node);\n\n  // Calculate derived metrics\n  const n1 = operators.size;  // distinct operators\n  const n2 = operands.size;   // distinct operands\n  const N1 = Array.from(operators.values()).reduce((a, b) => a + b, 0); // total operators\n  const N2 = Array.from(operands.values()).reduce((a, b) => a + b, 0);  // total operands\n\n  // Avoid division by zero\n  if (n1 === 0 || n2 === 0) {\n    return { ...EMPTY_HALSTEAD_METRICS };\n  }\n\n  const vocabulary = n1 + n2;\n  const length = N1 + N2;\n  const calculatedLength = n1 * Math.log2(n1) + n2 * Math.log2(n2);\n  const volume = length * Math.log2(vocabulary);\n  const difficulty = (n1 / 2) * (N2 / n2);\n  const effort = difficulty * volume;\n  const time = effort / 18;  // Halstead's constant for mental effort\n  const bugs = volume / 3000; // Halstead's bug estimation formula\n\n  return {\n    distinctOperators: n1,\n    distinctOperands: n2,\n    totalOperators: N1,\n    totalOperands: N2,\n    vocabulary: Math.round(vocabulary * 100) / 100,\n    length: Math.round(length * 100) / 100,\n    calculatedLength: Math.round(calculatedLength * 100) / 100,\n    volume: Math.round(volume * 100) / 100,\n    difficulty: Math.round(difficulty * 100) / 100,\n    effort: Math.round(effort * 100) / 100,\n    time: Math.round(time * 100) / 100,\n    bugs: Math.round(bugs * 1000) / 1000,\n  };\n}\n\n// ============================================================================\n// Complexity Level Classification\n// ============================================================================\n\n/**\n * Classify complexity level based on scores and thresholds\n */\nexport function classifyComplexityLevel(\n  complexity: ComplexityScore,\n  thresholds: ComplexityThresholds\n): ComplexityLevel {\n  // Check for critical levels first\n  if (\n    complexity.cyclomatic >= thresholds.cyclomaticCritical ||\n    complexity.cognitive >= thresholds.cognitiveCritical\n  ) {\n    return 'critical';\n  }\n\n  // Check for high levels\n  if (\n    complexity.cyclomatic >= thresholds.cyclomaticHigh ||\n    complexity.cognitive >= thresholds.cognitiveHigh ||\n    complexity.maxNestingDepth > thresholds.maxNestingDepth\n  ) {\n    return 'high';\n  }\n\n  // Check for moderate levels\n  if (\n    complexity.cyclomatic >= thresholds.cyclomaticHigh / 2 ||\n    complexity.cognitive >= thresholds.cognitiveHigh / 2 ||\n    complexity.maxNestingDepth > thresholds.maxNestingDepth - 1\n  ) {\n    return 'moderate';\n  }\n\n  return 'low';\n}\n\n// ============================================================================\n// Aggregation Functions\n// ============================================================================\n\n/**\n * Aggregate file complexity from individual function complexities\n */\nexport function aggregateFileComplexity(\n  functions: Array<{ complexity: ComplexityScore }>,\n  totalLoc: number,\n  totalLines: number\n): FileComplexityScore {\n  if (functions.length === 0) {\n    return {\n      cyclomatic: 1,\n      cognitive: 0,\n      loc: totalLoc,\n      totalLines,\n      maxNestingDepth: 0,\n      avgCyclomatic: 1,\n      avgCognitive: 0,\n      functionCount: 0,\n      maintainabilityIndex: 100,\n    };\n  }\n\n  const totalCyclomatic = functions.reduce((sum, f) => sum + f.complexity.cyclomatic, 0);\n  const totalCognitive = functions.reduce((sum, f) => sum + f.complexity.cognitive, 0);\n  const maxNesting = Math.max(...functions.map((f) => f.complexity.maxNestingDepth));\n\n  const avgCyclomatic = totalCyclomatic / functions.length;\n  const avgCognitive = totalCognitive / functions.length;\n  const maintainabilityIndex = calculateMaintainabilityIndex(\n    avgCyclomatic,\n    totalLoc / Math.max(1, functions.length),\n    avgCognitive\n  );\n\n  return {\n    cyclomatic: totalCyclomatic,\n    cognitive: totalCognitive,\n    loc: totalLoc,\n    totalLines,\n    maxNestingDepth: maxNesting,\n    avgCyclomatic: Math.round(avgCyclomatic * 100) / 100,\n    avgCognitive: Math.round(avgCognitive * 100) / 100,\n    functionCount: functions.length,\n    maintainabilityIndex,\n  };\n}\n\n// ============================================================================\n// Issue Detection\n// ============================================================================\n\n/**\n * Detect complexity issues in a function\n */\nexport function detectComplexityIssues(\n  complexity: ComplexityScore,\n  thresholds: ComplexityThresholds,\n  functionName: string\n): string[] {\n  const issues: string[] = [];\n\n  if (complexity.cyclomatic >= thresholds.cyclomaticCritical) {\n    issues.push(\n      `Critical cyclomatic complexity (${complexity.cyclomatic}): ${functionName} has too many decision paths`\n    );\n  } else if (complexity.cyclomatic >= thresholds.cyclomaticHigh) {\n    issues.push(\n      `High cyclomatic complexity (${complexity.cyclomatic}): Consider breaking down ${functionName}`\n    );\n  }\n\n  if (complexity.cognitive >= thresholds.cognitiveCritical) {\n    issues.push(\n      `Critical cognitive complexity (${complexity.cognitive}): ${functionName} is hard to understand`\n    );\n  } else if (complexity.cognitive >= thresholds.cognitiveHigh) {\n    issues.push(\n      `High cognitive complexity (${complexity.cognitive}): ${functionName} may be difficult to maintain`\n    );\n  }\n\n  if (complexity.maxNestingDepth > thresholds.maxNestingDepth) {\n    issues.push(\n      `Deep nesting (${complexity.maxNestingDepth} levels): Consider extracting nested logic`\n    );\n  }\n\n  if (complexity.loc > thresholds.maxFunctionLength) {\n    issues.push(\n      `Long function (${complexity.loc} LOC): Consider splitting into smaller functions`\n    );\n  }\n\n  if (complexity.returnCount && complexity.returnCount > 5) {\n    issues.push(\n      `Multiple return points (${complexity.returnCount}): May indicate complex control flow`\n    );\n  }\n\n  return issues;\n}\n\n/**\n * Generate recommendations for reducing complexity\n */\nexport function generateRecommendations(\n  complexity: ComplexityScore,\n  thresholds: ComplexityThresholds,\n  level: ComplexityLevel\n): string[] {\n  const recommendations: string[] = [];\n\n  if (level === 'low') {\n    return recommendations;\n  }\n\n  if (complexity.cyclomatic >= thresholds.cyclomaticHigh) {\n    recommendations.push('Extract conditional logic into separate helper functions');\n    recommendations.push('Consider using early returns to reduce nesting');\n    recommendations.push('Replace complex conditionals with polymorphism or strategy pattern');\n  }\n\n  if (complexity.cognitive >= thresholds.cognitiveHigh) {\n    recommendations.push('Simplify nested structures by extracting inner logic');\n    recommendations.push('Use descriptive variable names to improve readability');\n    recommendations.push('Consider using guard clauses at function start');\n  }\n\n  if (complexity.maxNestingDepth > thresholds.maxNestingDepth) {\n    recommendations.push('Flatten nested loops using functional programming patterns');\n    recommendations.push('Extract deeply nested code blocks into separate functions');\n    recommendations.push('Consider using async/await to flatten callback pyramids');\n  }\n\n  if (complexity.loc > thresholds.maxFunctionLength) {\n    recommendations.push('Split function into smaller, focused helper functions');\n    recommendations.push('Apply single responsibility principle');\n    recommendations.push('Consider creating a class if function manages state');\n  }\n\n  return recommendations;\n}\n"],"names":[],"mappings":";AA6BA,MAAM,uCAAuB,IAAI;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AACF,CAAC;AAQM,SAAS,8BAA8B,MAA6B;AACzE,MAAI,aAAa;AAEjB,WAAS,SAAS,SAA8B;AAC9C,QAAI,iBAAiB,IAAI,QAAQ,IAAI,GAAG;AAEtC,UAAI,QAAQ,SAAS,cAAc;AACjC,cAAM,aAAa;AACnB,YAAI,WAAW,SAAS,MAAM;AAC5B;AAAA,QACF;AAAA,MACF,WAES,QAAQ,SAAS,qBAAqB;AAC7C,cAAM,UAAU;AAChB,YAAI,QAAQ,aAAa,QAAQ,QAAQ,aAAa,MAAM;AAC1D;AAAA,QACF;AAAA,MACF,OAEK;AACH;AAAA,MACF;AAAA,IACF;AAGA,eAAW,OAAO,OAAO,KAAK,OAAO,GAAG;AACtC,YAAM,QAAS,QAA+C,GAAG;AACjE,UAAI,SAAS,OAAO,UAAU,UAAU;AACtC,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,qBAAW,QAAQ,OAAO;AACxB,gBAAI,QAAQ,OAAO,SAAS,YAAY,UAAU,MAAM;AACtD,uBAAS,IAAqB;AAAA,YAChC;AAAA,UACF;AAAA,QACF,WAAW,UAAU,OAAO;AAC1B,mBAAS,KAAsB;AAAA,QACjC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,WAAS,IAAI;AACb,SAAO;AACT;AAcO,SAAS,6BAA6B,MAA6B;AACxE,MAAI,aAAa;AAEjB,WAAS,SAAS,SAAwB,cAA4B;AACpE,UAAM,YAAY,eAAe;AAEjC,YAAQ,QAAQ,MAAA;AAAA;AAAA,MAEd,KAAK;AAAA,MACL,KAAK;AACH,sBAAc;AAEd,YAAI,QAAQ,SAAS,eAAe;AAClC,gBAAM,SAAS;AACf,2BAAiB,OAAO,MAAM,YAAY;AAC1C,2BAAiB,OAAO,YAAY,eAAe,CAAC;AACpD,cAAI,OAAO,WAAW;AACpB,gBAAI,OAAO,UAAU,SAAS,eAAe;AAE3C,4BAAc;AACd,uBAAS,OAAO,WAAW,YAAY;AAAA,YACzC,OAAO;AACL,4BAAc;AACd,+BAAiB,OAAO,WAAW,eAAe,CAAC;AAAA,YACrD;AAAA,UACF;AACA;AAAA,QACF;AACA;AAAA,MAEF,KAAK;AACH,sBAAc;AACd;AAAA,MAEF,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,sBAAc;AACd;AAAA,MAEF,KAAK;AACH,sBAAc;AACd;AAAA;AAAA,MAGF,KAAK,qBAAqB;AACxB,cAAM,UAAU;AAChB,YAAI,QAAQ,aAAa,QAAQ,QAAQ,aAAa,QAAQ,QAAQ,aAAa,MAAM;AACvF,wBAAc;AAAA,QAChB;AACA;AAAA,MACF;AAAA;AAAA,MAGA,KAAK;AAAA,MACL,KAAK,qBAAqB;AACxB,cAAM,OAAO;AACb,YAAI,KAAK,OAAO;AACd,wBAAc;AAAA,QAChB;AACA;AAAA,MACF;AAAA,IAME;AAIJ,UAAM,mBACJ,QAAQ,SAAS,iBACjB,QAAQ,SAAS,qBACjB,QAAQ,SAAS,kBACjB,QAAQ,SAAS,oBACjB,QAAQ,SAAS,oBACjB,QAAQ,SAAS,oBACjB,QAAQ,SAAS,sBACjB,QAAQ,SAAS,iBACjB,QAAQ,SAAS;AAEnB,UAAM,aAAa,mBAAmB,eAAe,IAAI;AACzD,qBAAiB,SAAS,UAAU;AAAA,EACtC;AAEA,WAAS,iBAAiB,SAAwB,cAA4B;AAC5E,eAAW,OAAO,OAAO,KAAK,OAAO,GAAG;AACtC,UAAI,QAAQ,SAAU;AACtB,YAAM,QAAS,QAA+C,GAAG;AACjE,UAAI,SAAS,OAAO,UAAU,UAAU;AACtC,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,qBAAW,QAAQ,OAAO;AACxB,gBAAI,QAAQ,OAAO,SAAS,YAAY,UAAU,MAAM;AACtD,uBAAS,MAAuB,YAAY;AAAA,YAC9C;AAAA,UACF;AAAA,QACF,WAAW,UAAU,OAAO;AAC1B,mBAAS,OAAwB,YAAY;AAAA,QAC/C;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,WAAS,MAAM,CAAC;AAChB,SAAO;AACT;AASO,SAAS,yBAAyB,MAA6B;AACpE,MAAI,WAAW;AAEf,WAAS,SAAS,SAAwB,OAAqB;AAC7D,eAAW,KAAK,IAAI,UAAU,KAAK;AAGnC,UAAM,mCAAmB,IAAI;AAAA,MAC3B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAED,UAAM,WAAW,aAAa,IAAI,QAAQ,IAAI,IAAI,QAAQ,IAAI;AAE9D,eAAW,OAAO,OAAO,KAAK,OAAO,GAAG;AACtC,UAAI,QAAQ,SAAU;AACtB,YAAM,QAAS,QAA+C,GAAG;AACjE,UAAI,SAAS,OAAO,UAAU,UAAU;AACtC,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,qBAAW,QAAQ,OAAO;AACxB,gBAAI,QAAQ,OAAO,SAAS,YAAY,UAAU,MAAM;AACtD,uBAAS,MAAuB,QAAQ;AAAA,YAC1C;AAAA,UACF;AAAA,QACF,WAAW,UAAU,OAAO;AAC1B,mBAAS,OAAwB,QAAQ;AAAA,QAC3C;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,WAAS,MAAM,CAAC;AAChB,SAAO;AACT;AASO,SAAS,qBACd,YACA,WACA,SACqC;AACrC,QAAM,QAAQ,WAAW,MAAM,IAAI,EAAE,MAAM,YAAY,GAAG,OAAO;AACjE,QAAM,aAAa,MAAM;AAGzB,MAAI,MAAM;AACV,MAAI,iBAAiB;AAErB,aAAW,QAAQ,OAAO;AACxB,UAAM,UAAU,KAAK,KAAA;AAGrB,QAAI,gBAAgB;AAClB,UAAI,QAAQ,SAAS,IAAI,GAAG;AAC1B,yBAAiB;AAAA,MACnB;AACA;AAAA,IACF;AAEA,QAAI,QAAQ,WAAW,IAAI,GAAG;AAC5B,uBAAiB;AACjB,UAAI,QAAQ,SAAS,IAAI,GAAG;AAC1B,yBAAiB;AAAA,MACnB;AACA;AAAA,IACF;AAGA,QAAI,YAAY,MAAM,QAAQ,WAAW,IAAI,GAAG;AAC9C;AAAA,IACF;AAEA;AAAA,EACF;AAEA,SAAO,EAAE,KAAK,WAAA;AAChB;AASO,SAAS,sBAAsB,MAA6B;AACjE,MAAI,QAAQ;AAEZ,WAAS,SAAS,SAA8B;AAC9C,QAAI,QAAQ,SAAS,mBAAmB;AACtC;AAAA,IACF;AAGA,QACE,QAAQ,SAAS,yBACjB,QAAQ,SAAS,wBACjB,QAAQ,SAAS,2BACjB;AACA,UAAI,YAAY,KAAM;AAAA,IACxB;AAEA,eAAW,OAAO,OAAO,KAAK,OAAO,GAAG;AACtC,UAAI,QAAQ,SAAU;AACtB,YAAM,QAAS,QAA+C,GAAG;AACjE,UAAI,SAAS,OAAO,UAAU,UAAU;AACtC,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,qBAAW,QAAQ,OAAO;AACxB,gBAAI,QAAQ,OAAO,SAAS,YAAY,UAAU,MAAM;AACtD,uBAAS,IAAqB;AAAA,YAChC;AAAA,UACF;AAAA,QACF,WAAW,UAAU,OAAO;AAC1B,mBAAS,KAAsB;AAAA,QACjC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,WAAS,IAAI;AACb,SAAO;AACT;AAaO,SAAS,8BACd,YACA,KACA,WACQ;AACR,MAAI,QAAQ,EAAG,QAAO;AAItB,QAAM,QAAQ,KAAK,IAAI,KAAK,IAAI,GAAG,GAAG,CAAC;AACvC,QAAM,cAAc,KAAK,IAAI,KAAK,IAAI,GAAG,SAAS,CAAC;AAGnD,QAAM,KAAK,MAAM,OAAO,aAAa,OAAO,QAAQ,MAAM;AAG1D,QAAM,eAAe,KAAK,IAAI,GAAI,KAAK,MAAO,GAAG;AAEjD,SAAO,KAAK,MAAM,eAAe,GAAG,IAAI;AAC1C;AAuCO,SAAS,yBAAyB,MAAsC;AAC7E,QAAM,gCAAgB,IAAA;AACtB,QAAM,+BAAe,IAAA;AAErB,WAAS,YAAY,IAAkB;AACrC,cAAU,IAAI,KAAK,UAAU,IAAI,EAAE,KAAK,KAAK,CAAC;AAAA,EAChD;AAEA,WAAS,WAAW,IAAkB;AACpC,aAAS,IAAI,KAAK,SAAS,IAAI,EAAE,KAAK,KAAK,CAAC;AAAA,EAC9C;AAEA,WAAS,SAAS,SAA8B;AAC9C,YAAQ,QAAQ,MAAA;AAAA;AAAA,MAEd,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,wBAAwB;AAC3B,cAAM,OAAO;AACb,oBAAY,KAAK,QAAQ;AACzB;AAAA,MACF;AAAA,MAEA,KAAK;AAAA,MACL,KAAK,oBAAoB;AACvB,cAAM,OAAO;AACb,oBAAY,KAAK,QAAQ;AACzB;AAAA,MACF;AAAA,MAEA,KAAK;AACH,oBAAY,IAAI;AAChB;AAAA,MAEF,KAAK,oBAAoB;AACvB,cAAM,OAAO;AACb,oBAAY,KAAK,WAAW,OAAO,GAAG;AACtC;AAAA,MACF;AAAA,MAEA,KAAK;AACH,oBAAY,IAAI;AAChB;AAAA,MAEF,KAAK;AACH,oBAAY,KAAK;AACjB;AAAA,MAEF,KAAK;AACH,oBAAY,IAAI;AAChB;AAAA,MAEF,KAAK;AAAA,MACL,KAAK;AACH,oBAAY,UAAU;AACtB;AAAA,MAEF,KAAK;AACH,oBAAY,OAAO;AACnB;AAAA,MAEF,KAAK;AACH,oBAAY,OAAO;AACnB;AAAA;AAAA,MAGF,KAAK;AACH,oBAAY,IAAI;AAChB;AAAA,MAEF,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,oBAAY,KAAK;AACjB;AAAA,MAEF,KAAK;AACH,oBAAY,OAAO;AACnB;AAAA,MAEF,KAAK;AACH,oBAAY,IAAI;AAChB,oBAAY,OAAO;AACnB;AAAA,MAEF,KAAK;AACH,oBAAY,QAAQ;AACpB;AAAA,MAEF,KAAK,cAAc;AACjB,cAAM,aAAa;AACnB,oBAAY,WAAW,OAAO,SAAS,SAAS;AAChD;AAAA,MACF;AAAA,MAEA,KAAK;AACH,oBAAY,KAAK;AACjB;AAAA,MAEF,KAAK;AACH,oBAAY,OAAO;AACnB;AAAA,MAEF,KAAK;AACH,oBAAY,OAAO;AACnB;AAAA,MAEF,KAAK;AACH,oBAAY,QAAQ;AACpB;AAAA,MAEF,KAAK;AACH,oBAAY,OAAO;AACnB;AAAA,MAEF,KAAK;AACH,oBAAY,UAAU;AACtB;AAAA;AAAA,MAGF,KAAK,cAAc;AACjB,cAAM,KAAK;AACX,mBAAW,GAAG,IAAI;AAClB;AAAA,MACF;AAAA,MAEA,KAAK,WAAW;AACd,cAAM,MAAM;AACZ,mBAAW,OAAO,IAAI,KAAK,CAAC;AAC5B;AAAA,MACF;AAAA,MAEA,KAAK;AACH,mBAAW,UAAU;AACrB;AAAA,IAGA;AAIJ,eAAW,OAAO,OAAO,KAAK,OAAO,GAAG;AACtC,UAAI,QAAQ,SAAU;AACtB,YAAM,QAAS,QAA+C,GAAG;AACjE,UAAI,SAAS,OAAO,UAAU,UAAU;AACtC,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,qBAAW,QAAQ,OAAO;AACxB,gBAAI,QAAQ,OAAO,SAAS,YAAY,UAAU,MAAM;AACtD,uBAAS,IAAqB;AAAA,YAChC;AAAA,UACF;AAAA,QACF,WAAW,UAAU,OAAO;AAC1B,mBAAS,KAAsB;AAAA,QACjC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,WAAS,IAAI;AAGb,QAAM,KAAK,UAAU;AACrB,QAAM,KAAK,SAAS;AACpB,QAAM,KAAK,MAAM,KAAK,UAAU,OAAA,CAAQ,EAAE,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC;AACnE,QAAM,KAAK,MAAM,KAAK,SAAS,OAAA,CAAQ,EAAE,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC;AAGlE,MAAI,OAAO,KAAK,OAAO,GAAG;AACxB,WAAO,EAAE,GAAG,uBAAA;AAAA,EACd;AAEA,QAAM,aAAa,KAAK;AACxB,QAAM,SAAS,KAAK;AACpB,QAAM,mBAAmB,KAAK,KAAK,KAAK,EAAE,IAAI,KAAK,KAAK,KAAK,EAAE;AAC/D,QAAM,SAAS,SAAS,KAAK,KAAK,UAAU;AAC5C,QAAM,aAAc,KAAK,KAAM,KAAK;AACpC,QAAM,SAAS,aAAa;AAC5B,QAAM,OAAO,SAAS;AACtB,QAAM,OAAO,SAAS;AAEtB,SAAO;AAAA,IACL,mBAAmB;AAAA,IACnB,kBAAkB;AAAA,IAClB,gBAAgB;AAAA,IAChB,eAAe;AAAA,IACf,YAAY,KAAK,MAAM,aAAa,GAAG,IAAI;AAAA,IAC3C,QAAQ,KAAK,MAAM,SAAS,GAAG,IAAI;AAAA,IACnC,kBAAkB,KAAK,MAAM,mBAAmB,GAAG,IAAI;AAAA,IACvD,QAAQ,KAAK,MAAM,SAAS,GAAG,IAAI;AAAA,IACnC,YAAY,KAAK,MAAM,aAAa,GAAG,IAAI;AAAA,IAC3C,QAAQ,KAAK,MAAM,SAAS,GAAG,IAAI;AAAA,IACnC,MAAM,KAAK,MAAM,OAAO,GAAG,IAAI;AAAA,IAC/B,MAAM,KAAK,MAAM,OAAO,GAAI,IAAI;AAAA,EAAA;AAEpC;AASO,SAAS,wBACd,YACA,YACiB;AAEjB,MACE,WAAW,cAAc,WAAW,sBACpC,WAAW,aAAa,WAAW,mBACnC;AACA,WAAO;AAAA,EACT;AAGA,MACE,WAAW,cAAc,WAAW,kBACpC,WAAW,aAAa,WAAW,iBACnC,WAAW,kBAAkB,WAAW,iBACxC;AACA,WAAO;AAAA,EACT;AAGA,MACE,WAAW,cAAc,WAAW,iBAAiB,KACrD,WAAW,aAAa,WAAW,gBAAgB,KACnD,WAAW,kBAAkB,WAAW,kBAAkB,GAC1D;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AASO,SAAS,wBACd,WACA,UACA,YACqB;AACrB,MAAI,UAAU,WAAW,GAAG;AAC1B,WAAO;AAAA,MACL,YAAY;AAAA,MACZ,WAAW;AAAA,MACX,KAAK;AAAA,MACL;AAAA,MACA,iBAAiB;AAAA,MACjB,eAAe;AAAA,MACf,cAAc;AAAA,MACd,eAAe;AAAA,MACf,sBAAsB;AAAA,IAAA;AAAA,EAE1B;AAEA,QAAM,kBAAkB,UAAU,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,WAAW,YAAY,CAAC;AACrF,QAAM,iBAAiB,UAAU,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,WAAW,WAAW,CAAC;AACnF,QAAM,aAAa,KAAK,IAAI,GAAG,UAAU,IAAI,CAAC,MAAM,EAAE,WAAW,eAAe,CAAC;AAEjF,QAAM,gBAAgB,kBAAkB,UAAU;AAClD,QAAM,eAAe,iBAAiB,UAAU;AAChD,QAAM,uBAAuB;AAAA,IAC3B;AAAA,IACA,WAAW,KAAK,IAAI,GAAG,UAAU,MAAM;AAAA,IACvC;AAAA,EAAA;AAGF,SAAO;AAAA,IACL,YAAY;AAAA,IACZ,WAAW;AAAA,IACX,KAAK;AAAA,IACL;AAAA,IACA,iBAAiB;AAAA,IACjB,eAAe,KAAK,MAAM,gBAAgB,GAAG,IAAI;AAAA,IACjD,cAAc,KAAK,MAAM,eAAe,GAAG,IAAI;AAAA,IAC/C,eAAe,UAAU;AAAA,IACzB;AAAA,EAAA;AAEJ;AASO,SAAS,uBACd,YACA,YACA,cACU;AACV,QAAM,SAAmB,CAAA;AAEzB,MAAI,WAAW,cAAc,WAAW,oBAAoB;AAC1D,WAAO;AAAA,MACL,mCAAmC,WAAW,UAAU,MAAM,YAAY;AAAA,IAAA;AAAA,EAE9E,WAAW,WAAW,cAAc,WAAW,gBAAgB;AAC7D,WAAO;AAAA,MACL,+BAA+B,WAAW,UAAU,6BAA6B,YAAY;AAAA,IAAA;AAAA,EAEjG;AAEA,MAAI,WAAW,aAAa,WAAW,mBAAmB;AACxD,WAAO;AAAA,MACL,kCAAkC,WAAW,SAAS,MAAM,YAAY;AAAA,IAAA;AAAA,EAE5E,WAAW,WAAW,aAAa,WAAW,eAAe;AAC3D,WAAO;AAAA,MACL,8BAA8B,WAAW,SAAS,MAAM,YAAY;AAAA,IAAA;AAAA,EAExE;AAEA,MAAI,WAAW,kBAAkB,WAAW,iBAAiB;AAC3D,WAAO;AAAA,MACL,iBAAiB,WAAW,eAAe;AAAA,IAAA;AAAA,EAE/C;AAEA,MAAI,WAAW,MAAM,WAAW,mBAAmB;AACjD,WAAO;AAAA,MACL,kBAAkB,WAAW,GAAG;AAAA,IAAA;AAAA,EAEpC;AAEA,MAAI,WAAW,eAAe,WAAW,cAAc,GAAG;AACxD,WAAO;AAAA,MACL,2BAA2B,WAAW,WAAW;AAAA,IAAA;AAAA,EAErD;AAEA,SAAO;AACT;AAKO,SAAS,wBACd,YACA,YACA,OACU;AACV,QAAM,kBAA4B,CAAA;AAElC,MAAI,UAAU,OAAO;AACnB,WAAO;AAAA,EACT;AAEA,MAAI,WAAW,cAAc,WAAW,gBAAgB;AACtD,oBAAgB,KAAK,0DAA0D;AAC/E,oBAAgB,KAAK,gDAAgD;AACrE,oBAAgB,KAAK,oEAAoE;AAAA,EAC3F;AAEA,MAAI,WAAW,aAAa,WAAW,eAAe;AACpD,oBAAgB,KAAK,sDAAsD;AAC3E,oBAAgB,KAAK,uDAAuD;AAC5E,oBAAgB,KAAK,gDAAgD;AAAA,EACvE;AAEA,MAAI,WAAW,kBAAkB,WAAW,iBAAiB;AAC3D,oBAAgB,KAAK,4DAA4D;AACjF,oBAAgB,KAAK,2DAA2D;AAChF,oBAAgB,KAAK,yDAAyD;AAAA,EAChF;AAEA,MAAI,WAAW,MAAM,WAAW,mBAAmB;AACjD,oBAAgB,KAAK,uDAAuD;AAC5E,oBAAgB,KAAK,uCAAuC;AAC5D,oBAAgB,KAAK,qDAAqD;AAAA,EAC5E;AAEA,SAAO;AACT;"}