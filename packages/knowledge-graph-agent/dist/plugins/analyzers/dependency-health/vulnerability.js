import { exec } from "child_process";
import { promisify } from "util";
import { existsSync } from "fs";
import { join } from "path";
import { createLogger } from "../../../utils/logger.js";
const execAsync = promisify(exec);
const logger = createLogger("vulnerability-checker");
const SEVERITY_ORDER = {
  info: 0,
  low: 1,
  moderate: 2,
  high: 3,
  critical: 4
};
function meetsThreshold(severity, threshold) {
  return SEVERITY_ORDER[severity] >= SEVERITY_ORDER[threshold];
}
function getMaxSeverity(severities) {
  if (severities.length === 0) return "info";
  let max = "info";
  for (const severity of severities) {
    if (SEVERITY_ORDER[severity] > SEVERITY_ORDER[max]) {
      max = severity;
    }
  }
  return max;
}
class VulnerabilityChecker {
  projectRoot;
  config;
  constructor(projectRoot, config = {}) {
    this.projectRoot = projectRoot;
    this.config = {
      vulnerabilitySeverityThreshold: config.vulnerabilitySeverityThreshold ?? "low",
      timeout: config.timeout ?? 6e4,
      ...config
    };
  }
  /**
   * Run npm audit and parse results
   */
  async checkVulnerabilities() {
    const result = {
      success: false,
      report: null,
      vulnerabilities: /* @__PURE__ */ new Map(),
      summary: {
        critical: 0,
        high: 0,
        moderate: 0,
        low: 0,
        info: 0,
        total: 0
      }
    };
    const lockFilePath = join(this.projectRoot, "package-lock.json");
    if (!existsSync(lockFilePath)) {
      logger.warn("No package-lock.json found, skipping vulnerability check");
      result.error = "No package-lock.json found";
      return result;
    }
    try {
      logger.info("Running npm audit", { projectRoot: this.projectRoot });
      const { stdout, stderr } = await execAsync(
        "npm audit --json 2>/dev/null || true",
        {
          cwd: this.projectRoot,
          timeout: this.config.timeout,
          maxBuffer: 10 * 1024 * 1024
          // 10MB buffer for large audits
        }
      );
      if (!stdout.trim()) {
        logger.info("npm audit returned empty result (no vulnerabilities or error)");
        result.success = true;
        return result;
      }
      let auditData;
      try {
        auditData = JSON.parse(stdout);
      } catch (parseError) {
        logger.error("Failed to parse npm audit output", parseError instanceof Error ? parseError : void 0);
        result.error = "Failed to parse npm audit output";
        return result;
      }
      result.report = auditData;
      result.success = true;
      if (auditData.metadata?.vulnerabilities) {
        result.summary = {
          critical: auditData.metadata.vulnerabilities.critical ?? 0,
          high: auditData.metadata.vulnerabilities.high ?? 0,
          moderate: auditData.metadata.vulnerabilities.moderate ?? 0,
          low: auditData.metadata.vulnerabilities.low ?? 0,
          info: auditData.metadata.vulnerabilities.info ?? 0,
          total: auditData.metadata.vulnerabilities.total ?? 0
        };
      }
      if (auditData.vulnerabilities) {
        for (const [packageName, finding] of Object.entries(auditData.vulnerabilities)) {
          const vulnInfo = this.parseAuditFinding(packageName, finding);
          if (vulnInfo.length > 0) {
            result.vulnerabilities.set(packageName, vulnInfo);
          }
        }
      }
      logger.info("Vulnerability check complete", {
        total: result.summary.total,
        critical: result.summary.critical,
        high: result.summary.high,
        moderate: result.summary.moderate
      });
    } catch (error) {
      logger.error("npm audit failed", error instanceof Error ? error : void 0);
      result.error = error instanceof Error ? error.message : String(error);
    }
    return result;
  }
  /**
   * Parse an audit finding into vulnerability info
   */
  parseAuditFinding(packageName, finding) {
    const vulnerabilities = [];
    const vuln = {
      id: `npm-audit-${packageName}`,
      title: `Vulnerability in ${packageName}`,
      severity: finding.severity,
      vulnerableVersions: finding.range,
      patchedVersions: this.extractPatchedVersion(finding.fixAvailable),
      recommendation: this.generateRecommendation(finding),
      references: []
    };
    if (meetsThreshold(vuln.severity, this.config.vulnerabilitySeverityThreshold)) {
      vulnerabilities.push(vuln);
    }
    return vulnerabilities;
  }
  /**
   * Extract patched version from fix info
   */
  extractPatchedVersion(fixAvailable) {
    if (typeof fixAvailable === "boolean") {
      return fixAvailable ? "Fix available" : null;
    }
    return `${fixAvailable.name}@${fixAvailable.version}`;
  }
  /**
   * Generate recommendation text
   */
  generateRecommendation(finding) {
    if (typeof finding.fixAvailable === "boolean") {
      if (finding.fixAvailable) {
        return `Run 'npm audit fix' to resolve this vulnerability`;
      }
      return "No automatic fix available. Manual intervention required.";
    }
    const fix = finding.fixAvailable;
    if (fix.isSemVerMajor) {
      return `Update to ${fix.name}@${fix.version} (breaking change)`;
    }
    return `Update to ${fix.name}@${fix.version}`;
  }
  /**
   * Get vulnerabilities for a specific package
   */
  async getPackageVulnerabilities(packageName) {
    const result = await this.checkVulnerabilities();
    return result.vulnerabilities.get(packageName) ?? [];
  }
  /**
   * Check if a package has critical vulnerabilities
   */
  async hasCriticalVulnerabilities(packageName) {
    const vulns = await this.getPackageVulnerabilities(packageName);
    return vulns.some((v) => v.severity === "critical" || v.severity === "high");
  }
  /**
   * Get security score based on vulnerabilities (100 = no vulns, 0 = critical vulns)
   */
  calculateSecurityScore(vulnerabilities) {
    if (vulnerabilities.length === 0) {
      return 100;
    }
    let score = 100;
    for (const vuln of vulnerabilities) {
      switch (vuln.severity) {
        case "critical":
          score -= 40;
          break;
        case "high":
          score -= 25;
          break;
        case "moderate":
          score -= 10;
          break;
        case "low":
          score -= 5;
          break;
        case "info":
          score -= 1;
          break;
      }
    }
    return Math.max(0, score);
  }
}
function createVulnerabilityChecker(projectRoot, config) {
  return new VulnerabilityChecker(projectRoot, config);
}
export {
  VulnerabilityChecker,
  createVulnerabilityChecker,
  getMaxSeverity,
  meetsThreshold
};
//# sourceMappingURL=vulnerability.js.map
