{"version":3,"file":"loader.js","sources":["../../src/plugins/loader.ts"],"sourcesContent":["/**\n * Plugin Loader\n *\n * Handles plugin discovery, loading, validation, and hot-reloading.\n * Supports loading plugins from file paths and npm packages.\n *\n * @module plugins/loader\n */\n\nimport { existsSync, readFileSync, statSync, watch, FSWatcher } from 'fs';\nimport { join, dirname, resolve, isAbsolute } from 'path';\nimport { pathToFileURL } from 'url';\nimport { createLogger } from '../utils/index.js';\nimport type {\n  KGPlugin,\n  KGPluginManifest,\n  PluginLoader as IPluginLoader,\n  PluginLoadOptions,\n  PluginLoadResult,\n  PluginMetadata,\n  DiscoveredPlugin,\n  PluginModuleExport,\n  PluginConstructor,\n  PluginFactory,\n} from './types.js';\nimport { isPluginManifest, createDefaultPluginMetadata, isValidSemver } from './types.js';\n\nconst logger = createLogger('plugin-loader');\n\n/**\n * In-memory cache for loaded plugins\n */\ninterface PluginCacheEntry {\n  /** Plugin instance */\n  plugin: KGPlugin;\n  /** Plugin manifest */\n  manifest: KGPluginManifest;\n  /** Plugin metadata */\n  metadata: PluginMetadata;\n  /** Path the plugin was loaded from */\n  path: string;\n  /** When the plugin was loaded */\n  loadedAt: number;\n  /** File watcher for hot-reload */\n  watcher?: FSWatcher;\n}\n\n/**\n * Plugin Loader implementation\n *\n * Discovers, validates, and loads plugins from the filesystem or npm.\n * Supports caching and hot-reloading for development.\n *\n * @example\n * ```typescript\n * const loader = new PluginLoaderImpl({\n *   searchPaths: ['./plugins', './node_modules'],\n *   enableHotReload: true,\n * });\n *\n * // Discover available plugins\n * const discovered = await loader.discover();\n *\n * // Load a specific plugin\n * const result = await loader.load('@kg-plugins/markdown');\n * if (result.success) {\n *   console.log('Loaded:', result.plugin.name);\n * }\n * ```\n */\nexport class AdvancedPluginLoader implements IPluginLoader {\n  private cache: Map<string, PluginCacheEntry> = new Map();\n  private searchPaths: string[] = [];\n  private enableHotReload: boolean;\n  private hotReloadCallbacks: Map<string, (plugin: KGPlugin) => void> = new Map();\n\n  constructor(options: {\n    searchPaths?: string[];\n    enableHotReload?: boolean;\n  } = {}) {\n    this.searchPaths = options.searchPaths || [];\n    this.enableHotReload = options.enableHotReload ?? false;\n  }\n\n  /**\n   * Discover available plugins in search paths\n   */\n  async discover(): Promise<DiscoveredPlugin[]> {\n    const discovered: DiscoveredPlugin[] = [];\n\n    for (const searchPath of this.searchPaths) {\n      const resolvedPath = resolve(searchPath);\n      if (!existsSync(resolvedPath)) {\n        logger.debug('Search path does not exist', { path: resolvedPath });\n        continue;\n      }\n\n      try {\n        const stats = statSync(resolvedPath);\n        if (stats.isDirectory()) {\n          // Check if this is a plugin directory itself\n          const directPlugin = await this.tryDiscoverPlugin(resolvedPath);\n          if (directPlugin) {\n            discovered.push(directPlugin);\n          }\n\n          // Check subdirectories for plugins\n          const entries = await this.readDir(resolvedPath);\n          for (const entry of entries) {\n            const entryPath = join(resolvedPath, entry);\n            const entryStats = statSync(entryPath);\n            if (entryStats.isDirectory()) {\n              const plugin = await this.tryDiscoverPlugin(entryPath);\n              if (plugin) {\n                discovered.push(plugin);\n              }\n            }\n          }\n        }\n      } catch (error) {\n        logger.error(`Failed to search path \"${searchPath}\"`, error instanceof Error ? error : new Error(String(error)));\n      }\n    }\n\n    logger.info('Plugin discovery complete', { found: discovered.length });\n    return discovered;\n  }\n\n  /**\n   * Load a plugin by name\n   */\n  async load(name: string, options?: PluginLoadOptions): Promise<PluginLoadResult> {\n    const startTime = Date.now();\n\n    // Check cache\n    if (!options?.force && this.cache.has(name)) {\n      const cached = this.cache.get(name)!;\n      logger.debug('Using cached plugin', { name });\n      return {\n        success: true,\n        plugin: cached.plugin,\n        metadata: cached.metadata,\n        loadTime: 0,\n      };\n    }\n\n    // Search for the plugin\n    const discovered = await this.findPlugin(name);\n    if (!discovered) {\n      return {\n        success: false,\n        error: `Plugin \"${name}\" not found in search paths`,\n        loadTime: Date.now() - startTime,\n      };\n    }\n\n    return this.loadFromPath(discovered.path, options);\n  }\n\n  /**\n   * Load a plugin from a specific path\n   */\n  async loadFromPath(path: string, options?: PluginLoadOptions): Promise<PluginLoadResult> {\n    const startTime = Date.now();\n    const resolvedPath = isAbsolute(path) ? path : resolve(path);\n\n    // Validate the path exists\n    if (!existsSync(resolvedPath)) {\n      return {\n        success: false,\n        error: `Plugin path does not exist: ${resolvedPath}`,\n        loadTime: Date.now() - startTime,\n      };\n    }\n\n    try {\n      // Load manifest\n      const manifest = await this.loadManifest(resolvedPath);\n      if (!manifest) {\n        return {\n          success: false,\n          error: `No valid plugin manifest found at ${resolvedPath}`,\n          loadTime: Date.now() - startTime,\n        };\n      }\n\n      // Validate manifest if requested\n      if (options?.validate !== false) {\n        const validation = this.validateManifest(manifest);\n        if (!validation.valid) {\n          return {\n            success: false,\n            error: `Invalid plugin manifest: ${validation.errors.join(', ')}`,\n            loadTime: Date.now() - startTime,\n          };\n        }\n      }\n\n      // Check cache\n      if (!options?.force && this.cache.has(manifest.name)) {\n        const cached = this.cache.get(manifest.name)!;\n        logger.debug('Using cached plugin', { name: manifest.name });\n        return {\n          success: true,\n          plugin: cached.plugin,\n          metadata: cached.metadata,\n          loadTime: 0,\n        };\n      }\n\n      // Load the plugin module\n      const plugin = await this.loadPluginModule(resolvedPath, manifest);\n      if (!plugin) {\n        return {\n          success: false,\n          error: `Failed to load plugin module from ${resolvedPath}`,\n          loadTime: Date.now() - startTime,\n        };\n      }\n\n      // Create metadata\n      const loadTime = Date.now() - startTime;\n      const metadata: PluginMetadata = {\n        ...createDefaultPluginMetadata(plugin.name, plugin.version, plugin.type),\n        status: 'loading',\n        loadTime,\n        hooks: manifest['kg-plugin'].hooks || [],\n        capabilities: (manifest['kg-plugin'].capabilities || []).map(c => c.name),\n      };\n\n      // Cache the plugin\n      const cacheEntry: PluginCacheEntry = {\n        plugin,\n        manifest,\n        metadata,\n        path: resolvedPath,\n        loadedAt: Date.now(),\n      };\n\n      // Setup hot-reload if enabled\n      if (this.enableHotReload && manifest['kg-plugin'].hotReload !== false) {\n        cacheEntry.watcher = this.setupHotReload(resolvedPath, manifest.name);\n      }\n\n      this.cache.set(manifest.name, cacheEntry);\n\n      logger.info('Plugin loaded', {\n        name: manifest.name,\n        version: manifest.version,\n        loadTime,\n      });\n\n      return {\n        success: true,\n        plugin,\n        metadata,\n        loadTime,\n      };\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`Failed to load plugin from \"${resolvedPath}\"`, err);\n\n      return {\n        success: false,\n        error: err.message,\n        loadTime: Date.now() - startTime,\n      };\n    }\n  }\n\n  /**\n   * Unload a plugin by name\n   */\n  async unload(name: string): Promise<boolean> {\n    const entry = this.cache.get(name);\n    if (!entry) {\n      return false;\n    }\n\n    try {\n      // Call destroy if available\n      if (typeof entry.plugin.destroy === 'function') {\n        await entry.plugin.destroy();\n      }\n\n      // Stop hot-reload watcher\n      if (entry.watcher) {\n        entry.watcher.close();\n      }\n\n      // Remove from cache\n      this.cache.delete(name);\n\n      logger.info('Plugin unloaded', { name });\n      return true;\n    } catch (error) {\n      logger.error(`Failed to unload plugin \"${name}\"`, error instanceof Error ? error : new Error(String(error)));\n      return false;\n    }\n  }\n\n  /**\n   * Reload a plugin\n   */\n  async reload(name: string): Promise<PluginLoadResult> {\n    const entry = this.cache.get(name);\n    if (!entry) {\n      return {\n        success: false,\n        error: `Plugin \"${name}\" is not loaded`,\n        loadTime: 0,\n      };\n    }\n\n    const path = entry.path;\n\n    // Unload first\n    await this.unload(name);\n\n    // Reload with force\n    return this.loadFromPath(path, { force: true });\n  }\n\n  /**\n   * Get a loaded plugin by name\n   */\n  get(name: string): KGPlugin | undefined {\n    return this.cache.get(name)?.plugin;\n  }\n\n  /**\n   * Check if a plugin is loaded\n   */\n  isLoaded(name: string): boolean {\n    return this.cache.has(name);\n  }\n\n  /**\n   * Get all loaded plugins\n   */\n  getAll(): KGPlugin[] {\n    return Array.from(this.cache.values()).map(e => e.plugin);\n  }\n\n  /**\n   * Validate a plugin manifest\n   */\n  validateManifest(manifest: KGPluginManifest): {\n    valid: boolean;\n    errors: string[];\n    warnings: string[];\n  } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Required fields\n    if (!manifest.name || typeof manifest.name !== 'string') {\n      errors.push('Missing or invalid \"name\" field');\n    }\n\n    if (!manifest.version || typeof manifest.version !== 'string') {\n      errors.push('Missing or invalid \"version\" field');\n    } else if (!isValidSemver(manifest.version)) {\n      errors.push(`Invalid version format: ${manifest.version}`);\n    }\n\n    // kg-plugin field\n    if (!manifest['kg-plugin']) {\n      errors.push('Missing \"kg-plugin\" configuration');\n    } else {\n      const kgPlugin = manifest['kg-plugin'];\n\n      if (!kgPlugin.type) {\n        errors.push('Missing \"kg-plugin.type\" field');\n      }\n\n      if (!kgPlugin.main) {\n        errors.push('Missing \"kg-plugin.main\" field');\n      }\n\n      // Validate hooks\n      if (kgPlugin.hooks) {\n        const validHooks = [\n          'onGraphLoad', 'onGraphSave', 'onNodeAdd', 'onNodeUpdate',\n          'onNodeRemove', 'onEdgeAdd', 'onEdgeRemove', 'onAnalysisStart',\n          'onAnalysisComplete', 'onAgentTaskStart', 'onAgentTaskComplete',\n          'onFileChange', 'onShutdown',\n        ];\n\n        for (const hook of kgPlugin.hooks) {\n          if (!validHooks.includes(hook)) {\n            warnings.push(`Unknown hook: ${hook}`);\n          }\n        }\n      }\n\n      // Validate version requirements\n      if (kgPlugin.minVersion && !isValidSemver(kgPlugin.minVersion)) {\n        errors.push(`Invalid minVersion format: ${kgPlugin.minVersion}`);\n      }\n\n      if (kgPlugin.maxVersion && !isValidSemver(kgPlugin.maxVersion)) {\n        errors.push(`Invalid maxVersion format: ${kgPlugin.maxVersion}`);\n      }\n\n      // Validate dependencies\n      if (kgPlugin.pluginDependencies) {\n        for (const dep of kgPlugin.pluginDependencies) {\n          if (!dep.name) {\n            errors.push('Plugin dependency missing \"name\" field');\n          }\n          if (!dep.version) {\n            errors.push(`Plugin dependency \"${dep.name}\" missing \"version\" field`);\n          }\n        }\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  }\n\n  /**\n   * Set plugin search paths\n   */\n  setSearchPaths(paths: string[]): void {\n    this.searchPaths = paths.map(p => resolve(p));\n    logger.debug('Search paths updated', { paths: this.searchPaths });\n  }\n\n  /**\n   * Get current plugin search paths\n   */\n  getSearchPaths(): string[] {\n    return [...this.searchPaths];\n  }\n\n  /**\n   * Register a callback for hot-reload events\n   */\n  onHotReload(name: string, callback: (plugin: KGPlugin) => void): void {\n    this.hotReloadCallbacks.set(name, callback);\n  }\n\n  /**\n   * Clear the plugin cache\n   */\n  async clearCache(): Promise<void> {\n    const names = Array.from(this.cache.keys());\n    for (const name of names) {\n      await this.unload(name);\n    }\n    logger.info('Plugin cache cleared');\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): {\n    entries: number;\n    oldestEntry: number | null;\n    newestEntry: number | null;\n  } {\n    let oldest: number | null = null;\n    let newest: number | null = null;\n\n    const entries = Array.from(this.cache.values());\n    for (const entry of entries) {\n      if (oldest === null || entry.loadedAt < oldest) {\n        oldest = entry.loadedAt;\n      }\n      if (newest === null || entry.loadedAt > newest) {\n        newest = entry.loadedAt;\n      }\n    }\n\n    return {\n      entries: this.cache.size,\n      oldestEntry: oldest,\n      newestEntry: newest,\n    };\n  }\n\n  // Private helpers\n\n  /**\n   * Try to discover a plugin at the given path\n   */\n  private async tryDiscoverPlugin(path: string): Promise<DiscoveredPlugin | null> {\n    const manifest = await this.loadManifest(path);\n    if (!manifest) {\n      return null;\n    }\n\n    const validation = this.validateManifest(manifest);\n\n    return {\n      manifest,\n      path,\n      isLocal: !path.includes('node_modules'),\n      valid: validation.valid,\n      errors: validation.valid ? undefined : validation.errors,\n    };\n  }\n\n  /**\n   * Find a plugin by name in search paths\n   */\n  private async findPlugin(name: string): Promise<DiscoveredPlugin | null> {\n    for (const searchPath of this.searchPaths) {\n      const resolvedPath = resolve(searchPath);\n      if (!existsSync(resolvedPath)) continue;\n\n      // Check direct match\n      const directPath = join(resolvedPath, name);\n      if (existsSync(directPath)) {\n        const plugin = await this.tryDiscoverPlugin(directPath);\n        if (plugin) return plugin;\n      }\n\n      // Check in node_modules\n      const nodeModulesPath = join(resolvedPath, 'node_modules', name);\n      if (existsSync(nodeModulesPath)) {\n        const plugin = await this.tryDiscoverPlugin(nodeModulesPath);\n        if (plugin) return plugin;\n      }\n\n      // Handle scoped packages (@org/name)\n      if (name.startsWith('@')) {\n        const [scope, packageName] = name.split('/');\n        const scopedPath = join(resolvedPath, 'node_modules', scope, packageName);\n        if (existsSync(scopedPath)) {\n          const plugin = await this.tryDiscoverPlugin(scopedPath);\n          if (plugin) return plugin;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Load a plugin manifest from a path\n   */\n  private async loadManifest(pluginPath: string): Promise<KGPluginManifest | null> {\n    const packageJsonPath = join(pluginPath, 'package.json');\n\n    if (!existsSync(packageJsonPath)) {\n      return null;\n    }\n\n    try {\n      const content = readFileSync(packageJsonPath, 'utf-8');\n      const parsed = JSON.parse(content);\n\n      if (!isPluginManifest(parsed)) {\n        return null;\n      }\n\n      return parsed;\n    } catch (error) {\n      logger.debug('Failed to parse package.json', {\n        path: packageJsonPath,\n        error: (error instanceof Error ? error : new Error(String(error))).message,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Load the plugin module\n   */\n  private async loadPluginModule(\n    pluginPath: string,\n    manifest: KGPluginManifest\n  ): Promise<KGPlugin | null> {\n    const mainPath = join(pluginPath, manifest['kg-plugin'].main);\n\n    if (!existsSync(mainPath)) {\n      // Try common alternatives\n      const alternatives = [\n        mainPath.replace('.js', '.mjs'),\n        mainPath.replace('.js', '.cjs'),\n        join(dirname(mainPath), 'index.js'),\n        join(dirname(mainPath), 'index.mjs'),\n      ];\n\n      for (const alt of alternatives) {\n        if (existsSync(alt)) {\n          return this.importPlugin(alt);\n        }\n      }\n\n      logger.error('Plugin main entry not found', undefined, {\n        path: mainPath,\n        tried: alternatives,\n      });\n      return null;\n    }\n\n    return this.importPlugin(mainPath);\n  }\n\n  /**\n   * Import a plugin module\n   */\n  private async importPlugin(modulePath: string): Promise<KGPlugin | null> {\n    try {\n      // Clear from require cache for hot-reload support\n      this.clearModuleCache(modulePath);\n\n      // Use dynamic import with file URL for ESM support\n      const fileUrl = pathToFileURL(modulePath).href;\n      const module = await import(`${fileUrl}?t=${Date.now()}`);\n\n      // Get the plugin from module exports\n      const exported: PluginModuleExport = module.default || module;\n\n      // Handle different export types\n      if (this.isPluginInstance(exported)) {\n        return exported;\n      }\n\n      if (this.isPluginConstructor(exported)) {\n        return new exported();\n      }\n\n      if (this.isPluginFactory(exported)) {\n        return await exported();\n      }\n\n      // Try named export\n      if (module.plugin && this.isPluginInstance(module.plugin)) {\n        return module.plugin;\n      }\n\n      if (module.createPlugin && typeof module.createPlugin === 'function') {\n        return await module.createPlugin();\n      }\n\n      logger.error('Plugin module does not export a valid plugin', undefined, {\n        path: modulePath,\n        exports: Object.keys(module),\n      });\n      return null;\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`Failed to import plugin module: ${modulePath}`, err);\n      return null;\n    }\n  }\n\n  /**\n   * Check if an export is a plugin instance\n   */\n  private isPluginInstance(obj: unknown): obj is KGPlugin {\n    if (typeof obj !== 'object' || obj === null) {\n      return false;\n    }\n\n    const plugin = obj as Record<string, unknown>;\n    return (\n      typeof plugin.name === 'string' &&\n      typeof plugin.version === 'string' &&\n      typeof plugin.type === 'string' &&\n      typeof plugin.initialize === 'function'\n    );\n  }\n\n  /**\n   * Check if an export is a plugin constructor\n   */\n  private isPluginConstructor(obj: unknown): obj is PluginConstructor {\n    return (\n      typeof obj === 'function' &&\n      obj.prototype &&\n      typeof obj.prototype.initialize === 'function'\n    );\n  }\n\n  /**\n   * Check if an export is a plugin factory\n   */\n  private isPluginFactory(obj: unknown): obj is PluginFactory {\n    return typeof obj === 'function' && !obj.prototype?.initialize;\n  }\n\n  /**\n   * Clear module from Node.js cache\n   */\n  private clearModuleCache(modulePath: string): void {\n    // For CommonJS modules\n    try {\n      const resolved = require.resolve(modulePath);\n      if (require.cache[resolved]) {\n        delete require.cache[resolved];\n      }\n    } catch {\n      // ESM modules don't use require.cache\n    }\n  }\n\n  /**\n   * Setup hot-reload watcher for a plugin\n   */\n  private setupHotReload(pluginPath: string, pluginName: string): FSWatcher | undefined {\n    try {\n      const watcher = watch(pluginPath, { recursive: true }, async (eventType, filename) => {\n        if (!filename) return;\n\n        // Only reload on JS/TS file changes\n        if (!filename.match(/\\.(js|ts|mjs|cjs)$/)) {\n          return;\n        }\n\n        logger.info('Hot-reloading plugin', { name: pluginName, file: filename });\n\n        const result = await this.reload(pluginName);\n        if (result.success && result.plugin) {\n          const callback = this.hotReloadCallbacks.get(pluginName);\n          if (callback) {\n            callback(result.plugin);\n          }\n        }\n      });\n\n      return watcher;\n    } catch (error) {\n      logger.warn('Failed to setup hot-reload', {\n        plugin: pluginName,\n        error: (error instanceof Error ? error : new Error(String(error))).message,\n      });\n      return undefined;\n    }\n  }\n\n  /**\n   * Read directory entries\n   */\n  private async readDir(path: string): Promise<string[]> {\n    const fs = await import('fs/promises');\n    try {\n      return await fs.readdir(path);\n    } catch {\n      return [];\n    }\n  }\n}\n\n/**\n * Create a new advanced plugin loader\n */\nexport function createAdvancedPluginLoader(options: {\n  searchPaths?: string[];\n  enableHotReload?: boolean;\n} = {}): AdvancedPluginLoader {\n  return new AdvancedPluginLoader(options);\n}\n"],"names":[],"mappings":"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"}