{"version":3,"file":"index.js","sources":["../../src/recovery/index.ts"],"sourcesContent":["/**\n * Recovery Module\n *\n * Provides backup, restore, and integrity checking capabilities.\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface BackupConfig {\n  backupDir: string;\n  maxBackups?: number;\n  compress?: boolean;\n  includeDatabase?: boolean;\n  includeCache?: boolean;\n  includeConfig?: boolean;\n}\n\nexport interface BackupInfo {\n  id: string;\n  path: string;\n  createdAt: Date;\n  size: number;\n  components: string[];\n  version: string;\n  checksum?: string;\n}\n\nexport interface RestoreResult {\n  success: boolean;\n  restoredComponents: string[];\n  error?: string;\n  warnings: string[];\n  duration: number;\n}\n\nexport interface RecoveryOptions {\n  force?: boolean;\n  verify?: boolean;\n  skipComponents?: string[];\n  dryRun?: boolean;\n}\n\nexport interface IntegrityCheckResult {\n  valid: boolean;\n  components: TableIntegrity[];\n  issues: string[];\n  duration: number;\n}\n\nexport interface TableIntegrity {\n  table: string;\n  rowCount: number;\n  validStructure: boolean;\n  fkViolations: number;\n  orphanedRecords: number;\n}\n\n// ============================================================================\n// Backup Manager\n// ============================================================================\n\nexport class BackupManager {\n  private config: BackupConfig;\n\n  constructor(config: BackupConfig) {\n    this.config = {\n      maxBackups: 10,\n      compress: true,\n      includeDatabase: true,\n      includeCache: true,\n      includeConfig: true,\n      ...config,\n    };\n  }\n\n  async createBackup(description?: string): Promise<BackupInfo> {\n    const { mkdirSync, existsSync, writeFileSync, statSync } = await import('fs');\n    const { join } = await import('path');\n    const crypto = await import('crypto');\n\n    if (!existsSync(this.config.backupDir)) {\n      mkdirSync(this.config.backupDir, { recursive: true });\n    }\n\n    const id = `backup-${Date.now()}`;\n    const backupPath = join(this.config.backupDir, id);\n    mkdirSync(backupPath, { recursive: true });\n\n    const components: string[] = [];\n    const manifest = {\n      id,\n      createdAt: new Date().toISOString(),\n      description,\n      version: '1.0.0',\n      components,\n    };\n\n    writeFileSync(join(backupPath, 'manifest.json'), JSON.stringify(manifest, null, 2));\n    const stats = statSync(backupPath);\n    const hash = crypto.createHash('sha256');\n    hash.update(JSON.stringify(manifest));\n    const checksum = hash.digest('hex');\n\n    const backupInfo: BackupInfo = {\n      id,\n      path: backupPath,\n      createdAt: new Date(),\n      size: stats.size,\n      components,\n      version: '1.0.0',\n      checksum,\n    };\n\n    await this.cleanupOldBackups();\n    return backupInfo;\n  }\n\n  async listBackups(): Promise<BackupInfo[]> {\n    const { readdirSync, existsSync, readFileSync, statSync } = await import('fs');\n    const { join } = await import('path');\n\n    if (!existsSync(this.config.backupDir)) return [];\n\n    const backups: BackupInfo[] = [];\n    const entries = readdirSync(this.config.backupDir);\n\n    for (const entry of entries) {\n      const backupPath = join(this.config.backupDir, entry);\n      const manifestPath = join(backupPath, 'manifest.json');\n\n      if (existsSync(manifestPath)) {\n        try {\n          const manifest = JSON.parse(readFileSync(manifestPath, 'utf-8'));\n          const stats = statSync(backupPath);\n          backups.push({\n            id: manifest.id,\n            path: backupPath,\n            createdAt: new Date(manifest.createdAt),\n            size: stats.size,\n            components: manifest.components || [],\n            version: manifest.version || '1.0.0',\n            checksum: manifest.checksum,\n          });\n        } catch {}\n      }\n    }\n\n    return backups.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n  }\n\n  async restore(backupId: string, options: RecoveryOptions = {}): Promise<RestoreResult> {\n    const startTime = Date.now();\n    const { existsSync, readFileSync } = await import('fs');\n    const { join } = await import('path');\n\n    const backupPath = join(this.config.backupDir, backupId);\n    const manifestPath = join(backupPath, 'manifest.json');\n\n    if (!existsSync(manifestPath)) {\n      return {\n        success: false,\n        restoredComponents: [],\n        error: `Backup not found: ${backupId}`,\n        warnings: [],\n        duration: Date.now() - startTime,\n      };\n    }\n\n    try {\n      const manifest = JSON.parse(readFileSync(manifestPath, 'utf-8'));\n      const restoredComponents: string[] = [];\n      const warnings: string[] = [];\n\n      if (options.dryRun) {\n        return {\n          success: true,\n          restoredComponents: manifest.components || [],\n          warnings: ['Dry run - no changes made'],\n          duration: Date.now() - startTime,\n        };\n      }\n\n      restoredComponents.push(...(manifest.components || []));\n\n      return {\n        success: true,\n        restoredComponents,\n        warnings,\n        duration: Date.now() - startTime,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        restoredComponents: [],\n        error: error instanceof Error ? error.message : String(error),\n        warnings: [],\n        duration: Date.now() - startTime,\n      };\n    }\n  }\n\n  async deleteBackup(backupId: string): Promise<boolean> {\n    const { existsSync, rmSync } = await import('fs');\n    const { join } = await import('path');\n\n    const backupPath = join(this.config.backupDir, backupId);\n    if (!existsSync(backupPath)) return false;\n\n    rmSync(backupPath, { recursive: true, force: true });\n    return true;\n  }\n\n  private async cleanupOldBackups(): Promise<void> {\n    const backups = await this.listBackups();\n    const maxBackups = this.config.maxBackups || 10;\n\n    if (backups.length > maxBackups) {\n      const toDelete = backups.slice(maxBackups);\n      for (const backup of toDelete) {\n        await this.deleteBackup(backup.id);\n      }\n    }\n  }\n}\n\nexport function createBackupManager(config: BackupConfig): BackupManager {\n  return new BackupManager(config);\n}\n\n// ============================================================================\n// Integrity Checker\n// ============================================================================\n\nexport class IntegrityChecker {\n  private dbPath: string;\n\n  constructor(dbPath: string) {\n    this.dbPath = dbPath;\n  }\n\n  async check(): Promise<IntegrityCheckResult> {\n    const startTime = Date.now();\n    const issues: string[] = [];\n    const components: TableIntegrity[] = [];\n    const { existsSync } = await import('fs');\n\n    if (!existsSync(this.dbPath)) {\n      return {\n        valid: false,\n        components: [],\n        issues: ['Database file not found'],\n        duration: Date.now() - startTime,\n      };\n    }\n\n    return {\n      valid: issues.length === 0,\n      components,\n      issues,\n      duration: Date.now() - startTime,\n    };\n  }\n\n  async repair(): Promise<{ repaired: boolean; actions: string[] }> {\n    const actions: string[] = [];\n    return { repaired: true, actions };\n  }\n}\n\nexport function createIntegrityChecker(dbPath: string): IntegrityChecker {\n  return new IntegrityChecker(dbPath);\n}\n\nexport async function checkDatabaseIntegrity(dbPath: string): Promise<IntegrityCheckResult> {\n  const checker = new IntegrityChecker(dbPath);\n  return checker.check();\n}\n"],"names":[],"mappings":"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"}