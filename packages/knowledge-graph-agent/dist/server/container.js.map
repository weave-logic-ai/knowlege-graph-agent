{"version":3,"file":"container.js","sources":["../../src/server/container.ts"],"sourcesContent":["/**\n * Service Container - Singleton Pattern for Concurrent Server Execution\n *\n * Provides a centralized container for managing all shared services across\n * MCP, GraphQL, and Dashboard servers. Implements lazy initialization,\n * dependency injection, and coordinated lifecycle management.\n *\n * @module server/container\n */\n\nimport { join, resolve } from 'path';\nimport { existsSync, mkdirSync } from 'fs';\nimport { KnowledgeGraphDatabase, createDatabase } from '../core/database.js';\nimport { AdvancedCache, createAdvancedCache } from '../caching/index.js';\nimport { ConfigManager } from '../config/manager.js';\nimport {\n  HealthMonitor,\n  createHealthMonitor,\n  createMemoryCheck,\n  createDatabaseCheck,\n  type SystemHealth,\n} from '../health/index.js';\nimport { AgentRegistry, createRegistry } from '../agents/registry.js';\nimport { WorkflowRegistry, createWorkflowRegistry } from '../workflows/registry.js';\nimport { ServiceManager, createServiceManager } from '../services/manager.js';\nimport { TypedEventBus, createTypedEventBus } from './event-bus.js';\nimport { createLogger } from '../utils/index.js';\nimport type { HealthStatus, ComponentHealth } from './types.js';\nimport type { CacheConfig } from '../caching/index.js';\nimport type { PluginManager } from '../plugins/types.js';\n\nconst logger = createLogger('service-container');\n\n/**\n * Emit a container lifecycle event using the underlying emitter\n */\nfunction emitContainerEvent(\n  eventBus: TypedEventBus,\n  type: ContainerEventType,\n  source: string,\n  data: Record<string, unknown>\n): void {\n  const emitter = eventBus.getEmitter();\n  emitter.emit(type, {\n    type,\n    source,\n    timestamp: new Date(),\n    data,\n  });\n}\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Service initialization state\n */\nexport type ServiceInitState = 'uninitialized' | 'initializing' | 'initialized' | 'failed';\n\n/**\n * Service dependency graph - defines initialization order\n */\nexport interface ServiceDependency {\n  name: string;\n  dependsOn: string[];\n  priority: number; // Lower = earlier initialization\n}\n\n/**\n * Container configuration options\n */\nexport interface ContainerConfig {\n  /** Project root directory */\n  projectRoot: string;\n  /** Database path (relative to projectRoot) */\n  databasePath?: string;\n  /** Enable WAL mode for SQLite */\n  walMode?: boolean;\n  /** Cache configuration */\n  cache?: Partial<CacheConfig>;\n  /** Enable health monitoring */\n  enableHealthMonitoring?: boolean;\n  /** Health check interval in ms */\n  healthCheckInterval?: number;\n  /** Max agents per type */\n  maxAgentsPerType?: number;\n  /** Enable verbose logging */\n  verbose?: boolean;\n}\n\n/**\n * Container event types\n */\nexport type ContainerEventType =\n  | 'service:initializing'\n  | 'service:initialized'\n  | 'service:failed'\n  | 'service:shutting-down'\n  | 'container:ready'\n  | 'container:shutdown';\n\n// ============================================================================\n// Service Container Implementation\n// ============================================================================\n\n/**\n * ServiceContainer - Singleton for shared service management\n *\n * Manages the lifecycle of all shared services across concurrent server\n * instances. Provides lazy initialization, dependency injection, and\n * coordinated shutdown.\n *\n * @example\n * ```typescript\n * // Get or create the singleton instance\n * const container = ServiceContainer.getInstance({\n *   projectRoot: '/path/to/project',\n * });\n *\n * // Initialize all services\n * await container.initialize();\n *\n * // Access services\n * const db = container.getDatabase();\n * const cache = container.getCache();\n *\n * // Graceful shutdown\n * await container.shutdown();\n * ```\n */\nexport class ServiceContainer {\n  private static instance: ServiceContainer | null = null;\n  private static instanceLock = false;\n\n  // Service instances (lazy initialized)\n  private _database: KnowledgeGraphDatabase | null = null;\n  private _cache: AdvancedCache | null = null;\n  private _configManager: ConfigManager | null = null;\n  private _healthMonitor: HealthMonitor | null = null;\n  private _agentRegistry: AgentRegistry | null = null;\n  private _workflowRegistry: WorkflowRegistry | null = null;\n  private _pluginManager: PluginManager | null = null;\n  private _eventBus: TypedEventBus;\n  private _serviceManager: ServiceManager | null = null;\n\n  // State tracking\n  private _config: ContainerConfig;\n  private _initState: ServiceInitState = 'uninitialized';\n  private _initPromise: Promise<void> | null = null;\n  private _startTime: number = 0;\n  private _shutdownInProgress = false;\n\n  // Service initialization tracking\n  private _serviceStates: Map<string, ServiceInitState> = new Map();\n\n  /**\n   * Private constructor - use getInstance() instead\n   */\n  private constructor(config: ContainerConfig) {\n    this._config = this.normalizeConfig(config);\n    this._eventBus = createTypedEventBus({\n      maxHistorySize: 1000,\n      historyRetention: 60 * 60 * 1000, // 1 hour\n      debugEvents: config.verbose ?? false,\n    });\n\n    // Initialize service state tracking\n    this.initializeServiceStates();\n\n    logger.debug('ServiceContainer instance created', {\n      projectRoot: this._config.projectRoot,\n    });\n  }\n\n  /**\n   * Normalize and validate configuration\n   */\n  private normalizeConfig(config: ContainerConfig): ContainerConfig {\n    return {\n      projectRoot: resolve(config.projectRoot),\n      databasePath: config.databasePath ?? '.kg/knowledge.db',\n      walMode: config.walMode ?? true,\n      cache: {\n        maxSize: config.cache?.maxSize ?? 100 * 1024 * 1024, // 100MB\n        maxEntries: config.cache?.maxEntries ?? 10000,\n        defaultTtl: config.cache?.defaultTtl ?? 3600000, // 1 hour\n        evictionPolicy: config.cache?.evictionPolicy ?? 'lru',\n      },\n      enableHealthMonitoring: config.enableHealthMonitoring ?? true,\n      healthCheckInterval: config.healthCheckInterval ?? 60000,\n      maxAgentsPerType: config.maxAgentsPerType ?? 10,\n      verbose: config.verbose ?? false,\n    };\n  }\n\n  /**\n   * Initialize service state tracking\n   */\n  private initializeServiceStates(): void {\n    const services = [\n      'database',\n      'cache',\n      'configManager',\n      'healthMonitor',\n      'agentRegistry',\n      'workflowRegistry',\n      'serviceManager',\n      'pluginManager',\n    ];\n\n    for (const service of services) {\n      this._serviceStates.set(service, 'uninitialized');\n    }\n  }\n\n  // ============================================================================\n  // Singleton Pattern\n  // ============================================================================\n\n  /**\n   * Get the singleton instance, optionally creating it with config\n   *\n   * @param config - Configuration for new instance (required if no instance exists)\n   * @returns The singleton ServiceContainer instance\n   * @throws Error if no instance exists and no config provided\n   */\n  static getInstance(config?: ContainerConfig): ServiceContainer {\n    if (ServiceContainer.instance) {\n      // Update config if provided\n      if (config) {\n        ServiceContainer.instance._config = ServiceContainer.instance.normalizeConfig(config);\n      }\n      return ServiceContainer.instance;\n    }\n\n    if (!config) {\n      throw new Error('ServiceContainer not initialized. Provide config.');\n    }\n\n    // Prevent concurrent instance creation\n    if (ServiceContainer.instanceLock) {\n      throw new Error('ServiceContainer is being initialized by another caller.');\n    }\n\n    ServiceContainer.instanceLock = true;\n    try {\n      ServiceContainer.instance = new ServiceContainer(config);\n    } finally {\n      ServiceContainer.instanceLock = false;\n    }\n\n    return ServiceContainer.instance;\n  }\n\n  /**\n   * Check if an instance exists\n   */\n  static hasInstance(): boolean {\n    return ServiceContainer.instance !== null;\n  }\n\n  /**\n   * Reset the singleton instance (for testing)\n   */\n  static async resetInstance(): Promise<void> {\n    if (ServiceContainer.instance) {\n      await ServiceContainer.instance.shutdown();\n      ServiceContainer.instance = null;\n    }\n  }\n\n  // ============================================================================\n  // Service Accessors (Lazy Initialization)\n  // ============================================================================\n\n  /**\n   * Get the database instance\n   * @throws Error if container not initialized\n   */\n  getDatabase(): KnowledgeGraphDatabase {\n    this.assertInitialized();\n    if (!this._database) {\n      throw new Error('Database not initialized');\n    }\n    return this._database;\n  }\n\n  /**\n   * Get the advanced cache instance\n   * @throws Error if container not initialized\n   */\n  getCache(): AdvancedCache {\n    this.assertInitialized();\n    if (!this._cache) {\n      throw new Error('Cache not initialized');\n    }\n    return this._cache;\n  }\n\n  /**\n   * Get the configuration manager\n   * @throws Error if container not initialized\n   */\n  getConfig(): ConfigManager {\n    this.assertInitialized();\n    if (!this._configManager) {\n      throw new Error('ConfigManager not initialized');\n    }\n    return this._configManager;\n  }\n\n  /**\n   * Get the health monitor\n   * @throws Error if container not initialized\n   */\n  getHealthMonitor(): HealthMonitor {\n    this.assertInitialized();\n    if (!this._healthMonitor) {\n      throw new Error('HealthMonitor not initialized');\n    }\n    return this._healthMonitor;\n  }\n\n  /**\n   * Get the agent registry\n   * @throws Error if container not initialized\n   */\n  getAgentRegistry(): AgentRegistry {\n    this.assertInitialized();\n    if (!this._agentRegistry) {\n      throw new Error('AgentRegistry not initialized');\n    }\n    return this._agentRegistry;\n  }\n\n  /**\n   * Get the workflow registry\n   * @throws Error if container not initialized\n   */\n  getWorkflowRegistry(): WorkflowRegistry {\n    this.assertInitialized();\n    if (!this._workflowRegistry) {\n      throw new Error('WorkflowRegistry not initialized');\n    }\n    return this._workflowRegistry;\n  }\n\n  /**\n   * Get the plugin manager (if available)\n   */\n  getPluginManager(): PluginManager | null {\n    this.assertInitialized();\n    return this._pluginManager;\n  }\n\n  /**\n   * Get the typed event bus for cross-service communication\n   */\n  getEventBus(): TypedEventBus {\n    return this._eventBus;\n  }\n\n  /**\n   * Get the service manager for background services\n   * @throws Error if container not initialized\n   */\n  getServiceManager(): ServiceManager {\n    this.assertInitialized();\n    if (!this._serviceManager) {\n      throw new Error('ServiceManager not initialized');\n    }\n    return this._serviceManager;\n  }\n\n  /**\n   * Get the project root directory\n   */\n  getProjectRoot(): string {\n    return this._config.projectRoot;\n  }\n\n  /**\n   * Get the container configuration\n   */\n  getContainerConfig(): Readonly<ContainerConfig> {\n    return Object.freeze({ ...this._config });\n  }\n\n  // ============================================================================\n  // Lifecycle Management\n  // ============================================================================\n\n  /**\n   * Initialize all services in dependency order\n   */\n  async initialize(): Promise<void> {\n    // Return existing promise if already initializing\n    if (this._initPromise) {\n      return this._initPromise;\n    }\n\n    // Return immediately if already initialized\n    if (this._initState === 'initialized') {\n      logger.debug('ServiceContainer already initialized');\n      return;\n    }\n\n    this._initPromise = this._doInitialize();\n\n    try {\n      await this._initPromise;\n    } finally {\n      this._initPromise = null;\n    }\n  }\n\n  /**\n   * Internal initialization logic with dependency ordering\n   */\n  private async _doInitialize(): Promise<void> {\n    if (this._initState === 'initializing') {\n      throw new Error('Initialization already in progress');\n    }\n\n    this._initState = 'initializing';\n    this._startTime = Date.now();\n\n    logger.info('Initializing ServiceContainer...');\n    emitContainerEvent(this._eventBus, 'container:initializing' as ContainerEventType, 'container', {});\n\n    try {\n      // Ensure .kg directory exists\n      await this.ensureDirectories();\n\n      // Initialize services in dependency order\n      // Phase 1: Core services (no dependencies)\n      await this.initializeService('configManager', () => this.initConfigManager());\n      await this.initializeService('database', () => this.initDatabase());\n      await this.initializeService('cache', () => this.initCache());\n\n      // Phase 2: Dependent services\n      await this.initializeService('healthMonitor', () => this.initHealthMonitor());\n      await this.initializeService('serviceManager', () => this.initServiceManager());\n\n      // Phase 3: High-level services\n      await this.initializeService('agentRegistry', () => this.initAgentRegistry());\n      await this.initializeService('workflowRegistry', () => this.initWorkflowRegistry());\n\n      // Phase 4: Optional services\n      // Plugin manager initialization would go here when implemented\n\n      this._initState = 'initialized';\n\n      const initTime = Date.now() - this._startTime;\n      logger.info('ServiceContainer initialized successfully', {\n        initTimeMs: initTime,\n        services: Array.from(this._serviceStates.entries())\n          .filter(([, state]) => state === 'initialized')\n          .map(([name]) => name),\n      });\n\n      emitContainerEvent(this._eventBus, 'container:ready', 'container', {\n        initTimeMs: initTime,\n      });\n    } catch (error) {\n      this._initState = 'failed';\n\n      logger.error(\n        'Failed to initialize ServiceContainer',\n        error instanceof Error ? error : new Error(String(error))\n      );\n\n      emitContainerEvent(this._eventBus, 'container:failed' as ContainerEventType, 'container', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      // Cleanup partial initialization\n      await this._cleanup();\n\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize a single service with state tracking\n   */\n  private async initializeService(\n    name: string,\n    initializer: () => Promise<void>\n  ): Promise<void> {\n    this._serviceStates.set(name, 'initializing');\n    emitContainerEvent(this._eventBus, 'service:initializing', 'container', { service: name });\n\n    try {\n      await initializer();\n      this._serviceStates.set(name, 'initialized');\n      emitContainerEvent(this._eventBus, 'service:initialized', 'container', { service: name });\n      logger.debug(`Service initialized: ${name}`);\n    } catch (error) {\n      this._serviceStates.set(name, 'failed');\n      emitContainerEvent(this._eventBus, 'service:failed', 'container', {\n        service: name,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Ensure required directories exist\n   */\n  private async ensureDirectories(): Promise<void> {\n    const kgDir = join(this._config.projectRoot, '.kg');\n    if (!existsSync(kgDir)) {\n      mkdirSync(kgDir, { recursive: true });\n      logger.debug('Created .kg directory');\n    }\n  }\n\n  // ============================================================================\n  // Service Initializers\n  // ============================================================================\n\n  private async initConfigManager(): Promise<void> {\n    this._configManager = new ConfigManager(this._config.projectRoot);\n  }\n\n  private async initDatabase(): Promise<void> {\n    const dbPath = join(this._config.projectRoot, this._config.databasePath!);\n    this._database = createDatabase(dbPath);\n    logger.debug('Database initialized', { path: dbPath });\n  }\n\n  private async initCache(): Promise<void> {\n    this._cache = createAdvancedCache({\n      maxSize: this._config.cache?.maxSize,\n      maxEntries: this._config.cache?.maxEntries,\n      defaultTtl: this._config.cache?.defaultTtl,\n      evictionPolicy: this._config.cache?.evictionPolicy,\n      enableStats: true,\n    });\n    logger.debug('Cache initialized');\n  }\n\n  private async initHealthMonitor(): Promise<void> {\n    this._healthMonitor = createHealthMonitor({\n      interval: this._config.healthCheckInterval,\n      autoStart: false,\n    });\n\n    // Register built-in health checks\n    this._healthMonitor.register(createMemoryCheck(85)); // 85% threshold\n\n    if (this._database) {\n      const dbPath = join(this._config.projectRoot, this._config.databasePath!);\n      this._healthMonitor.register(createDatabaseCheck(dbPath));\n    }\n\n    if (this._config.enableHealthMonitoring) {\n      this._healthMonitor.start();\n    }\n\n    logger.debug('Health monitor initialized');\n  }\n\n  private async initServiceManager(): Promise<void> {\n    this._serviceManager = createServiceManager();\n    logger.debug('Service manager initialized');\n  }\n\n  private async initAgentRegistry(): Promise<void> {\n    this._agentRegistry = createRegistry({\n      enableHealthMonitoring: this._config.enableHealthMonitoring,\n      healthCheckInterval: this._config.healthCheckInterval,\n      maxAgentsPerType: this._config.maxAgentsPerType,\n    });\n    logger.debug('Agent registry initialized');\n  }\n\n  private async initWorkflowRegistry(): Promise<void> {\n    this._workflowRegistry = createWorkflowRegistry({\n      maxConcurrentExecutions: 10,\n      persistHistory: true,\n      maxHistoryEntries: 1000,\n    });\n    logger.debug('Workflow registry initialized');\n  }\n\n  // ============================================================================\n  // Shutdown\n  // ============================================================================\n\n  /**\n   * Gracefully shutdown all services in reverse dependency order\n   */\n  async shutdown(): Promise<void> {\n    if (this._shutdownInProgress) {\n      logger.warn('Shutdown already in progress');\n      return;\n    }\n\n    if (this._initState === 'uninitialized') {\n      logger.debug('ServiceContainer not initialized, nothing to shutdown');\n      return;\n    }\n\n    this._shutdownInProgress = true;\n    logger.info('Shutting down ServiceContainer...');\n    emitContainerEvent(this._eventBus, 'container:shutdown', 'container', {});\n\n    await this._cleanup();\n\n    this._initState = 'uninitialized';\n    this._shutdownInProgress = false;\n\n    logger.info('ServiceContainer shutdown complete');\n  }\n\n  /**\n   * Internal cleanup logic - shutdown services in reverse order\n   */\n  private async _cleanup(): Promise<void> {\n    // Shutdown in reverse dependency order\n\n    // Phase 4: Optional services (first to shutdown)\n    // Plugin manager would be cleaned up here\n\n    // Phase 3: High-level services\n    await this.shutdownService('workflowRegistry', async () => {\n      if (this._workflowRegistry) {\n        // WorkflowRegistry doesn't have a dispose, but we can clear active executions\n        this._workflowRegistry.clear();\n        this._workflowRegistry = null;\n      }\n    });\n\n    await this.shutdownService('agentRegistry', async () => {\n      if (this._agentRegistry) {\n        await this._agentRegistry.dispose();\n        this._agentRegistry = null;\n      }\n    });\n\n    // Phase 2: Dependent services\n    await this.shutdownService('serviceManager', async () => {\n      if (this._serviceManager) {\n        await this._serviceManager.shutdown();\n        this._serviceManager = null;\n      }\n    });\n\n    await this.shutdownService('healthMonitor', async () => {\n      if (this._healthMonitor) {\n        this._healthMonitor.stop();\n        this._healthMonitor = null;\n      }\n    });\n\n    // Phase 1: Core services (last to shutdown)\n    await this.shutdownService('cache', async () => {\n      if (this._cache) {\n        // AdvancedCache doesn't have explicit cleanup, just clear\n        this._cache.clear();\n        this._cache = null;\n      }\n    });\n\n    await this.shutdownService('database', async () => {\n      if (this._database) {\n        this._database.close();\n        this._database = null;\n      }\n    });\n\n    await this.shutdownService('configManager', async () => {\n      if (this._configManager) {\n        // Save any pending config changes\n        try {\n          this._configManager.save();\n        } catch {\n          // Ignore save errors during shutdown\n        }\n        this._configManager = null;\n      }\n    });\n  }\n\n  /**\n   * Shutdown a single service with error handling\n   */\n  private async shutdownService(\n    name: string,\n    cleanup: () => Promise<void>\n  ): Promise<void> {\n    if (this._serviceStates.get(name) !== 'initialized') {\n      return;\n    }\n\n    emitContainerEvent(this._eventBus, 'service:shutting-down', 'container', { service: name });\n\n    try {\n      await cleanup();\n      this._serviceStates.set(name, 'uninitialized');\n      logger.debug(`Service shutdown complete: ${name}`);\n    } catch (error) {\n      logger.error(`Error shutting down ${name}`, error as Error);\n      this._serviceStates.set(name, 'failed');\n    }\n  }\n\n  // ============================================================================\n  // Health & Status\n  // ============================================================================\n\n  /**\n   * Check if container is initialized\n   */\n  isInitialized(): boolean {\n    return this._initState === 'initialized';\n  }\n\n  /**\n   * Get initialization state\n   */\n  getInitState(): ServiceInitState {\n    return this._initState;\n  }\n\n  /**\n   * Get individual service states\n   */\n  getServiceStates(): Map<string, ServiceInitState> {\n    return new Map(this._serviceStates);\n  }\n\n  /**\n   * Get comprehensive health status\n   */\n  getHealth(): HealthStatus {\n    const components: ComponentHealth[] = [];\n    const now = new Date();\n\n    // Check each service\n    const serviceEntries = Array.from(this._serviceStates.entries());\n    for (const [name, state] of serviceEntries) {\n      components.push({\n        name,\n        healthy: state === 'initialized',\n        message: state,\n        lastCheck: now,\n      });\n    }\n\n    // Add health monitor results if available\n    if (this._healthMonitor && this._initState === 'initialized') {\n      try {\n        const systemHealth = this._healthMonitor.getLastStatus();\n        for (const component of systemHealth.components) {\n          components.push({\n            name: `monitor:${component.name}`,\n            healthy: component.status === 'healthy',\n            message: component.message,\n            metrics: component.metadata as Record<string, number | string> | undefined,\n            lastCheck: component.lastCheck,\n          });\n        }\n      } catch {\n        // Health monitor might not be ready\n      }\n    }\n\n    // Calculate overall health\n    const unhealthyCount = components.filter((c) => !c.healthy).length;\n    const overallHealthy = unhealthyCount === 0;\n    const status: HealthStatus['status'] =\n      unhealthyCount === 0 ? 'healthy' : unhealthyCount < 2 ? 'degraded' : 'unhealthy';\n\n    // Memory usage\n    const memUsage = process.memoryUsage();\n\n    return {\n      healthy: overallHealthy,\n      status,\n      components,\n      uptime: this._initState === 'initialized' ? Date.now() - this._startTime : 0,\n      totalRequests: 0, // Updated by server manager\n      memory: {\n        heapUsed: memUsage.heapUsed,\n        heapTotal: memUsage.heapTotal,\n        external: memUsage.external,\n        rss: memUsage.rss,\n      },\n    };\n  }\n\n  /**\n   * Get uptime in milliseconds\n   */\n  getUptime(): number {\n    if (this._initState !== 'initialized') {\n      return 0;\n    }\n    return Date.now() - this._startTime;\n  }\n\n  // ============================================================================\n  // Helper Methods\n  // ============================================================================\n\n  /**\n   * Assert that the container is initialized\n   * @throws Error if not initialized\n   */\n  private assertInitialized(): void {\n    if (this._initState !== 'initialized') {\n      throw new Error('ServiceContainer not initialized. Call initialize() first.');\n    }\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\n/**\n * Create and initialize a service container\n *\n * @param config - Container configuration\n * @returns Initialized ServiceContainer\n */\nexport async function createServiceContainer(\n  config: ContainerConfig\n): Promise<ServiceContainer> {\n  const container = ServiceContainer.getInstance(config);\n  await container.initialize();\n  return container;\n}\n\n/**\n * Get existing service container instance\n *\n * @returns ServiceContainer if initialized\n * @throws Error if not initialized\n */\nexport function getServiceContainer(): ServiceContainer {\n  if (!ServiceContainer.hasInstance()) {\n    throw new Error('ServiceContainer not initialized. Call createServiceContainer() first.');\n  }\n  return ServiceContainer.getInstance();\n}\n\n/**\n * Check if service container is available\n */\nexport function hasServiceContainer(): boolean {\n  return ServiceContainer.hasInstance();\n}\n\n/**\n * Shutdown and reset the service container\n */\nexport async function shutdownServiceContainer(): Promise<void> {\n  await ServiceContainer.resetInstance();\n}\n"],"names":[],"mappings":"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"}