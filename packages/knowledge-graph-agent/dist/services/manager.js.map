{"version":3,"file":"manager.js","sources":["../../src/services/manager.ts"],"sourcesContent":["/**\n * Service Manager - Background process management\n *\n * Provides centralized management for background services including:\n * - Service registration and lifecycle management\n * - Health monitoring with configurable intervals\n * - Automatic restart on failure\n * - Graceful shutdown coordination\n *\n * @module services/manager\n */\n\nimport { EventEmitter } from 'events';\nimport { createLogger } from '../utils/index.js';\nimport type {\n  ServiceConfig,\n  ServiceState,\n  ServiceHandler,\n  ServiceMetrics,\n} from './types.js';\n\nconst logger = createLogger('service-manager');\n\n/**\n * Manages background services with lifecycle control and health monitoring.\n *\n * @example\n * ```typescript\n * const manager = createServiceManager();\n *\n * await manager.register(\n *   { id: 'watcher', name: 'File Watcher', type: 'watcher', autoStart: true },\n *   new FileWatcherService(['/path/to/watch'])\n * );\n *\n * manager.on('started', (state) => console.log(`${state.name} started`));\n *\n * // Graceful shutdown\n * process.on('SIGTERM', () => manager.shutdown());\n * ```\n */\nexport class ServiceManager extends EventEmitter {\n  private services: Map<string, ServiceState> = new Map();\n  private handlers: Map<string, ServiceHandler> = new Map();\n  private configs: Map<string, ServiceConfig> = new Map();\n  private healthCheckTimers: Map<string, NodeJS.Timeout> = new Map();\n  private isShuttingDown = false;\n\n  constructor() {\n    super();\n    logger.info('ServiceManager initialized');\n  }\n\n  /**\n   * Register a new service with the manager.\n   *\n   * @param config - Service configuration\n   * @param handler - Service implementation\n   * @throws Error if service ID is already registered\n   */\n  async register(config: ServiceConfig, handler: ServiceHandler): Promise<void> {\n    if (this.services.has(config.id)) {\n      throw new Error(`Service ${config.id} already registered`);\n    }\n\n    const state: ServiceState = {\n      id: config.id,\n      name: config.name,\n      type: config.type,\n      status: 'stopped',\n      restarts: 0,\n      metrics: {\n        uptime: 0,\n        requests: 0,\n        errors: 0,\n        healthStatus: 'healthy',\n      },\n    };\n\n    this.services.set(config.id, state);\n    this.handlers.set(config.id, handler);\n    this.configs.set(config.id, config);\n\n    logger.info(`Service registered: ${config.name}`, {\n      id: config.id,\n      type: config.type,\n      autoStart: config.autoStart,\n    });\n    this.emit('registered', state);\n\n    if (config.autoStart) {\n      await this.start(config.id);\n    }\n\n    if (config.healthCheckInterval && config.healthCheckInterval > 0) {\n      this.startHealthCheck(config.id, config.healthCheckInterval);\n    }\n  }\n\n  /**\n   * Start a registered service.\n   *\n   * @param id - Service identifier\n   * @throws Error if service is not found\n   */\n  async start(id: string): Promise<void> {\n    const state = this.services.get(id);\n    const handler = this.handlers.get(id);\n\n    if (!state || !handler) {\n      throw new Error(`Service ${id} not found`);\n    }\n\n    if (state.status === 'running' || state.status === 'starting') {\n      logger.debug(`Service ${state.name} already ${state.status}`);\n      return;\n    }\n\n    state.status = 'starting';\n    this.emit('starting', state);\n\n    try {\n      await handler.start();\n      state.status = 'running';\n      state.startTime = new Date();\n      state.lastError = undefined;\n      logger.info(`Service started: ${state.name}`);\n      this.emit('started', state);\n    } catch (error) {\n      state.status = 'failed';\n      state.lastError = error instanceof Error ? error.message : String(error);\n      state.metrics.errors++;\n      logger.error(`Service failed to start: ${state.name}`, undefined, { error: state.lastError });\n      this.emit('failed', state);\n\n      // Handle auto-restart\n      await this.handleFailure(id);\n    }\n  }\n\n  /**\n   * Stop a running service.\n   *\n   * @param id - Service identifier\n   * @throws Error if service is not found\n   */\n  async stop(id: string): Promise<void> {\n    const state = this.services.get(id);\n    const handler = this.handlers.get(id);\n\n    if (!state || !handler) {\n      throw new Error(`Service ${id} not found`);\n    }\n\n    if (state.status === 'stopped' || state.status === 'stopping') {\n      logger.debug(`Service ${state.name} already ${state.status}`);\n      return;\n    }\n\n    state.status = 'stopping';\n    this.emit('stopping', state);\n\n    try {\n      await handler.stop();\n      state.status = 'stopped';\n\n      // Calculate final uptime\n      if (state.startTime) {\n        state.metrics.uptime += Date.now() - state.startTime.getTime();\n      }\n\n      logger.info(`Service stopped: ${state.name}`);\n      this.emit('stopped', state);\n    } catch (error) {\n      state.status = 'failed';\n      state.lastError = error instanceof Error ? error.message : String(error);\n      state.metrics.errors++;\n      logger.error(`Service failed to stop: ${state.name}`, undefined, { error: state.lastError });\n      this.emit('failed', state);\n    }\n  }\n\n  /**\n   * Restart a service.\n   *\n   * @param id - Service identifier\n   * @throws Error if service is not found\n   */\n  async restart(id: string): Promise<void> {\n    const state = this.services.get(id);\n    if (!state) {\n      throw new Error(`Service ${id} not found`);\n    }\n\n    logger.info(`Restarting service: ${state.name}`);\n    state.restarts++;\n\n    await this.stop(id);\n    await this.start(id);\n\n    this.emit('restarted', state);\n  }\n\n  /**\n   * Handle service failure with optional auto-restart.\n   */\n  private async handleFailure(id: string): Promise<void> {\n    const state = this.services.get(id);\n    const config = this.configs.get(id);\n\n    if (!state || !config) return;\n\n    if (!config.restartOnFailure) return;\n\n    const maxRestarts = config.maxRestarts ?? 3;\n    if (state.restarts >= maxRestarts) {\n      logger.error(`Service ${state.name} exceeded max restarts (${maxRestarts})`);\n      return;\n    }\n\n    const delay = config.restartDelay ?? 1000;\n    logger.info(`Scheduling restart for ${state.name} in ${delay}ms`);\n\n    await new Promise(resolve => setTimeout(resolve, delay));\n\n    if (!this.isShuttingDown && state.status === 'failed') {\n      state.restarts++;\n      await this.start(id);\n    }\n  }\n\n  /**\n   * Get the current state of a service.\n   *\n   * @param id - Service identifier\n   * @returns Service state or undefined if not found\n   */\n  getStatus(id: string): ServiceState | undefined {\n    const state = this.services.get(id);\n    if (!state) return undefined;\n\n    const handler = this.handlers.get(id);\n    if (handler && state.status === 'running') {\n      // Update metrics from handler\n      const metrics = handler.getMetrics();\n      state.metrics = { ...state.metrics, ...metrics };\n    }\n\n    return { ...state };\n  }\n\n  /**\n   * List all registered services.\n   *\n   * @returns Array of service states\n   */\n  listServices(): ServiceState[] {\n    return Array.from(this.services.values()).map(state => ({ ...state }));\n  }\n\n  /**\n   * Get services by type.\n   *\n   * @param type - Service type to filter by\n   * @returns Array of matching service states\n   */\n  getServicesByType(type: string): ServiceState[] {\n    return this.listServices().filter(s => s.type === type);\n  }\n\n  /**\n   * Get services by status.\n   *\n   * @param status - Service status to filter by\n   * @returns Array of matching service states\n   */\n  getServicesByStatus(status: string): ServiceState[] {\n    return this.listServices().filter(s => s.status === status);\n  }\n\n  /**\n   * Start periodic health checks for a service.\n   */\n  private startHealthCheck(id: string, interval: number): void {\n    // Clear any existing timer\n    const existingTimer = this.healthCheckTimers.get(id);\n    if (existingTimer) {\n      clearInterval(existingTimer);\n    }\n\n    const timer = setInterval(async () => {\n      if (this.isShuttingDown) return;\n\n      const handler = this.handlers.get(id);\n      const state = this.services.get(id);\n\n      if (!handler || !state || state.status !== 'running') return;\n\n      try {\n        const healthy = await handler.healthCheck();\n        state.metrics.lastHealthCheck = new Date();\n\n        if (healthy) {\n          state.metrics.healthStatus = 'healthy';\n        } else {\n          state.metrics.healthStatus = 'degraded';\n          logger.warn(`Service ${state.name} health check returned unhealthy`);\n        }\n\n        this.emit('healthCheck', { id, healthy });\n      } catch (error) {\n        state.metrics.healthStatus = 'unhealthy';\n        state.metrics.errors++;\n        logger.error(\n          `Service ${state.name} health check failed`,\n          error instanceof Error ? error : undefined,\n        );\n        this.emit('healthCheck', { id, healthy: false });\n      }\n    }, interval);\n\n    this.healthCheckTimers.set(id, timer);\n    logger.debug(`Started health checks for ${id} every ${interval}ms`);\n  }\n\n  /**\n   * Stop health checks for a service.\n   */\n  private stopHealthCheck(id: string): void {\n    const timer = this.healthCheckTimers.get(id);\n    if (timer) {\n      clearInterval(timer);\n      this.healthCheckTimers.delete(id);\n    }\n  }\n\n  /**\n   * Unregister a service.\n   *\n   * @param id - Service identifier\n   */\n  async unregister(id: string): Promise<void> {\n    const state = this.services.get(id);\n    if (!state) return;\n\n    // Stop if running\n    if (state.status === 'running' || state.status === 'starting') {\n      await this.stop(id);\n    }\n\n    // Clean up\n    this.stopHealthCheck(id);\n    this.services.delete(id);\n    this.handlers.delete(id);\n    this.configs.delete(id);\n\n    logger.info(`Service unregistered: ${state.name}`);\n  }\n\n  /**\n   * Check if manager is shutting down.\n   */\n  get shuttingDown(): boolean {\n    return this.isShuttingDown;\n  }\n\n  /**\n   * Gracefully shutdown all services.\n   */\n  async shutdown(): Promise<void> {\n    if (this.isShuttingDown) {\n      logger.debug('Shutdown already in progress');\n      return;\n    }\n\n    this.isShuttingDown = true;\n    logger.info('Shutting down all services...');\n\n    // Clear all health check timers\n    const timerEntries = Array.from(this.healthCheckTimers.entries());\n    for (const [id, timer] of timerEntries) {\n      clearInterval(timer);\n      logger.debug(`Cleared health check timer for ${id}`);\n    }\n    this.healthCheckTimers.clear();\n\n    // Stop all services in parallel\n    const serviceIds = Array.from(this.services.keys());\n    const stopPromises = serviceIds.map(async id => {\n      try {\n        await this.stop(id);\n      } catch (error) {\n        logger.error(\n          `Error stopping service ${id}`,\n          error instanceof Error ? error : undefined,\n        );\n      }\n    });\n\n    await Promise.allSettled(stopPromises);\n\n    // Clear all maps\n    this.services.clear();\n    this.handlers.clear();\n    this.configs.clear();\n\n    logger.info('All services stopped');\n    this.emit('shutdown');\n  }\n\n  /**\n   * Get aggregate metrics for all services.\n   */\n  getAggregateMetrics(): {\n    totalServices: number;\n    running: number;\n    stopped: number;\n    failed: number;\n    totalRequests: number;\n    totalErrors: number;\n    healthyCount: number;\n  } {\n    const services = this.listServices();\n\n    return {\n      totalServices: services.length,\n      running: services.filter(s => s.status === 'running').length,\n      stopped: services.filter(s => s.status === 'stopped').length,\n      failed: services.filter(s => s.status === 'failed').length,\n      totalRequests: services.reduce((sum, s) => sum + s.metrics.requests, 0),\n      totalErrors: services.reduce((sum, s) => sum + s.metrics.errors, 0),\n      healthyCount: services.filter(s => s.metrics.healthStatus === 'healthy').length,\n    };\n  }\n}\n\n/**\n * Create a new ServiceManager instance.\n *\n * @returns Configured ServiceManager\n */\nexport function createServiceManager(): ServiceManager {\n  return new ServiceManager();\n}\n"],"names":[],"mappings":";;AAqBA,MAAM,SAAS,aAAa,iBAAiB;AAoBtC,MAAM,uBAAuB,aAAa;AAAA,EACvC,+BAA0C,IAAA;AAAA,EAC1C,+BAA4C,IAAA;AAAA,EAC5C,8BAA0C,IAAA;AAAA,EAC1C,wCAAqD,IAAA;AAAA,EACrD,iBAAiB;AAAA,EAEzB,cAAc;AACZ,UAAA;AACA,WAAO,KAAK,4BAA4B;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,SAAS,QAAuB,SAAwC;AAC5E,QAAI,KAAK,SAAS,IAAI,OAAO,EAAE,GAAG;AAChC,YAAM,IAAI,MAAM,WAAW,OAAO,EAAE,qBAAqB;AAAA,IAC3D;AAEA,UAAM,QAAsB;AAAA,MAC1B,IAAI,OAAO;AAAA,MACX,MAAM,OAAO;AAAA,MACb,MAAM,OAAO;AAAA,MACb,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,SAAS;AAAA,QACP,QAAQ;AAAA,QACR,UAAU;AAAA,QACV,QAAQ;AAAA,QACR,cAAc;AAAA,MAAA;AAAA,IAChB;AAGF,SAAK,SAAS,IAAI,OAAO,IAAI,KAAK;AAClC,SAAK,SAAS,IAAI,OAAO,IAAI,OAAO;AACpC,SAAK,QAAQ,IAAI,OAAO,IAAI,MAAM;AAElC,WAAO,KAAK,uBAAuB,OAAO,IAAI,IAAI;AAAA,MAChD,IAAI,OAAO;AAAA,MACX,MAAM,OAAO;AAAA,MACb,WAAW,OAAO;AAAA,IAAA,CACnB;AACD,SAAK,KAAK,cAAc,KAAK;AAE7B,QAAI,OAAO,WAAW;AACpB,YAAM,KAAK,MAAM,OAAO,EAAE;AAAA,IAC5B;AAEA,QAAI,OAAO,uBAAuB,OAAO,sBAAsB,GAAG;AAChE,WAAK,iBAAiB,OAAO,IAAI,OAAO,mBAAmB;AAAA,IAC7D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,MAAM,IAA2B;AACrC,UAAM,QAAQ,KAAK,SAAS,IAAI,EAAE;AAClC,UAAM,UAAU,KAAK,SAAS,IAAI,EAAE;AAEpC,QAAI,CAAC,SAAS,CAAC,SAAS;AACtB,YAAM,IAAI,MAAM,WAAW,EAAE,YAAY;AAAA,IAC3C;AAEA,QAAI,MAAM,WAAW,aAAa,MAAM,WAAW,YAAY;AAC7D,aAAO,MAAM,WAAW,MAAM,IAAI,YAAY,MAAM,MAAM,EAAE;AAC5D;AAAA,IACF;AAEA,UAAM,SAAS;AACf,SAAK,KAAK,YAAY,KAAK;AAE3B,QAAI;AACF,YAAM,QAAQ,MAAA;AACd,YAAM,SAAS;AACf,YAAM,gCAAgB,KAAA;AACtB,YAAM,YAAY;AAClB,aAAO,KAAK,oBAAoB,MAAM,IAAI,EAAE;AAC5C,WAAK,KAAK,WAAW,KAAK;AAAA,IAC5B,SAAS,OAAO;AACd,YAAM,SAAS;AACf,YAAM,YAAY,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AACvE,YAAM,QAAQ;AACd,aAAO,MAAM,4BAA4B,MAAM,IAAI,IAAI,QAAW,EAAE,OAAO,MAAM,UAAA,CAAW;AAC5F,WAAK,KAAK,UAAU,KAAK;AAGzB,YAAM,KAAK,cAAc,EAAE;AAAA,IAC7B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,KAAK,IAA2B;AACpC,UAAM,QAAQ,KAAK,SAAS,IAAI,EAAE;AAClC,UAAM,UAAU,KAAK,SAAS,IAAI,EAAE;AAEpC,QAAI,CAAC,SAAS,CAAC,SAAS;AACtB,YAAM,IAAI,MAAM,WAAW,EAAE,YAAY;AAAA,IAC3C;AAEA,QAAI,MAAM,WAAW,aAAa,MAAM,WAAW,YAAY;AAC7D,aAAO,MAAM,WAAW,MAAM,IAAI,YAAY,MAAM,MAAM,EAAE;AAC5D;AAAA,IACF;AAEA,UAAM,SAAS;AACf,SAAK,KAAK,YAAY,KAAK;AAE3B,QAAI;AACF,YAAM,QAAQ,KAAA;AACd,YAAM,SAAS;AAGf,UAAI,MAAM,WAAW;AACnB,cAAM,QAAQ,UAAU,KAAK,QAAQ,MAAM,UAAU,QAAA;AAAA,MACvD;AAEA,aAAO,KAAK,oBAAoB,MAAM,IAAI,EAAE;AAC5C,WAAK,KAAK,WAAW,KAAK;AAAA,IAC5B,SAAS,OAAO;AACd,YAAM,SAAS;AACf,YAAM,YAAY,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AACvE,YAAM,QAAQ;AACd,aAAO,MAAM,2BAA2B,MAAM,IAAI,IAAI,QAAW,EAAE,OAAO,MAAM,UAAA,CAAW;AAC3F,WAAK,KAAK,UAAU,KAAK;AAAA,IAC3B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,QAAQ,IAA2B;AACvC,UAAM,QAAQ,KAAK,SAAS,IAAI,EAAE;AAClC,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,MAAM,WAAW,EAAE,YAAY;AAAA,IAC3C;AAEA,WAAO,KAAK,uBAAuB,MAAM,IAAI,EAAE;AAC/C,UAAM;AAEN,UAAM,KAAK,KAAK,EAAE;AAClB,UAAM,KAAK,MAAM,EAAE;AAEnB,SAAK,KAAK,aAAa,KAAK;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,cAAc,IAA2B;AACrD,UAAM,QAAQ,KAAK,SAAS,IAAI,EAAE;AAClC,UAAM,SAAS,KAAK,QAAQ,IAAI,EAAE;AAElC,QAAI,CAAC,SAAS,CAAC,OAAQ;AAEvB,QAAI,CAAC,OAAO,iBAAkB;AAE9B,UAAM,cAAc,OAAO,eAAe;AAC1C,QAAI,MAAM,YAAY,aAAa;AACjC,aAAO,MAAM,WAAW,MAAM,IAAI,2BAA2B,WAAW,GAAG;AAC3E;AAAA,IACF;AAEA,UAAM,QAAQ,OAAO,gBAAgB;AACrC,WAAO,KAAK,0BAA0B,MAAM,IAAI,OAAO,KAAK,IAAI;AAEhE,UAAM,IAAI,QAAQ,CAAA,YAAW,WAAW,SAAS,KAAK,CAAC;AAEvD,QAAI,CAAC,KAAK,kBAAkB,MAAM,WAAW,UAAU;AACrD,YAAM;AACN,YAAM,KAAK,MAAM,EAAE;AAAA,IACrB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAU,IAAsC;AAC9C,UAAM,QAAQ,KAAK,SAAS,IAAI,EAAE;AAClC,QAAI,CAAC,MAAO,QAAO;AAEnB,UAAM,UAAU,KAAK,SAAS,IAAI,EAAE;AACpC,QAAI,WAAW,MAAM,WAAW,WAAW;AAEzC,YAAM,UAAU,QAAQ,WAAA;AACxB,YAAM,UAAU,EAAE,GAAG,MAAM,SAAS,GAAG,QAAA;AAAA,IACzC;AAEA,WAAO,EAAE,GAAG,MAAA;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAA+B;AAC7B,WAAO,MAAM,KAAK,KAAK,SAAS,OAAA,CAAQ,EAAE,IAAI,CAAA,WAAU,EAAE,GAAG,MAAA,EAAQ;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,kBAAkB,MAA8B;AAC9C,WAAO,KAAK,aAAA,EAAe,OAAO,CAAA,MAAK,EAAE,SAAS,IAAI;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,oBAAoB,QAAgC;AAClD,WAAO,KAAK,aAAA,EAAe,OAAO,CAAA,MAAK,EAAE,WAAW,MAAM;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA,EAKQ,iBAAiB,IAAY,UAAwB;AAE3D,UAAM,gBAAgB,KAAK,kBAAkB,IAAI,EAAE;AACnD,QAAI,eAAe;AACjB,oBAAc,aAAa;AAAA,IAC7B;AAEA,UAAM,QAAQ,YAAY,YAAY;AACpC,UAAI,KAAK,eAAgB;AAEzB,YAAM,UAAU,KAAK,SAAS,IAAI,EAAE;AACpC,YAAM,QAAQ,KAAK,SAAS,IAAI,EAAE;AAElC,UAAI,CAAC,WAAW,CAAC,SAAS,MAAM,WAAW,UAAW;AAEtD,UAAI;AACF,cAAM,UAAU,MAAM,QAAQ,YAAA;AAC9B,cAAM,QAAQ,kBAAkB,oBAAI,KAAA;AAEpC,YAAI,SAAS;AACX,gBAAM,QAAQ,eAAe;AAAA,QAC/B,OAAO;AACL,gBAAM,QAAQ,eAAe;AAC7B,iBAAO,KAAK,WAAW,MAAM,IAAI,kCAAkC;AAAA,QACrE;AAEA,aAAK,KAAK,eAAe,EAAE,IAAI,SAAS;AAAA,MAC1C,SAAS,OAAO;AACd,cAAM,QAAQ,eAAe;AAC7B,cAAM,QAAQ;AACd,eAAO;AAAA,UACL,WAAW,MAAM,IAAI;AAAA,UACrB,iBAAiB,QAAQ,QAAQ;AAAA,QAAA;AAEnC,aAAK,KAAK,eAAe,EAAE,IAAI,SAAS,OAAO;AAAA,MACjD;AAAA,IACF,GAAG,QAAQ;AAEX,SAAK,kBAAkB,IAAI,IAAI,KAAK;AACpC,WAAO,MAAM,6BAA6B,EAAE,UAAU,QAAQ,IAAI;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAKQ,gBAAgB,IAAkB;AACxC,UAAM,QAAQ,KAAK,kBAAkB,IAAI,EAAE;AAC3C,QAAI,OAAO;AACT,oBAAc,KAAK;AACnB,WAAK,kBAAkB,OAAO,EAAE;AAAA,IAClC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,WAAW,IAA2B;AAC1C,UAAM,QAAQ,KAAK,SAAS,IAAI,EAAE;AAClC,QAAI,CAAC,MAAO;AAGZ,QAAI,MAAM,WAAW,aAAa,MAAM,WAAW,YAAY;AAC7D,YAAM,KAAK,KAAK,EAAE;AAAA,IACpB;AAGA,SAAK,gBAAgB,EAAE;AACvB,SAAK,SAAS,OAAO,EAAE;AACvB,SAAK,SAAS,OAAO,EAAE;AACvB,SAAK,QAAQ,OAAO,EAAE;AAEtB,WAAO,KAAK,yBAAyB,MAAM,IAAI,EAAE;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,eAAwB;AAC1B,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAA0B;AAC9B,QAAI,KAAK,gBAAgB;AACvB,aAAO,MAAM,8BAA8B;AAC3C;AAAA,IACF;AAEA,SAAK,iBAAiB;AACtB,WAAO,KAAK,+BAA+B;AAG3C,UAAM,eAAe,MAAM,KAAK,KAAK,kBAAkB,SAAS;AAChE,eAAW,CAAC,IAAI,KAAK,KAAK,cAAc;AACtC,oBAAc,KAAK;AACnB,aAAO,MAAM,kCAAkC,EAAE,EAAE;AAAA,IACrD;AACA,SAAK,kBAAkB,MAAA;AAGvB,UAAM,aAAa,MAAM,KAAK,KAAK,SAAS,MAAM;AAClD,UAAM,eAAe,WAAW,IAAI,OAAM,OAAM;AAC9C,UAAI;AACF,cAAM,KAAK,KAAK,EAAE;AAAA,MACpB,SAAS,OAAO;AACd,eAAO;AAAA,UACL,0BAA0B,EAAE;AAAA,UAC5B,iBAAiB,QAAQ,QAAQ;AAAA,QAAA;AAAA,MAErC;AAAA,IACF,CAAC;AAED,UAAM,QAAQ,WAAW,YAAY;AAGrC,SAAK,SAAS,MAAA;AACd,SAAK,SAAS,MAAA;AACd,SAAK,QAAQ,MAAA;AAEb,WAAO,KAAK,sBAAsB;AAClC,SAAK,KAAK,UAAU;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAKA,sBAQE;AACA,UAAM,WAAW,KAAK,aAAA;AAEtB,WAAO;AAAA,MACL,eAAe,SAAS;AAAA,MACxB,SAAS,SAAS,OAAO,OAAK,EAAE,WAAW,SAAS,EAAE;AAAA,MACtD,SAAS,SAAS,OAAO,OAAK,EAAE,WAAW,SAAS,EAAE;AAAA,MACtD,QAAQ,SAAS,OAAO,OAAK,EAAE,WAAW,QAAQ,EAAE;AAAA,MACpD,eAAe,SAAS,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,QAAQ,UAAU,CAAC;AAAA,MACtE,aAAa,SAAS,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,QAAQ,QAAQ,CAAC;AAAA,MAClE,cAAc,SAAS,OAAO,CAAA,MAAK,EAAE,QAAQ,iBAAiB,SAAS,EAAE;AAAA,IAAA;AAAA,EAE7E;AACF;AAOO,SAAS,uBAAuC;AACrD,SAAO,IAAI,eAAA;AACb;"}