{"version":3,"file":"error-recovery.js","sources":["../../src/utils/error-recovery.ts"],"sourcesContent":["/**\n * Error Recovery System\n *\n * Provides intelligent retry strategies with exponential backoff,\n * jitter, and circuit breaker patterns. Based on weaver recovery patterns.\n *\n * @module utils/error-recovery\n */\n\nimport {\n  classifyError,\n  ErrorCategory,\n  type ClassifiedError,\n  isRetryableError,\n  isRateLimitError,\n} from './error-taxonomy.js';\n\n/**\n * Retry configuration options\n */\nexport interface RetryOptions {\n  /** Maximum number of retry attempts (default: 3) */\n  maxRetries?: number;\n\n  /** Initial delay in milliseconds (default: 1000) */\n  initialDelay?: number;\n\n  /** Maximum delay in milliseconds (default: 30000) */\n  maxDelay?: number;\n\n  /** Backoff factor for exponential backoff (default: 2) */\n  backoffFactor?: number;\n\n  /** Whether to add random jitter (default: true) */\n  jitter?: boolean;\n\n  /** Jitter factor (0-1, default: 0.1) */\n  jitterFactor?: number;\n\n  /** Custom function to determine if error is retryable */\n  isRetryable?: (error: unknown) => boolean;\n\n  /** Called before each retry attempt */\n  onRetry?: (error: ClassifiedError, attempt: number, delay: number) => void;\n\n  /** Abort signal for cancellation */\n  signal?: AbortSignal;\n}\n\n/**\n * Result of a retry operation\n */\nexport interface RetryResult<T> {\n  /** Whether the operation succeeded */\n  success: boolean;\n\n  /** The result value (if successful) */\n  value?: T;\n\n  /** The final error (if failed) */\n  error?: ClassifiedError;\n\n  /** Number of attempts made */\n  attempts: number;\n\n  /** Total time spent in milliseconds */\n  totalTime: number;\n}\n\n/**\n * Circuit breaker state\n */\nexport enum CircuitState {\n  CLOSED = 'closed',\n  OPEN = 'open',\n  HALF_OPEN = 'half_open',\n}\n\n/**\n * Circuit breaker configuration\n */\nexport interface CircuitBreakerOptions {\n  /** Number of failures before opening circuit (default: 5) */\n  failureThreshold?: number;\n\n  /** Time in ms before testing circuit again (default: 30000) */\n  resetTimeout?: number;\n\n  /** Number of successful tests before fully closing (default: 2) */\n  successThreshold?: number;\n\n  /** Whether to track errors by type (default: false) */\n  trackByErrorType?: boolean;\n}\n\n/**\n * Circuit breaker for protecting against cascading failures\n */\nexport class CircuitBreaker {\n  private state = CircuitState.CLOSED;\n  private failures = 0;\n  private successCount = 0;\n  private lastFailureTime = 0;\n  private readonly options: Required<CircuitBreakerOptions>;\n\n  constructor(options: CircuitBreakerOptions = {}) {\n    this.options = {\n      failureThreshold: options.failureThreshold ?? 5,\n      resetTimeout: options.resetTimeout ?? 30000,\n      successThreshold: options.successThreshold ?? 2,\n      trackByErrorType: options.trackByErrorType ?? false,\n    };\n  }\n\n  /**\n   * Get current circuit state\n   */\n  getState(): CircuitState {\n    // Check if we should transition from OPEN to HALF_OPEN\n    if (\n      this.state === CircuitState.OPEN &&\n      Date.now() - this.lastFailureTime >= this.options.resetTimeout\n    ) {\n      this.state = CircuitState.HALF_OPEN;\n      this.successCount = 0;\n    }\n    return this.state;\n  }\n\n  /**\n   * Check if circuit allows execution\n   */\n  canExecute(): boolean {\n    const state = this.getState();\n    return state === CircuitState.CLOSED || state === CircuitState.HALF_OPEN;\n  }\n\n  /**\n   * Record a successful execution\n   */\n  recordSuccess(): void {\n    if (this.state === CircuitState.HALF_OPEN) {\n      this.successCount++;\n      if (this.successCount >= this.options.successThreshold) {\n        this.state = CircuitState.CLOSED;\n        this.failures = 0;\n        this.successCount = 0;\n      }\n    } else if (this.state === CircuitState.CLOSED) {\n      // Reset failures on success\n      this.failures = 0;\n    }\n  }\n\n  /**\n   * Record a failed execution\n   */\n  recordFailure(): void {\n    this.failures++;\n    this.lastFailureTime = Date.now();\n\n    if (this.state === CircuitState.HALF_OPEN) {\n      // Any failure in half-open returns to open\n      this.state = CircuitState.OPEN;\n      this.successCount = 0;\n    } else if (this.failures >= this.options.failureThreshold) {\n      this.state = CircuitState.OPEN;\n    }\n  }\n\n  /**\n   * Reset the circuit breaker\n   */\n  reset(): void {\n    this.state = CircuitState.CLOSED;\n    this.failures = 0;\n    this.successCount = 0;\n    this.lastFailureTime = 0;\n  }\n}\n\n/**\n * Calculate delay with exponential backoff\n *\n * @param attempt - The current attempt number (1-based)\n * @param options - Retry options\n * @returns Delay in milliseconds\n */\nexport function calculateBackoff(\n  attempt: number,\n  options: Pick<RetryOptions, 'initialDelay' | 'maxDelay' | 'backoffFactor' | 'jitter' | 'jitterFactor'> = {}\n): number {\n  const initialDelay = options.initialDelay ?? 1000;\n  const maxDelay = options.maxDelay ?? 30000;\n  const backoffFactor = options.backoffFactor ?? 2;\n  const jitter = options.jitter ?? true;\n  const jitterFactor = options.jitterFactor ?? 0.1;\n\n  // Calculate exponential delay\n  let delay = initialDelay * Math.pow(backoffFactor, attempt - 1);\n\n  // Cap at maximum\n  delay = Math.min(delay, maxDelay);\n\n  // Add jitter if enabled\n  if (jitter) {\n    const jitterAmount = delay * jitterFactor;\n    delay = delay + (Math.random() * 2 - 1) * jitterAmount;\n  }\n\n  return Math.round(delay);\n}\n\n/**\n * Sleep for specified duration\n *\n * @param ms - Duration in milliseconds\n * @param signal - Optional abort signal\n */\nexport function sleep(ms: number, signal?: AbortSignal): Promise<void> {\n  return new Promise((resolve, reject) => {\n    if (signal?.aborted) {\n      reject(new Error('Aborted'));\n      return;\n    }\n\n    const timeout = setTimeout(resolve, ms);\n\n    signal?.addEventListener('abort', () => {\n      clearTimeout(timeout);\n      reject(new Error('Aborted'));\n    });\n  });\n}\n\n/**\n * Execute operation with automatic retry\n *\n * @param operation - The async operation to execute\n * @param options - Retry configuration\n * @returns Result containing value or error\n *\n * @example\n * ```typescript\n * const result = await withRetry(\n *   () => fetchData(),\n *   { maxRetries: 5, onRetry: (err, attempt) => console.log(`Retry ${attempt}`) }\n * );\n *\n * if (result.success) {\n *   console.log('Data:', result.value);\n * } else {\n *   console.error('Failed after', result.attempts, 'attempts');\n * }\n * ```\n */\nexport async function withRetry<T>(\n  operation: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<RetryResult<T>> {\n  const maxRetries = options.maxRetries ?? 3;\n  const isRetryable = options.isRetryable ?? isRetryableError;\n\n  const startTime = Date.now();\n  let attempt = 0;\n  let lastError: ClassifiedError | undefined;\n\n  while (attempt <= maxRetries) {\n    try {\n      // Check for abort\n      if (options.signal?.aborted) {\n        throw new Error('Operation aborted');\n      }\n\n      const value = await operation();\n      return {\n        success: true,\n        value,\n        attempts: attempt + 1,\n        totalTime: Date.now() - startTime,\n      };\n    } catch (error) {\n      const classified = classifyError(error);\n      lastError = classified;\n      attempt++;\n\n      // Don't retry if we've exhausted attempts\n      if (attempt > maxRetries) {\n        break;\n      }\n\n      // Don't retry non-retryable errors\n      if (!isRetryable(error)) {\n        break;\n      }\n\n      // Calculate delay\n      let delay = calculateBackoff(attempt, options);\n\n      // Use suggested delay for rate limits (often includes Retry-After header)\n      if (isRateLimitError(error) && classified.suggestedDelay > delay) {\n        delay = classified.suggestedDelay;\n      }\n\n      // Notify about retry\n      options.onRetry?.(classified, attempt, delay);\n\n      // Wait before retry\n      try {\n        await sleep(delay, options.signal);\n      } catch {\n        // Aborted during sleep\n        break;\n      }\n    }\n  }\n\n  return {\n    success: false,\n    error: lastError,\n    attempts: attempt,\n    totalTime: Date.now() - startTime,\n  };\n}\n\n/**\n * Execute operation with automatic retry (throws on failure)\n *\n * @param operation - The async operation to execute\n * @param options - Retry configuration\n * @returns The operation result\n * @throws The last error if all retries fail\n *\n * @example\n * ```typescript\n * try {\n *   const data = await retry(() => fetchData(), { maxRetries: 3 });\n *   console.log('Data:', data);\n * } catch (error) {\n *   console.error('All retries failed:', error);\n * }\n * ```\n */\nexport async function retry<T>(\n  operation: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const result = await withRetry(operation, options);\n\n  if (result.success) {\n    return result.value as T;\n  }\n\n  // Throw the original error\n  throw result.error?.original ?? new Error('Operation failed');\n}\n\n/**\n * Fallback chain options\n */\nexport interface FallbackOptions<T> {\n  /** Called when primary operation fails */\n  onFallback?: (error: ClassifiedError, index: number) => void;\n\n  /** Abort signal */\n  signal?: AbortSignal;\n\n  /** Default value if all operations fail */\n  defaultValue?: T;\n}\n\n/**\n * Execute with fallback chain\n *\n * Tries each operation in sequence until one succeeds.\n *\n * @param operations - Array of fallback operations\n * @param options - Fallback configuration\n * @returns The first successful result or default value\n *\n * @example\n * ```typescript\n * const data = await withFallback(\n *   [\n *     () => fetchFromPrimary(),\n *     () => fetchFromSecondary(),\n *     () => fetchFromCache(),\n *   ],\n *   { defaultValue: { cached: true, data: [] } }\n * );\n * ```\n */\nexport async function withFallback<T>(\n  operations: Array<() => Promise<T>>,\n  options: FallbackOptions<T> = {}\n): Promise<T> {\n  if (operations.length === 0) {\n    if (options.defaultValue !== undefined) {\n      return options.defaultValue;\n    }\n    throw new Error('No fallback operations provided');\n  }\n\n  let lastError: ClassifiedError | undefined;\n\n  for (let i = 0; i < operations.length; i++) {\n    try {\n      if (options.signal?.aborted) {\n        throw new Error('Operation aborted');\n      }\n\n      return await operations[i]();\n    } catch (error) {\n      const classified = classifyError(error);\n      lastError = classified;\n      options.onFallback?.(classified, i);\n    }\n  }\n\n  if (options.defaultValue !== undefined) {\n    return options.defaultValue;\n  }\n\n  throw lastError?.original ?? new Error('All fallback operations failed');\n}\n\n/**\n * Execute with circuit breaker\n *\n * @param operation - The operation to execute\n * @param breaker - Circuit breaker instance\n * @returns The operation result\n * @throws If circuit is open or operation fails\n */\nexport async function withCircuitBreaker<T>(\n  operation: () => Promise<T>,\n  breaker: CircuitBreaker\n): Promise<T> {\n  if (!breaker.canExecute()) {\n    throw new Error('Circuit breaker is open');\n  }\n\n  try {\n    const result = await operation();\n    breaker.recordSuccess();\n    return result;\n  } catch (error) {\n    breaker.recordFailure();\n    throw error;\n  }\n}\n\n/**\n * Create a retryable version of an async function\n *\n * @param fn - The async function to wrap\n * @param options - Default retry options\n * @returns A new function that automatically retries on failure\n *\n * @example\n * ```typescript\n * const fetchWithRetry = retryable(\n *   (url: string) => fetch(url),\n *   { maxRetries: 3 }\n * );\n *\n * const response = await fetchWithRetry('https://api.example.com/data');\n * ```\n */\nexport function retryable<TArgs extends unknown[], TResult>(\n  fn: (...args: TArgs) => Promise<TResult>,\n  options: RetryOptions = {}\n): (...args: TArgs) => Promise<TResult> {\n  return (...args: TArgs) => retry(() => fn(...args), options);\n}\n\n/**\n * Error class for retries exhausted\n */\nexport class RetriesExhaustedError extends Error {\n  public readonly lastError: ClassifiedError;\n  public readonly attempts: number;\n\n  constructor(lastError: ClassifiedError, attempts: number) {\n    super(`All ${attempts} retry attempts exhausted: ${lastError.message}`);\n    this.name = 'RetriesExhaustedError';\n    this.lastError = lastError;\n    this.attempts = attempts;\n  }\n}\n\n/**\n * Error class for circuit breaker open\n */\nexport class CircuitOpenError extends Error {\n  constructor(message = 'Circuit breaker is open') {\n    super(message);\n    this.name = 'CircuitOpenError';\n  }\n}\n"],"names":["CircuitState"],"mappings":"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"}