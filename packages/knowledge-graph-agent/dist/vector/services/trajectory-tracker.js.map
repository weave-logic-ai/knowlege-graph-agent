{"version":3,"file":"trajectory-tracker.js","sources":["../../../src/vector/services/trajectory-tracker.ts"],"sourcesContent":["/**\n * Trajectory Tracker\n *\n * Records agent operation sequences for pattern learning.\n * Integrates with the SONA (Self-Optimizing Neural Architecture) engine.\n *\n * The trajectory tracker provides:\n * - Recording of agent operation trajectories\n * - Pattern detection from historical trajectories\n * - Learning records for SONA integration\n * - Success/failure analysis\n * - Recommendations based on learned patterns\n *\n * @module vector/services/trajectory-tracker\n *\n * @example\n * ```typescript\n * import { createTrajectoryTracker } from './trajectory-tracker.js';\n *\n * const tracker = createTrajectoryTracker({\n *   maxTrajectories: 1000,\n *   enableAutoLearning: true,\n * });\n *\n * // Start a new trajectory\n * const trajectoryId = tracker.startTrajectory('agent-1', 'workflow-1');\n *\n * // Add steps as the agent works\n * tracker.addStep(trajectoryId, {\n *   action: 'analyze_document',\n *   state: { documentId: 'doc-123', status: 'processing' },\n *   outcome: 'success',\n *   duration: 1500,\n * });\n *\n * // Finalize when done\n * tracker.finalizeTrajectory(trajectoryId, { success: true });\n *\n * // Get recommendations for future actions\n * const recommendations = tracker.getRecommendedActions('analyze_document');\n * ```\n */\n\nimport type {\n  TrajectoryStep,\n  AgentTrajectory,\n  SonaLearningRecord,\n} from '../types.js';\nimport { createLogger } from '../../utils/index.js';\n\nconst logger = createLogger('trajectory-tracker');\n\n/**\n * Trajectory tracker configuration\n *\n * @property maxTrajectories - Maximum number of trajectories to keep in memory\n * @property maxStepsPerTrajectory - Maximum steps per trajectory\n * @property enableAutoLearning - Enable auto-learning from successful trajectories\n * @property minSuccessRateForLearning - Minimum success rate to learn from\n * @property patternThreshold - Number of occurrences before pattern is learned\n */\nexport interface TrajectoryTrackerConfig {\n  /** Maximum number of trajectories to keep in memory */\n  maxTrajectories?: number;\n  /** Maximum steps per trajectory */\n  maxStepsPerTrajectory?: number;\n  /** Enable auto-learning from successful trajectories */\n  enableAutoLearning?: boolean;\n  /** Minimum success rate to learn from */\n  minSuccessRateForLearning?: number;\n  /** Pattern extraction threshold */\n  patternThreshold?: number;\n}\n\n/**\n * Active trajectory being recorded\n * @internal\n */\ninterface ActiveTrajectory {\n  trajectory: AgentTrajectory;\n  startTime: number;\n}\n\n/**\n * Pattern detected from trajectories\n *\n * Represents a sequence of actions that has been observed multiple times\n * and can be used to predict or recommend future actions.\n */\nexport interface DetectedPattern {\n  /** Unique identifier for this pattern */\n  id: string;\n\n  /** Type of pattern (success, failure, or optimization opportunity) */\n  type: 'success' | 'failure' | 'optimization';\n\n  /** Sequence of actions in this pattern */\n  actions: string[];\n\n  /** Number of times this pattern has been observed */\n  frequency: number;\n\n  /** Average duration of trajectories with this pattern */\n  avgDuration: number;\n\n  /** Success rate of trajectories with this pattern */\n  successRate: number;\n\n  /** Confidence level in this pattern (0-1) */\n  confidence: number;\n\n  /** Additional metadata about the pattern */\n  metadata: Record<string, unknown>;\n}\n\n/**\n * Trajectory Tracker class\n *\n * Provides comprehensive tracking and learning from agent operation sequences.\n * This is a core component for the SONA (Self-Optimizing Neural Architecture)\n * system, enabling agents to learn from past experiences and improve over time.\n *\n * Key capabilities:\n * - **Recording**: Track agent operations as trajectories\n * - **Pattern Detection**: Identify recurring action sequences\n * - **Learning**: Create learning records from successful patterns\n * - **Recommendations**: Suggest next actions based on patterns\n * - **Analytics**: Provide statistics on trajectory performance\n *\n * @example\n * ```typescript\n * const tracker = new TrajectoryTracker({\n *   maxTrajectories: 500,\n *   enableAutoLearning: true,\n *   patternThreshold: 5,\n * });\n *\n * // Use throughout agent lifecycle\n * const id = tracker.startTrajectory('my-agent');\n * tracker.addStep(id, { action: 'step1', outcome: 'success' });\n * tracker.addStep(id, { action: 'step2', outcome: 'success' });\n * const trajectory = tracker.finalizeTrajectory(id, { success: true });\n *\n * // Analyze patterns\n * const patterns = tracker.getPatterns({ minConfidence: 0.8 });\n * ```\n */\nexport class TrajectoryTracker {\n  private config: Required<TrajectoryTrackerConfig>;\n  private activeTrajectories: Map<string, ActiveTrajectory> = new Map();\n  private completedTrajectories: AgentTrajectory[] = [];\n  private learningRecords: SonaLearningRecord[] = [];\n  private detectedPatterns: Map<string, DetectedPattern> = new Map();\n\n  /**\n   * Create a new TrajectoryTracker instance\n   *\n   * @param config - Configuration options for the tracker\n   */\n  constructor(config: TrajectoryTrackerConfig = {}) {\n    this.config = {\n      maxTrajectories: config.maxTrajectories ?? 1000,\n      maxStepsPerTrajectory: config.maxStepsPerTrajectory ?? 100,\n      enableAutoLearning: config.enableAutoLearning ?? true,\n      minSuccessRateForLearning: config.minSuccessRateForLearning ?? 0.7,\n      patternThreshold: config.patternThreshold ?? 3,\n    };\n  }\n\n  /**\n   * Start a new trajectory for an agent\n   *\n   * Creates a new trajectory record that will track the agent's operations.\n   * The trajectory must be finalized with `finalizeTrajectory` when complete.\n   *\n   * @param agentId - Unique identifier for the agent\n   * @param workflowId - Optional workflow this trajectory belongs to\n   * @param metadata - Optional additional metadata\n   * @returns The unique trajectory ID for tracking\n   *\n   * @example\n   * ```typescript\n   * const trajectoryId = tracker.startTrajectory(\n   *   'researcher-agent-1',\n   *   'research-workflow-123',\n   *   { priority: 'high', source: 'user-request' }\n   * );\n   * ```\n   */\n  startTrajectory(\n    agentId: string,\n    workflowId?: string,\n    metadata?: Record<string, unknown>\n  ): string {\n    const trajectoryId = `traj-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    const trajectory: AgentTrajectory = {\n      id: trajectoryId,\n      agentId,\n      workflowId,\n      steps: [],\n      startedAt: new Date(),\n      success: false,\n      totalDuration: 0,\n      metadata,\n    };\n\n    this.activeTrajectories.set(trajectoryId, {\n      trajectory,\n      startTime: Date.now(),\n    });\n\n    logger.debug('Started trajectory', { trajectoryId, agentId, workflowId });\n    return trajectoryId;\n  }\n\n  /**\n   * Add a step to an active trajectory\n   *\n   * Records a single operation/action taken by the agent as part of\n   * the trajectory. Steps are added in order and include timing information.\n   *\n   * @param trajectoryId - The trajectory to add the step to\n   * @param step - The step data (timestamp is auto-added)\n   *\n   * @example\n   * ```typescript\n   * tracker.addStep(trajectoryId, {\n   *   action: 'analyze_document',\n   *   state: { documentId: 'doc-123', status: 'processing', progress: 0.5 },\n   *   outcome: 'success',\n   *   duration: 2500,\n   *   metadata: { model: 'claude-3-opus' }\n   * });\n   * ```\n   */\n  addStep(\n    trajectoryId: string,\n    step: Omit<TrajectoryStep, 'timestamp'>\n  ): void {\n    const active = this.activeTrajectories.get(trajectoryId);\n    if (!active) {\n      logger.warn('Trajectory not found', { trajectoryId });\n      return;\n    }\n\n    if (active.trajectory.steps.length >= this.config.maxStepsPerTrajectory) {\n      logger.warn('Max steps reached for trajectory', { trajectoryId });\n      return;\n    }\n\n    const fullStep: TrajectoryStep = {\n      ...step,\n      timestamp: new Date(),\n    };\n\n    active.trajectory.steps.push(fullStep);\n    logger.debug('Added step to trajectory', {\n      trajectoryId,\n      action: step.action,\n      outcome: step.outcome,\n    });\n  }\n\n  /**\n   * Finalize a trajectory\n   *\n   * Marks a trajectory as complete, calculates total duration, and\n   * optionally triggers pattern learning if auto-learning is enabled.\n   *\n   * @param trajectoryId - The trajectory to finalize\n   * @param options - Finalization options including success status\n   * @returns The finalized trajectory, or null if not found\n   *\n   * @example\n   * ```typescript\n   * const trajectory = tracker.finalizeTrajectory(trajectoryId, {\n   *   success: true,\n   *   metadata: { finalScore: 0.95 }\n   * });\n   *\n   * if (trajectory) {\n   *   console.log(`Completed in ${trajectory.totalDuration}ms`);\n   * }\n   * ```\n   */\n  finalizeTrajectory(\n    trajectoryId: string,\n    options: {\n      success: boolean;\n      metadata?: Record<string, unknown>;\n    }\n  ): AgentTrajectory | null {\n    const active = this.activeTrajectories.get(trajectoryId);\n    if (!active) {\n      logger.warn('Trajectory not found for finalization', { trajectoryId });\n      return null;\n    }\n\n    const trajectory = active.trajectory;\n    trajectory.completedAt = new Date();\n    trajectory.success = options.success;\n    trajectory.totalDuration = Date.now() - active.startTime;\n\n    if (options.metadata) {\n      trajectory.metadata = { ...trajectory.metadata, ...options.metadata };\n    }\n\n    // Move to completed\n    this.activeTrajectories.delete(trajectoryId);\n    this.completedTrajectories.push(trajectory);\n\n    // Prune old trajectories\n    while (this.completedTrajectories.length > this.config.maxTrajectories) {\n      this.completedTrajectories.shift();\n    }\n\n    // Auto-learn if enabled\n    if (this.config.enableAutoLearning && options.success) {\n      this.learnFromTrajectory(trajectory);\n    }\n\n    logger.info('Finalized trajectory', {\n      trajectoryId,\n      success: options.success,\n      steps: trajectory.steps.length,\n      duration: trajectory.totalDuration,\n    });\n\n    return trajectory;\n  }\n\n  /**\n   * Learn patterns from a successful trajectory\n   *\n   * Extracts action sequences from the trajectory and updates pattern\n   * frequency and confidence metrics. Creates learning records when\n   * patterns exceed the configured threshold.\n   *\n   * @param trajectory - The trajectory to learn from\n   * @internal\n   */\n  private learnFromTrajectory(trajectory: AgentTrajectory): void {\n    if (trajectory.steps.length < 2) return;\n\n    // Extract action sequence\n    const actions = trajectory.steps.map((s) => s.action);\n    const patternId = this.generatePatternId(actions);\n\n    // Check if pattern exists\n    const existing = this.detectedPatterns.get(patternId);\n    if (existing) {\n      // Update existing pattern\n      existing.frequency++;\n      existing.avgDuration =\n        (existing.avgDuration + trajectory.totalDuration) / 2;\n      existing.successRate = trajectory.success\n        ? (existing.successRate * (existing.frequency - 1) + 1) /\n          existing.frequency\n        : (existing.successRate * (existing.frequency - 1)) /\n          existing.frequency;\n      existing.confidence = Math.min(1, existing.frequency / 10);\n    } else {\n      // Create new pattern\n      const pattern: DetectedPattern = {\n        id: patternId,\n        type: 'success',\n        actions,\n        frequency: 1,\n        avgDuration: trajectory.totalDuration,\n        successRate: trajectory.success ? 1 : 0,\n        confidence: 0.1,\n        metadata: {},\n      };\n      this.detectedPatterns.set(patternId, pattern);\n    }\n\n    // Create learning record when pattern exceeds threshold\n    if (\n      this.detectedPatterns.get(patternId)!.frequency >=\n      this.config.patternThreshold\n    ) {\n      const record: SonaLearningRecord = {\n        trajectoryId: trajectory.id,\n        patternId,\n        patternType: 'success',\n        confidence: this.detectedPatterns.get(patternId)!.confidence,\n        learnedAt: new Date(),\n        appliedCount: 0,\n      };\n      this.learningRecords.push(record);\n\n      logger.info('Learned pattern from trajectory', {\n        patternId,\n        frequency: this.detectedPatterns.get(patternId)!.frequency,\n      });\n    }\n  }\n\n  /**\n   * Generate a pattern ID from action sequence\n   *\n   * Creates a unique identifier for a pattern by joining action names.\n   *\n   * @param actions - Array of action names\n   * @returns Pattern identifier string\n   * @internal\n   */\n  private generatePatternId(actions: string[]): string {\n    return actions.join('->');\n  }\n\n  /**\n   * Get recommended actions based on current state\n   *\n   * Analyzes detected patterns to suggest the most likely next actions\n   * based on the current action being performed.\n   *\n   * @param currentAction - The action currently being performed\n   * @param context - Optional context for more targeted recommendations\n   * @returns Array of recommended actions sorted by confidence\n   *\n   * @example\n   * ```typescript\n   * const recommendations = tracker.getRecommendedActions('analyze_document');\n   *\n   * for (const rec of recommendations) {\n   *   console.log(`Suggested: ${rec.action} (${rec.confidence.toFixed(2)} confidence)`);\n   * }\n   * ```\n   */\n  getRecommendedActions(\n    currentAction: string,\n    context?: Record<string, unknown>\n  ): Array<{ action: string; confidence: number; basedOn: string }> {\n    const recommendations: Array<{\n      action: string;\n      confidence: number;\n      basedOn: string;\n    }> = [];\n\n    for (const [patternId, pattern] of this.detectedPatterns) {\n      const actionIndex = pattern.actions.indexOf(currentAction);\n      if (actionIndex >= 0 && actionIndex < pattern.actions.length - 1) {\n        const nextAction = pattern.actions[actionIndex + 1];\n        recommendations.push({\n          action: nextAction,\n          confidence: pattern.confidence * pattern.successRate,\n          basedOn: patternId,\n        });\n      }\n    }\n\n    // Sort by confidence (highest first)\n    recommendations.sort((a, b) => b.confidence - a.confidence);\n    return recommendations.slice(0, 5);\n  }\n\n  /**\n   * Get trajectory by ID\n   *\n   * Retrieves a trajectory from either active or completed trajectories.\n   *\n   * @param trajectoryId - The trajectory ID to look up\n   * @returns The trajectory if found, null otherwise\n   */\n  getTrajectory(trajectoryId: string): AgentTrajectory | null {\n    // Check active first\n    const active = this.activeTrajectories.get(trajectoryId);\n    if (active) return active.trajectory;\n\n    // Check completed\n    return (\n      this.completedTrajectories.find((t) => t.id === trajectoryId) || null\n    );\n  }\n\n  /**\n   * Get all trajectories for an agent\n   *\n   * Retrieves all completed trajectories that were executed by a specific agent.\n   *\n   * @param agentId - The agent ID to filter by\n   * @returns Array of trajectories for the agent\n   */\n  getAgentTrajectories(agentId: string): AgentTrajectory[] {\n    return this.completedTrajectories.filter((t) => t.agentId === agentId);\n  }\n\n  /**\n   * Get trajectories for a workflow\n   *\n   * Retrieves all completed trajectories that belong to a specific workflow.\n   *\n   * @param workflowId - The workflow ID to filter by\n   * @returns Array of trajectories for the workflow\n   */\n  getWorkflowTrajectories(workflowId: string): AgentTrajectory[] {\n    return this.completedTrajectories.filter((t) => t.workflowId === workflowId);\n  }\n\n  /**\n   * Get detected patterns\n   *\n   * Retrieves patterns that have been detected from trajectory analysis,\n   * optionally filtered by confidence level or pattern type.\n   *\n   * @param options - Filter options\n   * @returns Array of patterns sorted by confidence\n   *\n   * @example\n   * ```typescript\n   * // Get high-confidence success patterns\n   * const patterns = tracker.getPatterns({\n   *   minConfidence: 0.8,\n   *   type: 'success'\n   * });\n   * ```\n   */\n  getPatterns(options?: {\n    minConfidence?: number;\n    type?: 'success' | 'failure' | 'optimization';\n  }): DetectedPattern[] {\n    let patterns = Array.from(this.detectedPatterns.values());\n\n    if (options?.minConfidence !== undefined) {\n      const minConf = options.minConfidence;\n      patterns = patterns.filter((p) => p.confidence >= minConf);\n    }\n\n    if (options?.type) {\n      patterns = patterns.filter((p) => p.type === options.type);\n    }\n\n    return patterns.sort((a, b) => b.confidence - a.confidence);\n  }\n\n  /**\n   * Get learning records\n   *\n   * Retrieves SONA learning records, optionally filtered by pattern ID\n   * or time range.\n   *\n   * @param options - Filter options\n   * @returns Array of learning records\n   *\n   * @example\n   * ```typescript\n   * // Get recent learning records\n   * const records = tracker.getLearningRecords({\n   *   since: new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours\n   * });\n   * ```\n   */\n  getLearningRecords(options?: {\n    patternId?: string;\n    since?: Date;\n  }): SonaLearningRecord[] {\n    let records = [...this.learningRecords];\n\n    if (options?.patternId) {\n      records = records.filter((r) => r.patternId === options.patternId);\n    }\n\n    if (options?.since !== undefined) {\n      const sinceDate = options.since;\n      records = records.filter((r) => r.learnedAt >= sinceDate);\n    }\n\n    return records;\n  }\n\n  /**\n   * Get statistics about trajectory tracking\n   *\n   * Provides aggregate statistics about trajectories, patterns,\n   * and learning performance.\n   *\n   * @returns Statistics object with counts and rates\n   *\n   * @example\n   * ```typescript\n   * const stats = tracker.getStats();\n   * console.log(`Success rate: ${(stats.successRate * 100).toFixed(1)}%`);\n   * console.log(`Patterns detected: ${stats.detectedPatterns}`);\n   * ```\n   */\n  getStats(): {\n    activeTrajectories: number;\n    completedTrajectories: number;\n    detectedPatterns: number;\n    learningRecords: number;\n    successRate: number;\n    avgDuration: number;\n  } {\n    const completed = this.completedTrajectories;\n    const successCount = completed.filter((t) => t.success).length;\n    const totalDuration = completed.reduce((sum, t) => sum + t.totalDuration, 0);\n\n    return {\n      activeTrajectories: this.activeTrajectories.size,\n      completedTrajectories: completed.length,\n      detectedPatterns: this.detectedPatterns.size,\n      learningRecords: this.learningRecords.length,\n      successRate: completed.length > 0 ? successCount / completed.length : 0,\n      avgDuration: completed.length > 0 ? totalDuration / completed.length : 0,\n    };\n  }\n\n  /**\n   * Clear all trajectory data\n   *\n   * Removes all active trajectories, completed trajectories, learning records,\n   * and detected patterns. Use with caution as this is irreversible.\n   */\n  clear(): void {\n    this.activeTrajectories.clear();\n    this.completedTrajectories = [];\n    this.learningRecords = [];\n    this.detectedPatterns.clear();\n    logger.info('Trajectory tracker cleared');\n  }\n\n  /**\n   * Export data for persistence\n   *\n   * Serializes all trajectory data for storage or transfer.\n   * Use with `import()` to restore data.\n   *\n   * @returns Exportable data object\n   *\n   * @example\n   * ```typescript\n   * const data = tracker.export();\n   * await fs.writeFile('trajectories.json', JSON.stringify(data));\n   * ```\n   */\n  export(): {\n    trajectories: AgentTrajectory[];\n    patterns: DetectedPattern[];\n    learningRecords: SonaLearningRecord[];\n  } {\n    return {\n      trajectories: [...this.completedTrajectories],\n      patterns: Array.from(this.detectedPatterns.values()),\n      learningRecords: [...this.learningRecords],\n    };\n  }\n\n  /**\n   * Import data from persistence\n   *\n   * Restores trajectory data from a previous export.\n   *\n   * @param data - Previously exported data object\n   *\n   * @example\n   * ```typescript\n   * const data = JSON.parse(await fs.readFile('trajectories.json', 'utf-8'));\n   * tracker.import(data);\n   * ```\n   */\n  import(data: {\n    trajectories?: AgentTrajectory[];\n    patterns?: DetectedPattern[];\n    learningRecords?: SonaLearningRecord[];\n  }): void {\n    if (data.trajectories) {\n      this.completedTrajectories = data.trajectories.slice(\n        -this.config.maxTrajectories\n      );\n    }\n    if (data.patterns) {\n      for (const pattern of data.patterns) {\n        this.detectedPatterns.set(pattern.id, pattern);\n      }\n    }\n    if (data.learningRecords) {\n      this.learningRecords = data.learningRecords;\n    }\n    logger.info('Imported trajectory data', {\n      trajectories: this.completedTrajectories.length,\n      patterns: this.detectedPatterns.size,\n      learningRecords: this.learningRecords.length,\n    });\n  }\n}\n\n/**\n * Create a trajectory tracker instance\n *\n * Factory function for creating a TrajectoryTracker with the specified\n * configuration.\n *\n * @param config - Optional configuration options\n * @returns New TrajectoryTracker instance\n *\n * @example\n * ```typescript\n * import { createTrajectoryTracker } from './trajectory-tracker.js';\n *\n * const tracker = createTrajectoryTracker({\n *   maxTrajectories: 500,\n *   enableAutoLearning: true,\n *   patternThreshold: 5,\n * });\n * ```\n */\nexport function createTrajectoryTracker(\n  config?: TrajectoryTrackerConfig\n): TrajectoryTracker {\n  return new TrajectoryTracker(config);\n}\n"],"names":[],"mappings":"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"}