/**
 * Docs Directory Initializer
 *
 * Creates the initial docs directory structure following the weave-nn
 * methodology with proper PRIMITIVES.md taxonomy.
 *
 * SECURITY NOTES (Handlebars Templates):
 * - All templates use double-braces {{}} which HTML-escapes output
 * - Triple-braces {{{raw}}} are NOT used, preventing injection attacks
 * - Template variables come from internal sources (project analysis), not direct user input
 * - See: https://handlebarsjs.com/guide/#html-escaping
 */

import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';
import { join, basename } from 'path';
import fg from 'fast-glob';
import Handlebars from 'handlebars';
import type {
  DocsInitOptions,
  DocsInitResult,
  NodeType,
} from '../core/types.js';

/**
 * Default docs structure based on PRIMITIVES.md taxonomy
 */
const DEFAULT_STRUCTURE = {
  directories: [
    // Core concepts
    'concepts',
    'concepts/architecture',
    'concepts/patterns',

    // Components
    'components',
    'components/ui',
    'components/utilities',

    // Services
    'services',
    'services/api',
    'services/workers',

    // Features
    'features',
    'features/core',
    'features/advanced',

    // Integrations
    'integrations',
    'integrations/databases',
    'integrations/auth-providers',
    'integrations/storage',
    'integrations/monitoring',

    // Standards
    'standards',
    'standards/coding-standards',
    'standards/programming-languages',
    'standards/build-tools',

    // Guides
    'guides',
    'guides/getting-started',
    'guides/testing',
    'guides/deployment',

    // References
    'references',
    'references/api',
    'references/cli',

    // Meta
    '_templates',
    '_attachments',
  ],
  files: {
    'README.md': 'readme',
    'PRIMITIVES.md': 'primitives',
    'MOC.md': 'moc',
    '_templates/concept.md': 'template-concept',
    '_templates/technical.md': 'template-technical',
    '_templates/feature.md': 'template-feature',
    '_templates/service.md': 'template-service',
    '_templates/guide.md': 'template-guide',
  },
};

/**
 * Template content for docs files
 */
const TEMPLATES: Record<string, string> = {
  readme: `# {{projectName}} Documentation

Welcome to the {{projectName}} knowledge base.

## Quick Navigation

- [[MOC|Map of Content]] - Overview of all documentation
- [[PRIMITIVES|Primitives]] - Core building blocks and technologies

## Structure

This documentation follows the Weave-NN knowledge graph methodology:

\`\`\`
docs/
├── concepts/       # Abstract concepts and ideas
├── components/     # Reusable components and utilities
├── services/       # Backend services and APIs
├── features/       # Product features and capabilities
├── integrations/   # External integrations
├── standards/      # Coding standards and conventions
├── guides/         # How-to guides and tutorials
└── references/     # API and CLI references
\`\`\`

## Getting Started

1. Browse the [[MOC|Map of Content]] for an overview
2. Check [[PRIMITIVES]] for technology decisions
3. Read [[guides/getting-started/index|Getting Started Guide]]

---
*Generated by @weave-nn/knowledge-graph-agent*
`,

  primitives: `# Primitives

Core building blocks and technology decisions for {{projectName}}.

## Overview

Primitives are the foundational technologies that power this project. Each primitive represents a key technology choice with its rationale and usage patterns.

## Categories

### Languages
{{#each languages}}
- [[standards/programming-languages/{{this}}|{{this}}]]
{{/each}}

### Frameworks
{{#each frameworks}}
- [[{{category}}/{{slug}}|{{name}}]]
{{/each}}

### Key Dependencies
{{#each dependencies}}
- [[{{category}}/{{slug}}|{{name}}]] - {{description}}
{{/each}}

## Technology Decisions

| Category | Choice | Rationale |
|----------|--------|-----------|
| Runtime | Node.js | Modern JavaScript runtime |
| Language | TypeScript | Type safety and DX |
| Package Manager | npm/bun | Fast, reliable |

---
*Generated by @weave-nn/knowledge-graph-agent*
`,

  moc: `# Map of Content

Central navigation hub for {{projectName}} documentation.

## Core Concepts
{{#each concepts}}
- [[concepts/{{this}}]]
{{/each}}
{{#unless concepts}}
- *No concepts documented yet*
{{/unless}}

## Components
{{#each components}}
- [[components/{{this}}]]
{{/each}}
{{#unless components}}
- *No components documented yet*
{{/unless}}

## Services
{{#each services}}
- [[services/{{this}}]]
{{/each}}
{{#unless services}}
- *No services documented yet*
{{/unless}}

## Features
{{#each features}}
- [[features/{{this}}]]
{{/each}}
{{#unless features}}
- *No features documented yet*
{{/unless}}

## Guides
- [[guides/getting-started/index|Getting Started]]
- [[guides/testing/index|Testing Guide]]
- [[guides/deployment/index|Deployment Guide]]

## References
- [[references/api/index|API Reference]]
- [[references/cli/index|CLI Reference]]

---
*Last updated: {{date}}*
`,

  'template-concept': `---
title: {{title}}
type: concept
status: draft
tags: [concept]
created: {{date}}
updated: {{date}}
---

# {{title}}

## Overview

Brief description of this concept.

## Key Ideas

- Point 1
- Point 2
- Point 3

## Related Concepts

- [[related-concept-1]]
- [[related-concept-2]]

## References

- External reference 1
- External reference 2
`,

  'template-technical': `---
title: {{title}}
type: technical
status: draft
tags: [technical]
created: {{date}}
updated: {{date}}
---

# {{title}}

## Overview

Brief description of this technical component.

## Implementation

\`\`\`typescript
// Code example
\`\`\`

## Usage

How to use this component.

## Configuration

Available configuration options.

## Related

- [[related-technical-1]]
`,

  'template-feature': `---
title: {{title}}
type: feature
status: draft
tags: [feature]
created: {{date}}
updated: {{date}}
---

# {{title}}

## Overview

Brief description of this feature.

## User Story

As a [user type], I want [goal] so that [benefit].

## Acceptance Criteria

- [ ] Criterion 1
- [ ] Criterion 2
- [ ] Criterion 3

## Technical Implementation

How this feature is implemented.

## Related Features

- [[related-feature-1]]
`,

  'template-service': `---
title: {{title}}
type: service
status: draft
tags: [service, api]
created: {{date}}
updated: {{date}}
---

# {{title}}

## Overview

Brief description of this service.

## Endpoints

| Method | Path | Description |
|--------|------|-------------|
| GET | /api/... | Description |
| POST | /api/... | Description |

## Configuration

Environment variables and configuration options.

## Dependencies

- [[dependency-1]]
- [[dependency-2]]

## Deployment

Deployment instructions.
`,

  'template-guide': `---
title: {{title}}
type: guide
status: draft
tags: [guide, tutorial]
created: {{date}}
updated: {{date}}
---

# {{title}}

## Prerequisites

- Prerequisite 1
- Prerequisite 2

## Steps

### Step 1: Title

Instructions for step 1.

### Step 2: Title

Instructions for step 2.

### Step 3: Title

Instructions for step 3.

## Troubleshooting

Common issues and solutions.

## Next Steps

- [[next-guide-1]]
- [[next-guide-2]]
`,
};

/**
 * Framework detection result
 */
interface FrameworkInfo {
  name: string;
  slug: string;
  category: string;
  version?: string;
}

/**
 * Initialize docs directory
 */
export async function initDocs(options: DocsInitOptions): Promise<DocsInitResult> {
  const result: DocsInitResult = {
    success: true,
    docsPath: '',
    filesCreated: [],
    errors: [],
  };

  try {
    const { projectRoot, docsPath = 'docs', includeExamples = true, detectFramework = true } = options;
    const fullDocsPath = join(projectRoot, docsPath);
    result.docsPath = fullDocsPath;

    // Detect project information
    const projectName = await detectProjectName(projectRoot);
    const frameworks = detectFramework ? await detectFrameworks(projectRoot) : [];
    const languages = detectFramework ? await detectLanguages(projectRoot) : [];
    const dependencies = detectFramework ? await detectDependencies(projectRoot) : [];

    // Create template context
    const context = {
      projectName,
      date: new Date().toISOString().split('T')[0],
      frameworks,
      languages,
      dependencies,
      concepts: [],
      components: [],
      services: [],
      features: [],
    };

    // Create directories
    for (const dir of DEFAULT_STRUCTURE.directories) {
      const dirPath = join(fullDocsPath, dir);
      if (!existsSync(dirPath)) {
        mkdirSync(dirPath, { recursive: true });
        result.filesCreated.push(dirPath);
      }
    }

    // Create files from templates
    for (const [filePath, templateName] of Object.entries(DEFAULT_STRUCTURE.files)) {
      const fullPath = join(fullDocsPath, filePath);

      // Skip if file exists
      if (existsSync(fullPath)) {
        continue;
      }

      // Get template and compile
      const template = TEMPLATES[templateName];
      if (!template) {
        result.errors.push(`Template not found: ${templateName}`);
        continue;
      }

      try {
        const compiled = Handlebars.compile(template);
        const content = compiled(context);
        writeFileSync(fullPath, content, 'utf-8');
        result.filesCreated.push(fullPath);
      } catch (error) {
        result.errors.push(`Failed to create ${filePath}: ${error}`);
      }
    }

    // Create example files if requested
    if (includeExamples) {
      await createExampleFiles(fullDocsPath, context, result);
    }

    // Create .obsidian folder for vault detection
    const obsidianPath = join(fullDocsPath, '.obsidian');
    if (!existsSync(obsidianPath)) {
      mkdirSync(obsidianPath, { recursive: true });

      // Create minimal app.json for Obsidian
      const appJson = {
        "legacyEditor": false,
        "livePreview": true,
      };
      writeFileSync(join(obsidianPath, 'app.json'), JSON.stringify(appJson, null, 2));
      result.filesCreated.push(obsidianPath);
    }

    result.success = result.errors.length === 0;
  } catch (error) {
    result.success = false;
    result.errors.push(`Init failed: ${error}`);
  }

  return result;
}

/**
 * Detect project name from package.json or directory
 */
async function detectProjectName(projectRoot: string): Promise<string> {
  try {
    const pkgPath = join(projectRoot, 'package.json');
    if (existsSync(pkgPath)) {
      const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));
      if (pkg.name) {
        // Remove scope if present
        return pkg.name.replace(/^@[^/]+\//, '');
      }
    }
  } catch {
    // Ignore errors
  }

  // Fall back to directory name
  return basename(projectRoot);
}

/**
 * Detect frameworks from project files
 */
async function detectFrameworks(projectRoot: string): Promise<FrameworkInfo[]> {
  const frameworks: FrameworkInfo[] = [];

  try {
    const pkgPath = join(projectRoot, 'package.json');
    if (existsSync(pkgPath)) {
      const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));
      const deps = { ...pkg.dependencies, ...pkg.devDependencies };

      // Framework detection patterns
      const patterns: Array<{ name: string; packages: string[]; category: string }> = [
        { name: 'React', packages: ['react'], category: 'components/ui' },
        { name: 'Next.js', packages: ['next'], category: 'services/api' },
        { name: 'Vue', packages: ['vue'], category: 'components/ui' },
        { name: 'Express', packages: ['express'], category: 'services/api' },
        { name: 'Fastify', packages: ['fastify'], category: 'services/api' },
        { name: 'Prisma', packages: ['@prisma/client', 'prisma'], category: 'integrations/databases' },
        { name: 'TypeORM', packages: ['typeorm'], category: 'integrations/databases' },
        { name: 'Jest', packages: ['jest'], category: 'guides/testing' },
        { name: 'Vitest', packages: ['vitest'], category: 'guides/testing' },
        { name: 'Vite', packages: ['vite'], category: 'standards/build-tools' },
        { name: 'Webpack', packages: ['webpack'], category: 'standards/build-tools' },
      ];

      for (const pattern of patterns) {
        for (const pkg of pattern.packages) {
          if (deps[pkg]) {
            frameworks.push({
              name: pattern.name,
              slug: pattern.name.toLowerCase().replace(/[^a-z0-9]+/g, '-'),
              category: pattern.category,
              version: deps[pkg],
            });
            break;
          }
        }
      }
    }
  } catch {
    // Ignore errors
  }

  return frameworks;
}

/**
 * Detect programming languages used
 */
async function detectLanguages(projectRoot: string): Promise<string[]> {
  const languages: Set<string> = new Set();

  try {
    // Check for TypeScript
    if (existsSync(join(projectRoot, 'tsconfig.json'))) {
      languages.add('typescript');
    }

    // Check for package.json (JavaScript/Node.js)
    if (existsSync(join(projectRoot, 'package.json'))) {
      languages.add('javascript');
    }

    // Check for Python
    if (existsSync(join(projectRoot, 'requirements.txt')) ||
        existsSync(join(projectRoot, 'pyproject.toml'))) {
      languages.add('python');
    }

    // Check for Rust
    if (existsSync(join(projectRoot, 'Cargo.toml'))) {
      languages.add('rust');
    }

    // Check for Go
    if (existsSync(join(projectRoot, 'go.mod'))) {
      languages.add('go');
    }
  } catch {
    // Ignore errors
  }

  return Array.from(languages);
}

/**
 * Detect major dependencies
 */
async function detectDependencies(projectRoot: string): Promise<Array<{ name: string; slug: string; category: string; description: string }>> {
  const deps: Array<{ name: string; slug: string; category: string; description: string }> = [];

  try {
    const pkgPath = join(projectRoot, 'package.json');
    if (existsSync(pkgPath)) {
      const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));
      const allDeps = { ...pkg.dependencies };

      // Top dependencies to document
      const topDeps = Object.keys(allDeps).slice(0, 10);

      for (const dep of topDeps) {
        deps.push({
          name: dep,
          slug: dep.replace(/^@/, '').replace(/[^a-z0-9]+/g, '-'),
          category: 'components/utilities',
          description: `Version ${allDeps[dep]}`,
        });
      }
    }
  } catch {
    // Ignore errors
  }

  return deps;
}

/**
 * Create example documentation files
 */
async function createExampleFiles(
  docsPath: string,
  context: Record<string, unknown>,
  result: DocsInitResult
): Promise<void> {
  const examples = [
    {
      path: 'guides/getting-started/index.md',
      content: `---
title: Getting Started
type: guide
status: active
tags: [guide, getting-started]
created: ${context.date}
updated: ${context.date}
---

# Getting Started with ${context.projectName}

Welcome! This guide will help you get up and running.

## Prerequisites

- Node.js 20+
- npm or bun

## Installation

\`\`\`bash
npm install
\`\`\`

## Quick Start

1. Clone the repository
2. Install dependencies
3. Run the development server

## Next Steps

- Explore the [[MOC|Map of Content]]
- Review [[PRIMITIVES|Technology Primitives]]
`,
    },
    {
      path: 'concepts/architecture/index.md',
      content: `---
title: Architecture Overview
type: concept
status: active
tags: [architecture, concept]
created: ${context.date}
updated: ${context.date}
---

# Architecture Overview

High-level architecture of ${context.projectName}.

## System Diagram

\`\`\`
┌──────────────┐     ┌──────────────┐
│   Frontend   │────▶│   Backend    │
└──────────────┘     └──────────────┘
                            │
                     ┌──────▼──────┐
                     │   Database  │
                     └─────────────┘
\`\`\`

## Key Components

- **Frontend**: User interface
- **Backend**: API and business logic
- **Database**: Data persistence

## Design Principles

1. Separation of concerns
2. Single responsibility
3. Dependency injection
`,
    },
  ];

  for (const example of examples) {
    const fullPath = join(docsPath, example.path);
    if (!existsSync(fullPath)) {
      const dir = join(fullPath, '..');
      if (!existsSync(dir)) {
        mkdirSync(dir, { recursive: true });
      }
      writeFileSync(fullPath, example.content, 'utf-8');
      result.filesCreated.push(fullPath);
    }
  }
}

/**
 * Check if docs directory exists
 */
export function docsExist(projectRoot: string, docsPath = 'docs'): boolean {
  return existsSync(join(projectRoot, docsPath));
}

/**
 * Get docs path for a project
 */
export function getDocsPath(projectRoot: string): string | null {
  const possiblePaths = ['docs', 'documentation', 'doc', 'wiki'];

  for (const path of possiblePaths) {
    const fullPath = join(projectRoot, path);
    if (existsSync(fullPath)) {
      return fullPath;
    }
  }

  return null;
}
