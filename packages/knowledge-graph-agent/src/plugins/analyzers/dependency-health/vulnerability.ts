/**
 * Vulnerability Checker
 *
 * Checks npm dependencies for known security vulnerabilities
 * by parsing npm audit output and analyzing CVE data.
 *
 * @module plugins/analyzers/dependency-health/vulnerability
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { existsSync } from 'fs';
import { join } from 'path';
import { createLogger } from '../../../utils/logger.js';
import type {
  AuditReport,
  AuditFinding,
  VulnerabilityInfo,
  VulnerabilitySeverity,
  DependencyHealthConfig,
} from './types.js';

const execAsync = promisify(exec);
const logger = createLogger('vulnerability-checker');

/**
 * Result of vulnerability check
 */
export interface VulnerabilityCheckResult {
  /** Whether the check succeeded */
  success: boolean;
  /** Raw audit report */
  report: AuditReport | null;
  /** Parsed vulnerabilities by package */
  vulnerabilities: Map<string, VulnerabilityInfo[]>;
  /** Summary counts */
  summary: {
    critical: number;
    high: number;
    moderate: number;
    low: number;
    info: number;
    total: number;
  };
  /** Error message if check failed */
  error?: string;
}

/**
 * Severity order for comparison
 */
const SEVERITY_ORDER: Record<VulnerabilitySeverity, number> = {
  info: 0,
  low: 1,
  moderate: 2,
  high: 3,
  critical: 4,
};

/**
 * Check if severity meets threshold
 */
export function meetsThreshold(
  severity: VulnerabilitySeverity,
  threshold: VulnerabilitySeverity
): boolean {
  return SEVERITY_ORDER[severity] >= SEVERITY_ORDER[threshold];
}

/**
 * Get maximum severity from a list
 */
export function getMaxSeverity(
  severities: VulnerabilitySeverity[]
): VulnerabilitySeverity {
  if (severities.length === 0) return 'info';

  let max: VulnerabilitySeverity = 'info';
  for (const severity of severities) {
    if (SEVERITY_ORDER[severity] > SEVERITY_ORDER[max]) {
      max = severity;
    }
  }
  return max;
}

/**
 * VulnerabilityChecker class
 */
export class VulnerabilityChecker {
  private projectRoot: string;
  private config: DependencyHealthConfig;

  constructor(projectRoot: string, config: Partial<DependencyHealthConfig> = {}) {
    this.projectRoot = projectRoot;
    this.config = {
      vulnerabilitySeverityThreshold: config.vulnerabilitySeverityThreshold ?? 'low',
      timeout: config.timeout ?? 60000,
      ...config,
    } as DependencyHealthConfig;
  }

  /**
   * Run npm audit and parse results
   */
  async checkVulnerabilities(): Promise<VulnerabilityCheckResult> {
    const result: VulnerabilityCheckResult = {
      success: false,
      report: null,
      vulnerabilities: new Map(),
      summary: {
        critical: 0,
        high: 0,
        moderate: 0,
        low: 0,
        info: 0,
        total: 0,
      },
    };

    // Check if package-lock.json exists
    const lockFilePath = join(this.projectRoot, 'package-lock.json');
    if (!existsSync(lockFilePath)) {
      logger.warn('No package-lock.json found, skipping vulnerability check');
      result.error = 'No package-lock.json found';
      return result;
    }

    try {
      logger.info('Running npm audit', { projectRoot: this.projectRoot });

      // Run npm audit with JSON output
      // We use --json flag and don't throw on non-zero exit (audit exits non-zero if vulnerabilities found)
      const { stdout, stderr } = await execAsync(
        'npm audit --json 2>/dev/null || true',
        {
          cwd: this.projectRoot,
          timeout: this.config.timeout,
          maxBuffer: 10 * 1024 * 1024, // 10MB buffer for large audits
        }
      );

      if (!stdout.trim()) {
        logger.info('npm audit returned empty result (no vulnerabilities or error)');
        result.success = true;
        return result;
      }

      // Parse the JSON output
      let auditData: AuditReport;
      try {
        auditData = JSON.parse(stdout);
      } catch (parseError) {
        logger.error('Failed to parse npm audit output', parseError instanceof Error ? parseError : undefined);
        result.error = 'Failed to parse npm audit output';
        return result;
      }

      result.report = auditData;
      result.success = true;

      // Extract vulnerability counts from metadata
      if (auditData.metadata?.vulnerabilities) {
        result.summary = {
          critical: auditData.metadata.vulnerabilities.critical ?? 0,
          high: auditData.metadata.vulnerabilities.high ?? 0,
          moderate: auditData.metadata.vulnerabilities.moderate ?? 0,
          low: auditData.metadata.vulnerabilities.low ?? 0,
          info: auditData.metadata.vulnerabilities.info ?? 0,
          total: auditData.metadata.vulnerabilities.total ?? 0,
        };
      }

      // Parse vulnerabilities by package
      if (auditData.vulnerabilities) {
        for (const [packageName, finding] of Object.entries(auditData.vulnerabilities)) {
          const vulnInfo = this.parseAuditFinding(packageName, finding);
          if (vulnInfo.length > 0) {
            result.vulnerabilities.set(packageName, vulnInfo);
          }
        }
      }

      logger.info('Vulnerability check complete', {
        total: result.summary.total,
        critical: result.summary.critical,
        high: result.summary.high,
        moderate: result.summary.moderate,
      });

    } catch (error) {
      logger.error('npm audit failed', error instanceof Error ? error : undefined);
      result.error = error instanceof Error ? error.message : String(error);
    }

    return result;
  }

  /**
   * Parse an audit finding into vulnerability info
   */
  private parseAuditFinding(packageName: string, finding: AuditFinding): VulnerabilityInfo[] {
    const vulnerabilities: VulnerabilityInfo[] = [];

    // Create a vulnerability entry from the finding
    const vuln: VulnerabilityInfo = {
      id: `npm-audit-${packageName}`,
      title: `Vulnerability in ${packageName}`,
      severity: finding.severity,
      vulnerableVersions: finding.range,
      patchedVersions: this.extractPatchedVersion(finding.fixAvailable),
      recommendation: this.generateRecommendation(finding),
      references: [],
    };

    // Filter by threshold
    if (meetsThreshold(vuln.severity, this.config.vulnerabilitySeverityThreshold!)) {
      vulnerabilities.push(vuln);
    }

    return vulnerabilities;
  }

  /**
   * Extract patched version from fix info
   */
  private extractPatchedVersion(
    fixAvailable: boolean | { name: string; version: string; isSemVerMajor: boolean }
  ): string | null {
    if (typeof fixAvailable === 'boolean') {
      return fixAvailable ? 'Fix available' : null;
    }
    return `${fixAvailable.name}@${fixAvailable.version}`;
  }

  /**
   * Generate recommendation text
   */
  private generateRecommendation(finding: AuditFinding): string {
    if (typeof finding.fixAvailable === 'boolean') {
      if (finding.fixAvailable) {
        return `Run 'npm audit fix' to resolve this vulnerability`;
      }
      return 'No automatic fix available. Manual intervention required.';
    }

    const fix = finding.fixAvailable;
    if (fix.isSemVerMajor) {
      return `Update to ${fix.name}@${fix.version} (breaking change)`;
    }
    return `Update to ${fix.name}@${fix.version}`;
  }

  /**
   * Get vulnerabilities for a specific package
   */
  async getPackageVulnerabilities(packageName: string): Promise<VulnerabilityInfo[]> {
    const result = await this.checkVulnerabilities();
    return result.vulnerabilities.get(packageName) ?? [];
  }

  /**
   * Check if a package has critical vulnerabilities
   */
  async hasCriticalVulnerabilities(packageName: string): Promise<boolean> {
    const vulns = await this.getPackageVulnerabilities(packageName);
    return vulns.some(v => v.severity === 'critical' || v.severity === 'high');
  }

  /**
   * Get security score based on vulnerabilities (100 = no vulns, 0 = critical vulns)
   */
  calculateSecurityScore(vulnerabilities: VulnerabilityInfo[]): number {
    if (vulnerabilities.length === 0) {
      return 100;
    }

    let score = 100;

    for (const vuln of vulnerabilities) {
      switch (vuln.severity) {
        case 'critical':
          score -= 40;
          break;
        case 'high':
          score -= 25;
          break;
        case 'moderate':
          score -= 10;
          break;
        case 'low':
          score -= 5;
          break;
        case 'info':
          score -= 1;
          break;
      }
    }

    return Math.max(0, score);
  }
}

/**
 * Create a vulnerability checker instance
 */
export function createVulnerabilityChecker(
  projectRoot: string,
  config?: Partial<DependencyHealthConfig>
): VulnerabilityChecker {
  return new VulnerabilityChecker(projectRoot, config);
}
