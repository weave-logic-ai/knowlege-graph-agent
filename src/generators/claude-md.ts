/**
 * CLAUDE.md Generator
 *
 * Generates and manages CLAUDE.md configuration files for Claude Code
 * with knowledge graph integration.
 *
 * SECURITY NOTES (Handlebars Templates):
 * - All templates use double-braces {{}} which HTML-escapes output
 * - Triple-braces {{{raw}}} are NOT used, preventing XSS in HTML contexts
 * - User input is sanitized via sanitizeTemplateInput() before template use
 * - Template content is validated and Handlebars delimiters are stripped from user input
 * - See: https://handlebarsjs.com/guide/#html-escaping
 */

import { existsSync, readFileSync, writeFileSync } from 'fs';
import { join, basename, resolve, normalize } from 'path';
import Handlebars from 'handlebars';
import type {
  ClaudeMdGeneratorOptions,
  ClaudeMdSection,
  ClaudeMdTemplate,
} from '../core/types.js';

/**
 * Validate that a template path is within the project directory
 * and is a markdown file
 */
function validateTemplatePath(projectRoot: string, templatePath: string): string | null {
  // Resolve both paths to absolute
  const resolvedRoot = resolve(projectRoot);
  const resolvedTemplate = resolve(projectRoot, templatePath);
  const normalizedTemplate = normalize(resolvedTemplate);

  // Ensure template is within project directory
  if (!normalizedTemplate.startsWith(resolvedRoot + '/') && normalizedTemplate !== resolvedRoot) {
    return null; // Path traversal attempt
  }

  // Must be a markdown file
  if (!normalizedTemplate.endsWith('.md')) {
    return null;
  }

  return normalizedTemplate;
}

/**
 * Default CLAUDE.md template with knowledge graph integration
 */
const DEFAULT_TEMPLATE = `# Claude Code Configuration - {{projectName}}

## Project Overview

{{description}}

## Knowledge Graph Integration

This project uses @weavelogic/knowledge-graph-agent for documentation and planning.

### Quick Commands

\`\`\`bash
# Initialize knowledge graph
npx kg init

# Generate/update graph from docs
npx kg graph

# Sync with claude-flow memory
npx kg sync

# Initialize docs directory
npx kg docs init

# Update CLAUDE.md
npx kg claude update
\`\`\`

### Vault Location

Documentation is stored in: \`{{docsPath}}\`

## File Organization

{{#if customDirectories}}
{{#each customDirectories}}
- \`{{this.path}}\` - {{this.description}}
{{/each}}
{{else}}
- \`/src\` - Source code files
- \`/docs\` - Documentation and knowledge base
- \`/tests\` - Test files
- \`/config\` - Configuration files
{{/if}}

## Build Commands

{{#each buildCommands}}
- \`{{this.command}}\` - {{this.description}}
{{/each}}

## Code Style & Best Practices

{{#each codeStyleRules}}
- **{{this.name}}**: {{this.description}}
{{/each}}

{{#if includeClaudeFlow}}
## Claude-Flow Integration

This project uses claude-flow for AI coordination:

### MCP Configuration

\`\`\`bash
claude mcp add claude-flow npx claude-flow@alpha mcp start
\`\`\`

### Memory Namespace

- **Namespace**: \`{{namespace}}\`
- **Sync on change**: {{syncOnChange}}

### Available Tools

- \`mcp__claude-flow__memory_usage\` - Store/retrieve knowledge
- \`mcp__claude-flow__swarm_init\` - Initialize agent swarms
- \`mcp__claude-flow__task_orchestrate\` - Coordinate tasks

{{/if}}
{{#if includeKnowledgeGraph}}
## Knowledge Graph Commands

The knowledge graph provides semantic navigation of the codebase:

### CLI Commands

| Command | Description |
|---------|-------------|
| \`kg init\` | Initialize knowledge graph in project |
| \`kg graph\` | Generate/update knowledge graph |
| \`kg docs init\` | Initialize docs directory |
| \`kg docs generate\` | Generate docs from codebase |
| \`kg claude update\` | Update CLAUDE.md |
| \`kg sync\` | Sync with claude-flow memory |
| \`kg stats\` | Show graph statistics |
| \`kg search <query>\` | Search the knowledge graph |

### Graph Structure

\`\`\`
{{docsPath}}/
├── concepts/        # Abstract concepts
├── components/      # Reusable components
├── services/        # Backend services
├── features/        # Product features
├── integrations/    # External integrations
├── standards/       # Coding standards
├── guides/          # How-to guides
└── references/      # API references
\`\`\`

{{/if}}
{{#if customSections}}
{{#each customSections}}
## {{this.title}}

{{this.content}}

{{/each}}
{{/if}}
## Important Instructions

- NEVER create files unless absolutely necessary
- ALWAYS prefer editing existing files
- Use the knowledge graph for documentation
- Follow the file organization above
- Run tests before committing

---
*Generated by @weavelogic/knowledge-graph-agent*
`;

/**
 * Section templates for common configurations
 */
const SECTION_TEMPLATES: Record<string, ClaudeMdSection> = {
  sparc: {
    title: 'SPARC Methodology',
    order: 10,
    content: `This project follows the SPARC development methodology:

1. **Specification** - Requirements analysis
2. **Pseudocode** - Algorithm design
3. **Architecture** - System design
4. **Refinement** - TDD implementation
5. **Completion** - Integration

### SPARC Commands

\`\`\`bash
npx claude-flow sparc modes        # List available modes
npx claude-flow sparc tdd "<task>" # Run TDD workflow
npx claude-flow sparc run <mode>   # Execute specific mode
\`\`\``,
  },

  testing: {
    title: 'Testing Requirements',
    order: 20,
    content: `All code changes must include appropriate tests:

- **Unit tests**: For individual functions and components
- **Integration tests**: For API endpoints and services
- **E2E tests**: For critical user flows

### Running Tests

\`\`\`bash
npm run test         # Run all tests
npm run test:watch   # Watch mode
npm run test:cov     # With coverage
\`\`\``,
  },

  security: {
    title: 'Security Guidelines',
    order: 30,
    content: `Security is a priority. Follow these guidelines:

- Never hardcode secrets or API keys
- Use environment variables for sensitive data
- Validate all user inputs
- Sanitize outputs to prevent XSS
- Follow OWASP guidelines`,
  },

  agents: {
    title: 'Available Agents',
    order: 40,
    content: `Use Claude Code's Task tool to spawn specialized agents:

### Core Agents
\`coder\`, \`reviewer\`, \`tester\`, \`planner\`, \`researcher\`

### SPARC Agents
\`sparc-coord\`, \`sparc-coder\`, \`specification\`, \`architecture\`

### Specialized Agents
\`backend-dev\`, \`system-architect\`, \`code-analyzer\`, \`api-docs\`

### Usage

\`\`\`javascript
Task("Implement feature", "Description...", "coder")
Task("Review code", "Description...", "reviewer")
\`\`\``,
  },
};

/**
 * Generate CLAUDE.md content
 */
export function generateClaudeMd(options: ClaudeMdGeneratorOptions): string {
  const {
    projectRoot,
    template,
    includeKnowledgeGraph = true,
    includeClaudeFlow = true,
    customSections = [],
  } = options;

  // Detect project info
  const projectInfo = detectProjectInfo(projectRoot);

  // Prepare context
  const context = {
    projectName: projectInfo.name,
    description: projectInfo.description || `${projectInfo.name} project`,
    docsPath: getDocsPath(projectRoot),
    includeKnowledgeGraph,
    includeClaudeFlow,
    namespace: 'knowledge-graph',
    syncOnChange: true,
    buildCommands: projectInfo.scripts,
    codeStyleRules: getDefaultCodeStyleRules(),
    customSections: [...customSections],
    customDirectories: null,
  };

  // Get template content (pass projectRoot for path validation)
  const templateContent = template ? getTemplateContent(template, projectRoot) : DEFAULT_TEMPLATE;

  // Compile and render
  const compiled = Handlebars.compile(templateContent);
  return compiled(context);
}

/**
 * Create or update CLAUDE.md file
 */
export async function updateClaudeMd(options: ClaudeMdGeneratorOptions): Promise<{
  created: boolean;
  updated: boolean;
  path: string;
  content: string;
}> {
  const { projectRoot, outputPath } = options;
  const filePath = outputPath || join(projectRoot, 'CLAUDE.md');

  const exists = existsSync(filePath);
  const content = generateClaudeMd(options);

  writeFileSync(filePath, content, 'utf-8');

  return {
    created: !exists,
    updated: exists,
    path: filePath,
    content,
  };
}

/**
 * Add section to existing CLAUDE.md
 */
export function addSection(
  projectRoot: string,
  section: ClaudeMdSection
): boolean {
  const filePath = join(projectRoot, 'CLAUDE.md');

  if (!existsSync(filePath)) {
    return false;
  }

  const content = readFileSync(filePath, 'utf-8');

  // Check if section already exists
  const sectionRegex = new RegExp(`^## ${section.title}`, 'm');
  if (sectionRegex.test(content)) {
    return false; // Section already exists
  }

  // Find the best position to insert (before Important Instructions or at end)
  const importantMatch = content.match(/^## Important Instructions/m);
  let newContent: string;

  const sectionContent = `\n## ${section.title}\n\n${section.content}\n`;

  if (importantMatch && importantMatch.index !== undefined) {
    newContent =
      content.slice(0, importantMatch.index) +
      sectionContent +
      '\n' +
      content.slice(importantMatch.index);
  } else {
    newContent = content + sectionContent;
  }

  writeFileSync(filePath, newContent, 'utf-8');
  return true;
}

/**
 * Get predefined section template
 */
export function getSectionTemplate(name: string): ClaudeMdSection | null {
  return SECTION_TEMPLATES[name] || null;
}

/**
 * List available section templates
 */
export function listSectionTemplates(): string[] {
  return Object.keys(SECTION_TEMPLATES);
}

// ============================================================================
// Helper Functions
// ============================================================================

interface ProjectInfo {
  name: string;
  description?: string;
  scripts: Array<{ command: string; description: string }>;
}

/**
 * Sanitize string for safe template use
 * Prevents template injection and removes dangerous characters
 */
function sanitizeForTemplate(str: string | undefined, maxLength = 200): string {
  if (!str || typeof str !== 'string') return '';
  return str
    .replace(/[<>&"'`{}\\]/g, '') // Remove template-sensitive chars
    .replace(/\{\{/g, '')  // Remove Handlebars delimiters
    .replace(/\}\}/g, '')
    .slice(0, maxLength)
    .trim();
}

function detectProjectInfo(projectRoot: string): ProjectInfo {
  const info: ProjectInfo = {
    name: sanitizeForTemplate(basename(projectRoot), 100) || 'project',
    scripts: [],
  };

  try {
    const pkgPath = join(projectRoot, 'package.json');
    if (existsSync(pkgPath)) {
      let pkg;
      try {
        pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));
      } catch {
        return info; // Return default info on JSON parse error
      }

      // Sanitize project name
      const rawName = (pkg.name || basename(projectRoot)).replace(/^@[^/]+\//, '');
      info.name = sanitizeForTemplate(rawName, 100) || 'project';

      // Sanitize description
      info.description = sanitizeForTemplate(pkg.description, 500);

      // Extract common scripts (sanitize script names)
      if (pkg.scripts && typeof pkg.scripts === 'object') {
        const commonScripts = ['build', 'test', 'dev', 'start', 'lint', 'typecheck'];
        for (const script of commonScripts) {
          if (pkg.scripts[script] && typeof pkg.scripts[script] === 'string') {
            info.scripts.push({
              command: `npm run ${script}`,
              description: sanitizeForTemplate(
                getScriptDescription(script, pkg.scripts[script]),
                200
              ),
            });
          }
        }
      }
    }
  } catch {
    // Ignore errors - return default info
  }

  // Add default scripts if none found
  if (info.scripts.length === 0) {
    info.scripts = [
      { command: 'npm run build', description: 'Build the project' },
      { command: 'npm run test', description: 'Run tests' },
      { command: 'npm run dev', description: 'Development mode' },
    ];
  }

  return info;
}

function getScriptDescription(name: string, script: string): string {
  const descriptions: Record<string, string> = {
    build: 'Build the project',
    test: 'Run tests',
    dev: 'Start development server',
    start: 'Start production server',
    lint: 'Run linter',
    typecheck: 'Type checking',
  };

  return descriptions[name] || `Run ${name}`;
}

function getDocsPath(projectRoot: string): string {
  const possiblePaths = ['docs', 'documentation', 'doc'];

  for (const path of possiblePaths) {
    if (existsSync(join(projectRoot, path))) {
      return path;
    }
  }

  return 'docs';
}

function getDefaultCodeStyleRules(): Array<{ name: string; description: string }> {
  return [
    { name: 'Modular Design', description: 'Files under 500 lines' },
    { name: 'Environment Safety', description: 'Never hardcode secrets' },
    { name: 'Test-First', description: 'Write tests before implementation' },
    { name: 'Clean Architecture', description: 'Separate concerns' },
    { name: 'Documentation', description: 'Keep docs updated' },
  ];
}

function getTemplateContent(templateName: string, projectRoot?: string): string {
  // Check for built-in templates
  if (templateName === 'minimal') {
    return `# {{projectName}}

{{description}}

## Commands

{{#each buildCommands}}
- \`{{this.command}}\` - {{this.description}}
{{/each}}

---
*Generated by @weavelogic/knowledge-graph-agent*
`;
  }

  if (templateName === 'full') {
    // Add all sections
    let content = DEFAULT_TEMPLATE;
    for (const section of Object.values(SECTION_TEMPLATES)) {
      content = content.replace(
        /^## Important Instructions/m,
        `## ${section.title}\n\n${section.content}\n\n## Important Instructions`
      );
    }
    return content;
  }

  // Try to read as file path - only if within project directory
  if (projectRoot && (templateName.includes('/') || templateName.includes('.'))) {
    const validatedPath = validateTemplatePath(projectRoot, templateName);
    if (validatedPath && existsSync(validatedPath)) {
      return readFileSync(validatedPath, 'utf-8');
    }
  }

  return DEFAULT_TEMPLATE;
}
